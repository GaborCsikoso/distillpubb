(function () {
	'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function appendNode(node, target) {
		target.appendChild(node);
	}

	function insertNode(node, target, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detach);
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createSvgElement(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function addListener(node, event, handler) {
		node.addEventListener(event, handler, false);
	}

	function removeListener(node, event, handler) {
		node.removeEventListener(event, handler, false);
	}

	function setAttribute(node, attribute, value) {
		node.setAttribute(attribute, value);
	}

	function setXlinkAttribute(node, attribute, value) {
		node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
	}

	function toNumber(value) {
		return value === '' ? undefined : +value;
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				handler.__calling = true;
				handler.call(this, data);
				handler.__calling = false;
			}
		}
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._bind = options._bind;

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		this.root._lock = true;
		callAll(this.root._beforecreate);
		callAll(this.root._oncreate);
		callAll(this.root._aftercreate);
		this.root._lock = false;
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	var proto = {
		destroy,
		get,
		fire,
		on,
		set,
		_recompute: noop,
		_set,
		_mount,
		_differs
	};

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	}

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending);
	var bisectRight = ascendingBisect.right;

	function sequence(start, stop, step) {
	  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	  var i = -1,
	      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	      range = new Array(n);

	  while (++i < n) {
	    range[i] = start + i * step;
	  }

	  return range;
	}

	var e10 = Math.sqrt(50),
	    e5 = Math.sqrt(10),
	    e2 = Math.sqrt(2);

	function ticks(start, stop, count) {
	  var reverse,
	      i = -1,
	      n,
	      ticks,
	      step;

	  stop = +stop, start = +start, count = +count;
	  if (start === stop && count > 0) return [start];
	  if (reverse = stop < start) n = start, start = stop, stop = n;
	  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

	  if (step > 0) {
	    start = Math.ceil(start / step);
	    stop = Math.floor(stop / step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) * step;
	  } else {
	    start = Math.floor(start * step);
	    stop = Math.ceil(stop * step);
	    ticks = new Array(n = Math.ceil(start - stop + 1));
	    while (++i < n) ticks[i] = (start - i) / step;
	  }

	  if (reverse) ticks.reverse();

	  return ticks;
	}

	function tickIncrement(start, stop, count) {
	  var step = (stop - start) / Math.max(0, count),
	      power = Math.floor(Math.log(step) / Math.LN10),
	      error = step / Math.pow(10, power);
	  return power >= 0
	      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
	}

	function tickStep(start, stop, count) {
	  var step0 = Math.abs(stop - start) / Math.max(0, count),
	      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	      error = step0 / step1;
	  if (error >= e10) step1 *= 10;
	  else if (error >= e5) step1 *= 5;
	  else if (error >= e2) step1 *= 2;
	  return stop < start ? -step1 : step1;
	}

	function min(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  return min;
	}

	function transpose(matrix) {
	  if (!(n = matrix.length)) return [];
	  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
	    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
	      row[j] = matrix[j][i];
	    }
	  }
	  return transpose;
	}

	function length(d) {
	  return d.length;
	}

	function zip() {
	  return transpose(arguments);
	}

	var slice$1 = Array.prototype.slice;

	function identity$1(x) {
	  return x;
	}

	var top = 1,
	    right = 2,
	    bottom = 3,
	    left = 4,
	    epsilon = 1e-6;

	function translateX(x) {
	  return "translate(" + (x + 0.5) + ",0)";
	}

	function translateY(y) {
	  return "translate(0," + (y + 0.5) + ")";
	}

	function number$1(scale) {
	  return function(d) {
	    return +scale(d);
	  };
	}

	function center(scale) {
	  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
	  if (scale.round()) offset = Math.round(offset);
	  return function(d) {
	    return +scale(d) + offset;
	  };
	}

	function entering() {
	  return !this.__axis;
	}

	function axis(orient, scale) {
	  var tickArguments = [],
	      tickValues = null,
	      tickFormat = null,
	      tickSizeInner = 6,
	      tickSizeOuter = 6,
	      tickPadding = 3,
	      k = orient === top || orient === left ? -1 : 1,
	      x = orient === left || orient === right ? "x" : "y",
	      transform = orient === top || orient === bottom ? translateX : translateY;

	  function axis(context) {
	    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
	        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1) : tickFormat,
	        spacing = Math.max(tickSizeInner, 0) + tickPadding,
	        range = scale.range(),
	        range0 = +range[0] + 0.5,
	        range1 = +range[range.length - 1] + 0.5,
	        position = (scale.bandwidth ? center : number$1)(scale.copy()),
	        selection = context.selection ? context.selection() : context,
	        path = selection.selectAll(".domain").data([null]),
	        tick = selection.selectAll(".tick").data(values, scale).order(),
	        tickExit = tick.exit(),
	        tickEnter = tick.enter().append("g").attr("class", "tick"),
	        line = tick.select("line"),
	        text = tick.select("text");

	    path = path.merge(path.enter().insert("path", ".tick")
	        .attr("class", "domain")
	        .attr("stroke", "#000"));

	    tick = tick.merge(tickEnter);

	    line = line.merge(tickEnter.append("line")
	        .attr("stroke", "#000")
	        .attr(x + "2", k * tickSizeInner));

	    text = text.merge(tickEnter.append("text")
	        .attr("fill", "#000")
	        .attr(x, k * spacing)
	        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

	    if (context !== selection) {
	      path = path.transition(context);
	      tick = tick.transition(context);
	      line = line.transition(context);
	      text = text.transition(context);

	      tickExit = tickExit.transition(context)
	          .attr("opacity", epsilon)
	          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

	      tickEnter
	          .attr("opacity", epsilon)
	          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
	    }

	    tickExit.remove();

	    path
	        .attr("d", orient === left || orient == right
	            ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
	            : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

	    tick
	        .attr("opacity", 1)
	        .attr("transform", function(d) { return transform(position(d)); });

	    line
	        .attr(x + "2", k * tickSizeInner);

	    text
	        .attr(x, k * spacing)
	        .text(format);

	    selection.filter(entering)
	        .attr("fill", "none")
	        .attr("font-size", 10)
	        .attr("font-family", "sans-serif")
	        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

	    selection
	        .each(function() { this.__axis = position; });
	  }

	  axis.scale = function(_) {
	    return arguments.length ? (scale = _, axis) : scale;
	  };

	  axis.ticks = function() {
	    return tickArguments = slice$1.call(arguments), axis;
	  };

	  axis.tickArguments = function(_) {
	    return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice();
	  };

	  axis.tickValues = function(_) {
	    return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues && tickValues.slice();
	  };

	  axis.tickFormat = function(_) {
	    return arguments.length ? (tickFormat = _, axis) : tickFormat;
	  };

	  axis.tickSize = function(_) {
	    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
	  };

	  axis.tickSizeInner = function(_) {
	    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
	  };

	  axis.tickSizeOuter = function(_) {
	    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
	  };

	  axis.tickPadding = function(_) {
	    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
	  };

	  return axis;
	}

	function axisRight(scale) {
	  return axis(right, scale);
	}

	var noop$1 = {value: function() {}};

	function dispatch() {
	  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
	    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
	    _[t] = [];
	  }
	  return new Dispatch(_);
	}

	function Dispatch(_) {
	  this._ = _;
	}

	function parseTypenames(typenames, types) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
	    return {type: t, name: name};
	  });
	}

	Dispatch.prototype = dispatch.prototype = {
	  constructor: Dispatch,
	  on: function(typename, callback) {
	    var _ = this._,
	        T = parseTypenames(typename + "", _),
	        t,
	        i = -1,
	        n = T.length;

	    // If no callback was specified, return the callback of the given type and name.
	    if (arguments.length < 2) {
	      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
	      return;
	    }

	    // If a type was specified, set the callback for the given type and name.
	    // Otherwise, if a null callback was specified, remove callbacks of the given name.
	    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
	    while (++i < n) {
	      if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
	      else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
	    }

	    return this;
	  },
	  copy: function() {
	    var copy = {}, _ = this._;
	    for (var t in _) copy[t] = _[t].slice();
	    return new Dispatch(copy);
	  },
	  call: function(type, that) {
	    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  },
	  apply: function(type, that, args) {
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  }
	};

	function get$1(type, name) {
	  for (var i = 0, n = type.length, c; i < n; ++i) {
	    if ((c = type[i]).name === name) {
	      return c.value;
	    }
	  }
	}

	function set$1(type, name, callback) {
	  for (var i = 0, n = type.length; i < n; ++i) {
	    if (type[i].name === name) {
	      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
	      break;
	    }
	  }
	  if (callback != null) type.push({name: name, value: callback});
	  return type;
	}

	var xhtml = "http://www.w3.org/1999/xhtml";

	var namespaces = {
	  svg: "http://www.w3.org/2000/svg",
	  xhtml: xhtml,
	  xlink: "http://www.w3.org/1999/xlink",
	  xml: "http://www.w3.org/XML/1998/namespace",
	  xmlns: "http://www.w3.org/2000/xmlns/"
	};

	function namespace(name) {
	  var prefix = name += "", i = prefix.indexOf(":");
	  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
	}

	function creatorInherit(name) {
	  return function() {
	    var document = this.ownerDocument,
	        uri = this.namespaceURI;
	    return uri === xhtml && document.documentElement.namespaceURI === xhtml
	        ? document.createElement(name)
	        : document.createElementNS(uri, name);
	  };
	}

	function creatorFixed(fullname) {
	  return function() {
	    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
	  };
	}

	function creator(name) {
	  var fullname = namespace(name);
	  return (fullname.local
	      ? creatorFixed
	      : creatorInherit)(fullname);
	}

	function none() {}

	function selector(selector) {
	  return selector == null ? none : function() {
	    return this.querySelector(selector);
	  };
	}

	function selection_select(select) {
	  if (typeof select !== "function") select = selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	      }
	    }
	  }

	  return new Selection(subgroups, this._parents);
	}

	function empty() {
	  return [];
	}

	function selectorAll(selector) {
	  return selector == null ? empty : function() {
	    return this.querySelectorAll(selector);
	  };
	}

	function selection_selectAll(select) {
	  if (typeof select !== "function") select = selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        subgroups.push(select.call(node, node.__data__, i, group));
	        parents.push(node);
	      }
	    }
	  }

	  return new Selection(subgroups, parents);
	}

	var matcher = function(selector) {
	  return function() {
	    return this.matches(selector);
	  };
	};

	if (typeof document !== "undefined") {
	  var element = document.documentElement;
	  if (!element.matches) {
	    var vendorMatches = element.webkitMatchesSelector
	        || element.msMatchesSelector
	        || element.mozMatchesSelector
	        || element.oMatchesSelector;
	    matcher = function(selector) {
	      return function() {
	        return vendorMatches.call(this, selector);
	      };
	    };
	  }
	}

	var matcher$1 = matcher;

	function selection_filter(match) {
	  if (typeof match !== "function") match = matcher$1(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Selection(subgroups, this._parents);
	}

	function sparse(update) {
	  return new Array(update.length);
	}

	function selection_enter() {
	  return new Selection(this._enter || this._groups.map(sparse), this._parents);
	}

	function EnterNode(parent, datum) {
	  this.ownerDocument = parent.ownerDocument;
	  this.namespaceURI = parent.namespaceURI;
	  this._next = null;
	  this._parent = parent;
	  this.__data__ = datum;
	}

	EnterNode.prototype = {
	  constructor: EnterNode,
	  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
	  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
	  querySelector: function(selector) { return this._parent.querySelector(selector); },
	  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
	};

	function constant$1(x) {
	  return function() {
	    return x;
	  };
	}

	var keyPrefix = "$"; // Protect against keys like “__proto__”.

	function bindIndex(parent, group, enter, update, exit, data) {
	  var i = 0,
	      node,
	      groupLength = group.length,
	      dataLength = data.length;

	  // Put any non-null nodes that fit into update.
	  // Put any null nodes into enter.
	  // Put any remaining data into enter.
	  for (; i < dataLength; ++i) {
	    if (node = group[i]) {
	      node.__data__ = data[i];
	      update[i] = node;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Put any non-null nodes that don’t fit into exit.
	  for (; i < groupLength; ++i) {
	    if (node = group[i]) {
	      exit[i] = node;
	    }
	  }
	}

	function bindKey(parent, group, enter, update, exit, data, key) {
	  var i,
	      node,
	      nodeByKeyValue = {},
	      groupLength = group.length,
	      dataLength = data.length,
	      keyValues = new Array(groupLength),
	      keyValue;

	  // Compute the key for each node.
	  // If multiple nodes have the same key, the duplicates are added to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if (node = group[i]) {
	      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
	      if (keyValue in nodeByKeyValue) {
	        exit[i] = node;
	      } else {
	        nodeByKeyValue[keyValue] = node;
	      }
	    }
	  }

	  // Compute the key for each datum.
	  // If there a node associated with this key, join and add it to update.
	  // If there is not (or the key is a duplicate), add it to enter.
	  for (i = 0; i < dataLength; ++i) {
	    keyValue = keyPrefix + key.call(parent, data[i], i, data);
	    if (node = nodeByKeyValue[keyValue]) {
	      update[i] = node;
	      node.__data__ = data[i];
	      nodeByKeyValue[keyValue] = null;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Add any remaining nodes that were not bound to data to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
	      exit[i] = node;
	    }
	  }
	}

	function selection_data(value, key) {
	  if (!value) {
	    data = new Array(this.size()), j = -1;
	    this.each(function(d) { data[++j] = d; });
	    return data;
	  }

	  var bind = key ? bindKey : bindIndex,
	      parents = this._parents,
	      groups = this._groups;

	  if (typeof value !== "function") value = constant$1(value);

	  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
	    var parent = parents[j],
	        group = groups[j],
	        groupLength = group.length,
	        data = value.call(parent, parent && parent.__data__, j, parents),
	        dataLength = data.length,
	        enterGroup = enter[j] = new Array(dataLength),
	        updateGroup = update[j] = new Array(dataLength),
	        exitGroup = exit[j] = new Array(groupLength);

	    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

	    // Now connect the enter nodes to their following update node, such that
	    // appendChild can insert the materialized enter node before this node,
	    // rather than at the end of the parent node.
	    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
	      if (previous = enterGroup[i0]) {
	        if (i0 >= i1) i1 = i0 + 1;
	        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
	        previous._next = next || null;
	      }
	    }
	  }

	  update = new Selection(update, parents);
	  update._enter = enter;
	  update._exit = exit;
	  return update;
	}

	function selection_exit() {
	  return new Selection(this._exit || this._groups.map(sparse), this._parents);
	}

	function selection_merge(selection$$1) {

	  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Selection(merges, this._parents);
	}

	function selection_order() {

	  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
	    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
	      if (node = group[i]) {
	        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	        next = node;
	      }
	    }
	  }

	  return this;
	}

	function selection_sort(compare) {
	  if (!compare) compare = ascending$1;

	  function compareNode(a, b) {
	    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
	  }

	  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        sortgroup[i] = node;
	      }
	    }
	    sortgroup.sort(compareNode);
	  }

	  return new Selection(sortgroups, this._parents).order();
	}

	function ascending$1(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function selection_call() {
	  var callback = arguments[0];
	  arguments[0] = this;
	  callback.apply(null, arguments);
	  return this;
	}

	function selection_nodes() {
	  var nodes = new Array(this.size()), i = -1;
	  this.each(function() { nodes[++i] = this; });
	  return nodes;
	}

	function selection_node() {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
	      var node = group[i];
	      if (node) return node;
	    }
	  }

	  return null;
	}

	function selection_size() {
	  var size = 0;
	  this.each(function() { ++size; });
	  return size;
	}

	function selection_empty() {
	  return !this.node();
	}

	function selection_each(callback) {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
	      if (node = group[i]) callback.call(node, node.__data__, i, group);
	    }
	  }

	  return this;
	}

	function attrRemove(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant(name, value) {
	  return function() {
	    this.setAttribute(name, value);
	  };
	}

	function attrConstantNS(fullname, value) {
	  return function() {
	    this.setAttributeNS(fullname.space, fullname.local, value);
	  };
	}

	function attrFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttribute(name);
	    else this.setAttribute(name, v);
	  };
	}

	function attrFunctionNS(fullname, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
	    else this.setAttributeNS(fullname.space, fullname.local, v);
	  };
	}

	function selection_attr(name, value) {
	  var fullname = namespace(name);

	  if (arguments.length < 2) {
	    var node = this.node();
	    return fullname.local
	        ? node.getAttributeNS(fullname.space, fullname.local)
	        : node.getAttribute(fullname);
	  }

	  return this.each((value == null
	      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
	      ? (fullname.local ? attrFunctionNS : attrFunction)
	      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
	}

	function defaultView(node) {
	  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
	      || (node.document && node) // node is a Window
	      || node.defaultView; // node is a Document
	}

	function styleRemove(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant(name, value, priority) {
	  return function() {
	    this.style.setProperty(name, value, priority);
	  };
	}

	function styleFunction(name, value, priority) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.style.removeProperty(name);
	    else this.style.setProperty(name, v, priority);
	  };
	}

	function selection_style(name, value, priority) {
	  return arguments.length > 1
	      ? this.each((value == null
	            ? styleRemove : typeof value === "function"
	            ? styleFunction
	            : styleConstant)(name, value, priority == null ? "" : priority))
	      : styleValue(this.node(), name);
	}

	function styleValue(node, name) {
	  return node.style.getPropertyValue(name)
	      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
	}

	function propertyRemove(name) {
	  return function() {
	    delete this[name];
	  };
	}

	function propertyConstant(name, value) {
	  return function() {
	    this[name] = value;
	  };
	}

	function propertyFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) delete this[name];
	    else this[name] = v;
	  };
	}

	function selection_property(name, value) {
	  return arguments.length > 1
	      ? this.each((value == null
	          ? propertyRemove : typeof value === "function"
	          ? propertyFunction
	          : propertyConstant)(name, value))
	      : this.node()[name];
	}

	function classArray(string) {
	  return string.trim().split(/^|\s+/);
	}

	function classList(node) {
	  return node.classList || new ClassList(node);
	}

	function ClassList(node) {
	  this._node = node;
	  this._names = classArray(node.getAttribute("class") || "");
	}

	ClassList.prototype = {
	  add: function(name) {
	    var i = this._names.indexOf(name);
	    if (i < 0) {
	      this._names.push(name);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  remove: function(name) {
	    var i = this._names.indexOf(name);
	    if (i >= 0) {
	      this._names.splice(i, 1);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  contains: function(name) {
	    return this._names.indexOf(name) >= 0;
	  }
	};

	function classedAdd(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.add(names[i]);
	}

	function classedRemove(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.remove(names[i]);
	}

	function classedTrue(names) {
	  return function() {
	    classedAdd(this, names);
	  };
	}

	function classedFalse(names) {
	  return function() {
	    classedRemove(this, names);
	  };
	}

	function classedFunction(names, value) {
	  return function() {
	    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
	  };
	}

	function selection_classed(name, value) {
	  var names = classArray(name + "");

	  if (arguments.length < 2) {
	    var list = classList(this.node()), i = -1, n = names.length;
	    while (++i < n) if (!list.contains(names[i])) return false;
	    return true;
	  }

	  return this.each((typeof value === "function"
	      ? classedFunction : value
	      ? classedTrue
	      : classedFalse)(names, value));
	}

	function textRemove() {
	  this.textContent = "";
	}

	function textConstant(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.textContent = v == null ? "" : v;
	  };
	}

	function selection_text(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? textRemove : (typeof value === "function"
	          ? textFunction
	          : textConstant)(value))
	      : this.node().textContent;
	}

	function htmlRemove() {
	  this.innerHTML = "";
	}

	function htmlConstant(value) {
	  return function() {
	    this.innerHTML = value;
	  };
	}

	function htmlFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.innerHTML = v == null ? "" : v;
	  };
	}

	function selection_html(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? htmlRemove : (typeof value === "function"
	          ? htmlFunction
	          : htmlConstant)(value))
	      : this.node().innerHTML;
	}

	function raise() {
	  if (this.nextSibling) this.parentNode.appendChild(this);
	}

	function selection_raise() {
	  return this.each(raise);
	}

	function lower() {
	  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
	}

	function selection_lower() {
	  return this.each(lower);
	}

	function selection_append(name) {
	  var create = typeof name === "function" ? name : creator(name);
	  return this.select(function() {
	    return this.appendChild(create.apply(this, arguments));
	  });
	}

	function constantNull() {
	  return null;
	}

	function selection_insert(name, before) {
	  var create = typeof name === "function" ? name : creator(name),
	      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
	  return this.select(function() {
	    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
	  });
	}

	function remove() {
	  var parent = this.parentNode;
	  if (parent) parent.removeChild(this);
	}

	function selection_remove() {
	  return this.each(remove);
	}

	function selection_cloneShallow() {
	  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
	}

	function selection_cloneDeep() {
	  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
	}

	function selection_clone(deep) {
	  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
	}

	function selection_datum(value) {
	  return arguments.length
	      ? this.property("__data__", value)
	      : this.node().__data__;
	}

	var filterEvents = {};

	var event = null;

	if (typeof document !== "undefined") {
	  var element$1 = document.documentElement;
	  if (!("onmouseenter" in element$1)) {
	    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
	  }
	}

	function filterContextListener(listener, index, group) {
	  listener = contextListener(listener, index, group);
	  return function(event) {
	    var related = event.relatedTarget;
	    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
	      listener.call(this, event);
	    }
	  };
	}

	function contextListener(listener, index, group) {
	  return function(event1) {
	    var event0 = event; // Events can be reentrant (e.g., focus).
	    event = event1;
	    try {
	      listener.call(this, this.__data__, index, group);
	    } finally {
	      event = event0;
	    }
	  };
	}

	function parseTypenames$1(typenames) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    return {type: t, name: name};
	  });
	}

	function onRemove(typename) {
	  return function() {
	    var on = this.__on;
	    if (!on) return;
	    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
	      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.capture);
	      } else {
	        on[++i] = o;
	      }
	    }
	    if (++i) on.length = i;
	    else delete this.__on;
	  };
	}

	function onAdd(typename, value, capture) {
	  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
	  return function(d, i, group) {
	    var on = this.__on, o, listener = wrap(value, i, group);
	    if (on) for (var j = 0, m = on.length; j < m; ++j) {
	      if ((o = on[j]).type === typename.type && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.capture);
	        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
	        o.value = value;
	        return;
	      }
	    }
	    this.addEventListener(typename.type, listener, capture);
	    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
	    if (!on) this.__on = [o];
	    else on.push(o);
	  };
	}

	function selection_on(typename, value, capture) {
	  var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

	  if (arguments.length < 2) {
	    var on = this.node().__on;
	    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
	      for (i = 0, o = on[j]; i < n; ++i) {
	        if ((t = typenames[i]).type === o.type && t.name === o.name) {
	          return o.value;
	        }
	      }
	    }
	    return;
	  }

	  on = value ? onAdd : onRemove;
	  if (capture == null) capture = false;
	  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
	  return this;
	}

	function customEvent(event1, listener, that, args) {
	  var event0 = event;
	  event1.sourceEvent = event;
	  event = event1;
	  try {
	    return listener.apply(that, args);
	  } finally {
	    event = event0;
	  }
	}

	function dispatchEvent(node, type, params) {
	  var window = defaultView(node),
	      event = window.CustomEvent;

	  if (typeof event === "function") {
	    event = new event(type, params);
	  } else {
	    event = window.document.createEvent("Event");
	    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
	    else event.initEvent(type, false, false);
	  }

	  node.dispatchEvent(event);
	}

	function dispatchConstant(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params);
	  };
	}

	function dispatchFunction(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params.apply(this, arguments));
	  };
	}

	function selection_dispatch(type, params) {
	  return this.each((typeof params === "function"
	      ? dispatchFunction
	      : dispatchConstant)(type, params));
	}

	var root = [null];

	function Selection(groups, parents) {
	  this._groups = groups;
	  this._parents = parents;
	}

	function selection() {
	  return new Selection([[document.documentElement]], root);
	}

	Selection.prototype = selection.prototype = {
	  constructor: Selection,
	  select: selection_select,
	  selectAll: selection_selectAll,
	  filter: selection_filter,
	  data: selection_data,
	  enter: selection_enter,
	  exit: selection_exit,
	  merge: selection_merge,
	  order: selection_order,
	  sort: selection_sort,
	  call: selection_call,
	  nodes: selection_nodes,
	  node: selection_node,
	  size: selection_size,
	  empty: selection_empty,
	  each: selection_each,
	  attr: selection_attr,
	  style: selection_style,
	  property: selection_property,
	  classed: selection_classed,
	  text: selection_text,
	  html: selection_html,
	  raise: selection_raise,
	  lower: selection_lower,
	  append: selection_append,
	  insert: selection_insert,
	  remove: selection_remove,
	  clone: selection_clone,
	  datum: selection_datum,
	  on: selection_on,
	  dispatch: selection_dispatch
	};

	function select(selector) {
	  return typeof selector === "string"
	      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
	      : new Selection([[selector]], root);
	}

	function sourceEvent() {
	  var current = event, source;
	  while (source = current.sourceEvent) current = source;
	  return current;
	}

	function point(node, event) {
	  var svg = node.ownerSVGElement || node;

	  if (svg.createSVGPoint) {
	    var point = svg.createSVGPoint();
	    point.x = event.clientX, point.y = event.clientY;
	    point = point.matrixTransform(node.getScreenCTM().inverse());
	    return [point.x, point.y];
	  }

	  var rect = node.getBoundingClientRect();
	  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
	}

	function mouse(node) {
	  var event = sourceEvent();
	  if (event.changedTouches) event = event.changedTouches[0];
	  return point(node, event);
	}

	function touch(node, touches, identifier) {
	  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

	  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
	    if ((touch = touches[i]).identifier === identifier) {
	      return point(node, touch);
	    }
	  }

	  return null;
	}

	function nopropagation() {
	  event.stopImmediatePropagation();
	}

	function noevent() {
	  event.preventDefault();
	  event.stopImmediatePropagation();
	}

	function dragDisable(view) {
	  var root = view.document.documentElement,
	      selection$$1 = select(view).on("dragstart.drag", noevent, true);
	  if ("onselectstart" in root) {
	    selection$$1.on("selectstart.drag", noevent, true);
	  } else {
	    root.__noselect = root.style.MozUserSelect;
	    root.style.MozUserSelect = "none";
	  }
	}

	function yesdrag(view, noclick) {
	  var root = view.document.documentElement,
	      selection$$1 = select(view).on("dragstart.drag", null);
	  if (noclick) {
	    selection$$1.on("click.drag", noevent, true);
	    setTimeout(function() { selection$$1.on("click.drag", null); }, 0);
	  }
	  if ("onselectstart" in root) {
	    selection$$1.on("selectstart.drag", null);
	  } else {
	    root.style.MozUserSelect = root.__noselect;
	    delete root.__noselect;
	  }
	}

	function constant$2(x) {
	  return function() {
	    return x;
	  };
	}

	function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
	  this.target = target;
	  this.type = type;
	  this.subject = subject;
	  this.identifier = id;
	  this.active = active;
	  this.x = x;
	  this.y = y;
	  this.dx = dx;
	  this.dy = dy;
	  this._ = dispatch;
	}

	DragEvent.prototype.on = function() {
	  var value = this._.on.apply(this._, arguments);
	  return value === this._ ? this : value;
	};

	// Ignore right-click, since that should open the context menu.
	function defaultFilter() {
	  return !event.button;
	}

	function defaultContainer() {
	  return this.parentNode;
	}

	function defaultSubject(d) {
	  return d == null ? {x: event.x, y: event.y} : d;
	}

	function defaultTouchable() {
	  return "ontouchstart" in this;
	}

	function drag() {
	  var filter = defaultFilter,
	      container = defaultContainer,
	      subject = defaultSubject,
	      touchable = defaultTouchable,
	      gestures = {},
	      listeners = dispatch("start", "drag", "end"),
	      active = 0,
	      mousedownx,
	      mousedowny,
	      mousemoving,
	      touchending,
	      clickDistance2 = 0;

	  function drag(selection$$1) {
	    selection$$1
	        .on("mousedown.drag", mousedowned)
	      .filter(touchable)
	        .on("touchstart.drag", touchstarted)
	        .on("touchmove.drag", touchmoved)
	        .on("touchend.drag touchcancel.drag", touchended)
	        .style("touch-action", "none")
	        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	  }

	  function mousedowned() {
	    if (touchending || !filter.apply(this, arguments)) return;
	    var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
	    if (!gesture) return;
	    select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
	    dragDisable(event.view);
	    nopropagation();
	    mousemoving = false;
	    mousedownx = event.clientX;
	    mousedowny = event.clientY;
	    gesture("start");
	  }

	  function mousemoved() {
	    noevent();
	    if (!mousemoving) {
	      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
	      mousemoving = dx * dx + dy * dy > clickDistance2;
	    }
	    gestures.mouse("drag");
	  }

	  function mouseupped() {
	    select(event.view).on("mousemove.drag mouseup.drag", null);
	    yesdrag(event.view, mousemoving);
	    noevent();
	    gestures.mouse("end");
	  }

	  function touchstarted() {
	    if (!filter.apply(this, arguments)) return;
	    var touches$$1 = event.changedTouches,
	        c = container.apply(this, arguments),
	        n = touches$$1.length, i, gesture;

	    for (i = 0; i < n; ++i) {
	      if (gesture = beforestart(touches$$1[i].identifier, c, touch, this, arguments)) {
	        nopropagation();
	        gesture("start");
	      }
	    }
	  }

	  function touchmoved() {
	    var touches$$1 = event.changedTouches,
	        n = touches$$1.length, i, gesture;

	    for (i = 0; i < n; ++i) {
	      if (gesture = gestures[touches$$1[i].identifier]) {
	        noevent();
	        gesture("drag");
	      }
	    }
	  }

	  function touchended() {
	    var touches$$1 = event.changedTouches,
	        n = touches$$1.length, i, gesture;

	    if (touchending) clearTimeout(touchending);
	    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
	    for (i = 0; i < n; ++i) {
	      if (gesture = gestures[touches$$1[i].identifier]) {
	        nopropagation();
	        gesture("end");
	      }
	    }
	  }

	  function beforestart(id, container, point$$1, that, args) {
	    var p = point$$1(container, id), s, dx, dy,
	        sublisteners = listeners.copy();

	    if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
	      if ((event.subject = s = subject.apply(that, args)) == null) return false;
	      dx = s.x - p[0] || 0;
	      dy = s.y - p[1] || 0;
	      return true;
	    })) return;

	    return function gesture(type) {
	      var p0 = p, n;
	      switch (type) {
	        case "start": gestures[id] = gesture, n = active++; break;
	        case "end": delete gestures[id], --active; // nobreak
	        case "drag": p = point$$1(container, id), n = active; break;
	      }
	      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
	    };
	  }

	  drag.filter = function(_) {
	    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$2(!!_), drag) : filter;
	  };

	  drag.container = function(_) {
	    return arguments.length ? (container = typeof _ === "function" ? _ : constant$2(_), drag) : container;
	  };

	  drag.subject = function(_) {
	    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2(_), drag) : subject;
	  };

	  drag.touchable = function(_) {
	    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$2(!!_), drag) : touchable;
	  };

	  drag.on = function() {
	    var value = listeners.on.apply(listeners, arguments);
	    return value === listeners ? drag : value;
	  };

	  drag.clickDistance = function(_) {
	    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
	  };

	  return drag;
	}

	function define(constructor, factory, prototype) {
	  constructor.prototype = factory.prototype = prototype;
	  prototype.constructor = constructor;
	}

	function extend(parent, definition) {
	  var prototype = Object.create(parent.prototype);
	  for (var key in definition) prototype[key] = definition[key];
	  return prototype;
	}

	function Color() {}

	var darker = 0.7;
	var brighter = 1 / darker;

	var reI = "\\s*([+-]?\\d+)\\s*",
	    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
	    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
	    reHex3 = /^#([0-9a-f]{3})$/,
	    reHex6 = /^#([0-9a-f]{6})$/,
	    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
	    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
	    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
	    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
	    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
	    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

	var named = {
	  aliceblue: 0xf0f8ff,
	  antiquewhite: 0xfaebd7,
	  aqua: 0x00ffff,
	  aquamarine: 0x7fffd4,
	  azure: 0xf0ffff,
	  beige: 0xf5f5dc,
	  bisque: 0xffe4c4,
	  black: 0x000000,
	  blanchedalmond: 0xffebcd,
	  blue: 0x0000ff,
	  blueviolet: 0x8a2be2,
	  brown: 0xa52a2a,
	  burlywood: 0xdeb887,
	  cadetblue: 0x5f9ea0,
	  chartreuse: 0x7fff00,
	  chocolate: 0xd2691e,
	  coral: 0xff7f50,
	  cornflowerblue: 0x6495ed,
	  cornsilk: 0xfff8dc,
	  crimson: 0xdc143c,
	  cyan: 0x00ffff,
	  darkblue: 0x00008b,
	  darkcyan: 0x008b8b,
	  darkgoldenrod: 0xb8860b,
	  darkgray: 0xa9a9a9,
	  darkgreen: 0x006400,
	  darkgrey: 0xa9a9a9,
	  darkkhaki: 0xbdb76b,
	  darkmagenta: 0x8b008b,
	  darkolivegreen: 0x556b2f,
	  darkorange: 0xff8c00,
	  darkorchid: 0x9932cc,
	  darkred: 0x8b0000,
	  darksalmon: 0xe9967a,
	  darkseagreen: 0x8fbc8f,
	  darkslateblue: 0x483d8b,
	  darkslategray: 0x2f4f4f,
	  darkslategrey: 0x2f4f4f,
	  darkturquoise: 0x00ced1,
	  darkviolet: 0x9400d3,
	  deeppink: 0xff1493,
	  deepskyblue: 0x00bfff,
	  dimgray: 0x696969,
	  dimgrey: 0x696969,
	  dodgerblue: 0x1e90ff,
	  firebrick: 0xb22222,
	  floralwhite: 0xfffaf0,
	  forestgreen: 0x228b22,
	  fuchsia: 0xff00ff,
	  gainsboro: 0xdcdcdc,
	  ghostwhite: 0xf8f8ff,
	  gold: 0xffd700,
	  goldenrod: 0xdaa520,
	  gray: 0x808080,
	  green: 0x008000,
	  greenyellow: 0xadff2f,
	  grey: 0x808080,
	  honeydew: 0xf0fff0,
	  hotpink: 0xff69b4,
	  indianred: 0xcd5c5c,
	  indigo: 0x4b0082,
	  ivory: 0xfffff0,
	  khaki: 0xf0e68c,
	  lavender: 0xe6e6fa,
	  lavenderblush: 0xfff0f5,
	  lawngreen: 0x7cfc00,
	  lemonchiffon: 0xfffacd,
	  lightblue: 0xadd8e6,
	  lightcoral: 0xf08080,
	  lightcyan: 0xe0ffff,
	  lightgoldenrodyellow: 0xfafad2,
	  lightgray: 0xd3d3d3,
	  lightgreen: 0x90ee90,
	  lightgrey: 0xd3d3d3,
	  lightpink: 0xffb6c1,
	  lightsalmon: 0xffa07a,
	  lightseagreen: 0x20b2aa,
	  lightskyblue: 0x87cefa,
	  lightslategray: 0x778899,
	  lightslategrey: 0x778899,
	  lightsteelblue: 0xb0c4de,
	  lightyellow: 0xffffe0,
	  lime: 0x00ff00,
	  limegreen: 0x32cd32,
	  linen: 0xfaf0e6,
	  magenta: 0xff00ff,
	  maroon: 0x800000,
	  mediumaquamarine: 0x66cdaa,
	  mediumblue: 0x0000cd,
	  mediumorchid: 0xba55d3,
	  mediumpurple: 0x9370db,
	  mediumseagreen: 0x3cb371,
	  mediumslateblue: 0x7b68ee,
	  mediumspringgreen: 0x00fa9a,
	  mediumturquoise: 0x48d1cc,
	  mediumvioletred: 0xc71585,
	  midnightblue: 0x191970,
	  mintcream: 0xf5fffa,
	  mistyrose: 0xffe4e1,
	  moccasin: 0xffe4b5,
	  navajowhite: 0xffdead,
	  navy: 0x000080,
	  oldlace: 0xfdf5e6,
	  olive: 0x808000,
	  olivedrab: 0x6b8e23,
	  orange: 0xffa500,
	  orangered: 0xff4500,
	  orchid: 0xda70d6,
	  palegoldenrod: 0xeee8aa,
	  palegreen: 0x98fb98,
	  paleturquoise: 0xafeeee,
	  palevioletred: 0xdb7093,
	  papayawhip: 0xffefd5,
	  peachpuff: 0xffdab9,
	  peru: 0xcd853f,
	  pink: 0xffc0cb,
	  plum: 0xdda0dd,
	  powderblue: 0xb0e0e6,
	  purple: 0x800080,
	  rebeccapurple: 0x663399,
	  red: 0xff0000,
	  rosybrown: 0xbc8f8f,
	  royalblue: 0x4169e1,
	  saddlebrown: 0x8b4513,
	  salmon: 0xfa8072,
	  sandybrown: 0xf4a460,
	  seagreen: 0x2e8b57,
	  seashell: 0xfff5ee,
	  sienna: 0xa0522d,
	  silver: 0xc0c0c0,
	  skyblue: 0x87ceeb,
	  slateblue: 0x6a5acd,
	  slategray: 0x708090,
	  slategrey: 0x708090,
	  snow: 0xfffafa,
	  springgreen: 0x00ff7f,
	  steelblue: 0x4682b4,
	  tan: 0xd2b48c,
	  teal: 0x008080,
	  thistle: 0xd8bfd8,
	  tomato: 0xff6347,
	  turquoise: 0x40e0d0,
	  violet: 0xee82ee,
	  wheat: 0xf5deb3,
	  white: 0xffffff,
	  whitesmoke: 0xf5f5f5,
	  yellow: 0xffff00,
	  yellowgreen: 0x9acd32
	};

	define(Color, color, {
	  displayable: function() {
	    return this.rgb().displayable();
	  },
	  hex: function() {
	    return this.rgb().hex();
	  },
	  toString: function() {
	    return this.rgb() + "";
	  }
	});

	function color(format) {
	  var m;
	  format = (format + "").trim().toLowerCase();
	  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
	      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
	      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
	      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
	      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
	      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
	      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
	      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
	      : named.hasOwnProperty(format) ? rgbn(named[format])
	      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
	      : null;
	}

	function rgbn(n) {
	  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
	}

	function rgba(r, g, b, a) {
	  if (a <= 0) r = g = b = NaN;
	  return new Rgb(r, g, b, a);
	}

	function rgbConvert(o) {
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Rgb;
	  o = o.rgb();
	  return new Rgb(o.r, o.g, o.b, o.opacity);
	}

	function rgb(r, g, b, opacity) {
	  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
	}

	function Rgb(r, g, b, opacity) {
	  this.r = +r;
	  this.g = +g;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Rgb, rgb, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  rgb: function() {
	    return this;
	  },
	  displayable: function() {
	    return (0 <= this.r && this.r <= 255)
	        && (0 <= this.g && this.g <= 255)
	        && (0 <= this.b && this.b <= 255)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  hex: function() {
	    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
	  },
	  toString: function() {
	    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	    return (a === 1 ? "rgb(" : "rgba(")
	        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
	        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
	        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
	        + (a === 1 ? ")" : ", " + a + ")");
	  }
	}));

	function hex(value) {
	  value = Math.max(0, Math.min(255, Math.round(value) || 0));
	  return (value < 16 ? "0" : "") + value.toString(16);
	}

	function hsla(h, s, l, a) {
	  if (a <= 0) h = s = l = NaN;
	  else if (l <= 0 || l >= 1) h = s = NaN;
	  else if (s <= 0) h = NaN;
	  return new Hsl(h, s, l, a);
	}

	function hslConvert(o) {
	  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Hsl;
	  if (o instanceof Hsl) return o;
	  o = o.rgb();
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      h = NaN,
	      s = max - min,
	      l = (max + min) / 2;
	  if (s) {
	    if (r === max) h = (g - b) / s + (g < b) * 6;
	    else if (g === max) h = (b - r) / s + 2;
	    else h = (r - g) / s + 4;
	    s /= l < 0.5 ? max + min : 2 - max - min;
	    h *= 60;
	  } else {
	    s = l > 0 && l < 1 ? 0 : h;
	  }
	  return new Hsl(h, s, l, o.opacity);
	}

	function hsl(h, s, l, opacity) {
	  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
	}

	function Hsl(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Hsl, hsl, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = this.h % 360 + (this.h < 0) * 360,
	        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
	        l = this.l,
	        m2 = l + (l < 0.5 ? l : 1 - l) * s,
	        m1 = 2 * l - m2;
	    return new Rgb(
	      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
	      hsl2rgb(h, m1, m2),
	      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
	      this.opacity
	    );
	  },
	  displayable: function() {
	    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
	        && (0 <= this.l && this.l <= 1)
	        && (0 <= this.opacity && this.opacity <= 1);
	  }
	}));

	/* From FvD 13.37, CSS Color Module Level 3 */
	function hsl2rgb(h, m1, m2) {
	  return (h < 60 ? m1 + (m2 - m1) * h / 60
	      : h < 180 ? m2
	      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
	      : m1) * 255;
	}

	var deg2rad = Math.PI / 180;
	var rad2deg = 180 / Math.PI;

	// https://beta.observablehq.com/@mbostock/lab-and-rgb
	var K = 18,
	    Xn = 0.96422,
	    Yn = 1,
	    Zn = 0.82521,
	    t0 = 4 / 29,
	    t1 = 6 / 29,
	    t2 = 3 * t1 * t1,
	    t3 = t1 * t1 * t1;

	function labConvert(o) {
	  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
	  if (o instanceof Hcl) {
	    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
	    var h = o.h * deg2rad;
	    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
	  }
	  if (!(o instanceof Rgb)) o = rgbConvert(o);
	  var r = rgb2lrgb(o.r),
	      g = rgb2lrgb(o.g),
	      b = rgb2lrgb(o.b),
	      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
	  if (r === g && g === b) x = z = y; else {
	    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
	    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
	  }
	  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
	}

	function lab(l, a, b, opacity) {
	  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
	}

	function Lab(l, a, b, opacity) {
	  this.l = +l;
	  this.a = +a;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Lab, lab, extend(Color, {
	  brighter: function(k) {
	    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
	  },
	  darker: function(k) {
	    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
	  },
	  rgb: function() {
	    var y = (this.l + 16) / 116,
	        x = isNaN(this.a) ? y : y + this.a / 500,
	        z = isNaN(this.b) ? y : y - this.b / 200;
	    x = Xn * lab2xyz(x);
	    y = Yn * lab2xyz(y);
	    z = Zn * lab2xyz(z);
	    return new Rgb(
	      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
	      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
	      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
	      this.opacity
	    );
	  }
	}));

	function xyz2lab(t) {
	  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
	}

	function lab2xyz(t) {
	  return t > t1 ? t * t * t : t2 * (t - t0);
	}

	function lrgb2rgb(x) {
	  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
	}

	function rgb2lrgb(x) {
	  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
	}

	function hclConvert(o) {
	  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
	  if (!(o instanceof Lab)) o = labConvert(o);
	  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
	  var h = Math.atan2(o.b, o.a) * rad2deg;
	  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
	}

	function hcl(h, c, l, opacity) {
	  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
	}

	function Hcl(h, c, l, opacity) {
	  this.h = +h;
	  this.c = +c;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Hcl, hcl, extend(Color, {
	  brighter: function(k) {
	    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
	  },
	  darker: function(k) {
	    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
	  },
	  rgb: function() {
	    return labConvert(this).rgb();
	  }
	}));

	var A = -0.14861,
	    B = +1.78277,
	    C = -0.29227,
	    D = -0.90649,
	    E = +1.97294,
	    ED = E * D,
	    EB = E * B,
	    BC_DA = B * C - D * A;

	function cubehelixConvert(o) {
	  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Rgb)) o = rgbConvert(o);
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
	      bl = b - l,
	      k = (E * (g - l) - C * bl) / D,
	      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
	      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
	  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
	}

	function cubehelix(h, s, l, opacity) {
	  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
	}

	function Cubehelix(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Cubehelix, cubehelix, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
	        l = +this.l,
	        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
	        cosh = Math.cos(h),
	        sinh = Math.sin(h);
	    return new Rgb(
	      255 * (l + a * (A * cosh + B * sinh)),
	      255 * (l + a * (C * cosh + D * sinh)),
	      255 * (l + a * (E * cosh)),
	      this.opacity
	    );
	  }
	}));

	function basis(t1, v0, v1, v2, v3) {
	  var t2 = t1 * t1, t3 = t2 * t1;
	  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
	      + (4 - 6 * t2 + 3 * t3) * v1
	      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
	      + t3 * v3) / 6;
	}

	function basis$1(values) {
	  var n = values.length - 1;
	  return function(t) {
	    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
	        v1 = values[i],
	        v2 = values[i + 1],
	        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
	        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
	    return basis((t - i / n) * n, v0, v1, v2, v3);
	  };
	}

	function constant$3(x) {
	  return function() {
	    return x;
	  };
	}

	function linear$1(a, d) {
	  return function(t) {
	    return a + t * d;
	  };
	}

	function exponential(a, b, y) {
	  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
	    return Math.pow(a + t * b, y);
	  };
	}

	function hue(a, b) {
	  var d = b - a;
	  return d ? linear$1(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
	}

	function gamma(y) {
	  return (y = +y) === 1 ? nogamma : function(a, b) {
	    return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
	  };
	}

	function nogamma(a, b) {
	  var d = b - a;
	  return d ? linear$1(a, d) : constant$3(isNaN(a) ? b : a);
	}

	var interpolateRgb = (function rgbGamma(y) {
	  var color$$1 = gamma(y);

	  function rgb$$1(start, end) {
	    var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),
	        g = color$$1(start.g, end.g),
	        b = color$$1(start.b, end.b),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.r = r(t);
	      start.g = g(t);
	      start.b = b(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }

	  rgb$$1.gamma = rgbGamma;

	  return rgb$$1;
	})(1);

	function rgbSpline(spline) {
	  return function(colors) {
	    var n = colors.length,
	        r = new Array(n),
	        g = new Array(n),
	        b = new Array(n),
	        i, color$$1;
	    for (i = 0; i < n; ++i) {
	      color$$1 = rgb(colors[i]);
	      r[i] = color$$1.r || 0;
	      g[i] = color$$1.g || 0;
	      b[i] = color$$1.b || 0;
	    }
	    r = spline(r);
	    g = spline(g);
	    b = spline(b);
	    color$$1.opacity = 1;
	    return function(t) {
	      color$$1.r = r(t);
	      color$$1.g = g(t);
	      color$$1.b = b(t);
	      return color$$1 + "";
	    };
	  };
	}

	var rgbBasis = rgbSpline(basis$1);

	function array$1(a, b) {
	  var nb = b ? b.length : 0,
	      na = a ? Math.min(nb, a.length) : 0,
	      x = new Array(na),
	      c = new Array(nb),
	      i;

	  for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
	  for (; i < nb; ++i) c[i] = b[i];

	  return function(t) {
	    for (i = 0; i < na; ++i) c[i] = x[i](t);
	    return c;
	  };
	}

	function date(a, b) {
	  var d = new Date;
	  return a = +a, b -= a, function(t) {
	    return d.setTime(a + b * t), d;
	  };
	}

	function interpolateNumber(a, b) {
	  return a = +a, b -= a, function(t) {
	    return a + b * t;
	  };
	}

	function object(a, b) {
	  var i = {},
	      c = {},
	      k;

	  if (a === null || typeof a !== "object") a = {};
	  if (b === null || typeof b !== "object") b = {};

	  for (k in b) {
	    if (k in a) {
	      i[k] = interpolateValue(a[k], b[k]);
	    } else {
	      c[k] = b[k];
	    }
	  }

	  return function(t) {
	    for (k in i) c[k] = i[k](t);
	    return c;
	  };
	}

	var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
	    reB = new RegExp(reA.source, "g");

	function zero(b) {
	  return function() {
	    return b;
	  };
	}

	function one(b) {
	  return function(t) {
	    return b(t) + "";
	  };
	}

	function interpolateString(a, b) {
	  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
	      am, // current match in a
	      bm, // current match in b
	      bs, // string preceding current number in b, if any
	      i = -1, // index in s
	      s = [], // string constants and placeholders
	      q = []; // number interpolators

	  // Coerce inputs to strings.
	  a = a + "", b = b + "";

	  // Interpolate pairs of numbers in a & b.
	  while ((am = reA.exec(a))
	      && (bm = reB.exec(b))) {
	    if ((bs = bm.index) > bi) { // a string precedes the next number in b
	      bs = b.slice(bi, bs);
	      if (s[i]) s[i] += bs; // coalesce with previous string
	      else s[++i] = bs;
	    }
	    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
	      if (s[i]) s[i] += bm; // coalesce with previous string
	      else s[++i] = bm;
	    } else { // interpolate non-matching numbers
	      s[++i] = null;
	      q.push({i: i, x: interpolateNumber(am, bm)});
	    }
	    bi = reB.lastIndex;
	  }

	  // Add remains of b.
	  if (bi < b.length) {
	    bs = b.slice(bi);
	    if (s[i]) s[i] += bs; // coalesce with previous string
	    else s[++i] = bs;
	  }

	  // Special optimization for only a single match.
	  // Otherwise, interpolate each of the numbers and rejoin the string.
	  return s.length < 2 ? (q[0]
	      ? one(q[0].x)
	      : zero(b))
	      : (b = q.length, function(t) {
	          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	          return s.join("");
	        });
	}

	function interpolateValue(a, b) {
	  var t = typeof b, c;
	  return b == null || t === "boolean" ? constant$3(b)
	      : (t === "number" ? interpolateNumber
	      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
	      : b instanceof color ? interpolateRgb
	      : b instanceof Date ? date
	      : Array.isArray(b) ? array$1
	      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
	      : interpolateNumber)(a, b);
	}

	function interpolateRound(a, b) {
	  return a = +a, b -= a, function(t) {
	    return Math.round(a + b * t);
	  };
	}

	var degrees = 180 / Math.PI;

	var identity$2 = {
	  translateX: 0,
	  translateY: 0,
	  rotate: 0,
	  skewX: 0,
	  scaleX: 1,
	  scaleY: 1
	};

	function decompose(a, b, c, d, e, f) {
	  var scaleX, scaleY, skewX;
	  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
	  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
	  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
	  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
	  return {
	    translateX: e,
	    translateY: f,
	    rotate: Math.atan2(b, a) * degrees,
	    skewX: Math.atan(skewX) * degrees,
	    scaleX: scaleX,
	    scaleY: scaleY
	  };
	}

	var cssNode,
	    cssRoot,
	    cssView,
	    svgNode;

	function parseCss(value) {
	  if (value === "none") return identity$2;
	  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
	  cssNode.style.transform = value;
	  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
	  cssRoot.removeChild(cssNode);
	  value = value.slice(7, -1).split(",");
	  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
	}

	function parseSvg(value) {
	  if (value == null) return identity$2;
	  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
	  svgNode.setAttribute("transform", value);
	  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
	  value = value.matrix;
	  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
	}

	function interpolateTransform(parse, pxComma, pxParen, degParen) {

	  function pop(s) {
	    return s.length ? s.pop() + " " : "";
	  }

	  function translate(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push("translate(", null, pxComma, null, pxParen);
	      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
	    } else if (xb || yb) {
	      s.push("translate(" + xb + pxComma + yb + pxParen);
	    }
	  }

	  function rotate(a, b, s, q) {
	    if (a !== b) {
	      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
	      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "rotate(" + b + degParen);
	    }
	  }

	  function skewX(a, b, s, q) {
	    if (a !== b) {
	      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "skewX(" + b + degParen);
	    }
	  }

	  function scale(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
	      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
	    } else if (xb !== 1 || yb !== 1) {
	      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
	    }
	  }

	  return function(a, b) {
	    var s = [], // string constants and placeholders
	        q = []; // number interpolators
	    a = parse(a), b = parse(b);
	    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
	    rotate(a.rotate, b.rotate, s, q);
	    skewX(a.skewX, b.skewX, s, q);
	    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
	    a = b = null; // gc
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  };
	}

	var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
	var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

	var rho = Math.SQRT2;

	function cubehelix$1(hue$$1) {
	  return (function cubehelixGamma(y) {
	    y = +y;

	    function cubehelix$$1(start, end) {
	      var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),
	          s = nogamma(start.s, end.s),
	          l = nogamma(start.l, end.l),
	          opacity = nogamma(start.opacity, end.opacity);
	      return function(t) {
	        start.h = h(t);
	        start.s = s(t);
	        start.l = l(Math.pow(t, y));
	        start.opacity = opacity(t);
	        return start + "";
	      };
	    }

	    cubehelix$$1.gamma = cubehelixGamma;

	    return cubehelix$$1;
	  })(1);
	}

	cubehelix$1(hue);
	var cubehelixLong = cubehelix$1(nogamma);

	var frame = 0, // is an animation frame pending?
	    timeout = 0, // is a timeout pending?
	    interval = 0, // are any timers active?
	    pokeDelay = 1000, // how frequently we check for clock skew
	    taskHead,
	    taskTail,
	    clockLast = 0,
	    clockNow = 0,
	    clockSkew = 0,
	    clock = typeof performance === "object" && performance.now ? performance : Date,
	    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

	function now() {
	  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
	}

	function clearNow() {
	  clockNow = 0;
	}

	function Timer() {
	  this._call =
	  this._time =
	  this._next = null;
	}

	Timer.prototype = timer.prototype = {
	  constructor: Timer,
	  restart: function(callback, delay, time) {
	    if (typeof callback !== "function") throw new TypeError("callback is not a function");
	    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
	    if (!this._next && taskTail !== this) {
	      if (taskTail) taskTail._next = this;
	      else taskHead = this;
	      taskTail = this;
	    }
	    this._call = callback;
	    this._time = time;
	    sleep();
	  },
	  stop: function() {
	    if (this._call) {
	      this._call = null;
	      this._time = Infinity;
	      sleep();
	    }
	  }
	};

	function timer(callback, delay, time) {
	  var t = new Timer;
	  t.restart(callback, delay, time);
	  return t;
	}

	function timerFlush() {
	  now(); // Get the current time, if not already set.
	  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
	  var t = taskHead, e;
	  while (t) {
	    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
	    t = t._next;
	  }
	  --frame;
	}

	function wake() {
	  clockNow = (clockLast = clock.now()) + clockSkew;
	  frame = timeout = 0;
	  try {
	    timerFlush();
	  } finally {
	    frame = 0;
	    nap();
	    clockNow = 0;
	  }
	}

	function poke() {
	  var now = clock.now(), delay = now - clockLast;
	  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
	}

	function nap() {
	  var t0, t1 = taskHead, t2, time = Infinity;
	  while (t1) {
	    if (t1._call) {
	      if (time > t1._time) time = t1._time;
	      t0 = t1, t1 = t1._next;
	    } else {
	      t2 = t1._next, t1._next = null;
	      t1 = t0 ? t0._next = t2 : taskHead = t2;
	    }
	  }
	  taskTail = t0;
	  sleep(time);
	}

	function sleep(time) {
	  if (frame) return; // Soonest alarm already set, or will be.
	  if (timeout) timeout = clearTimeout(timeout);
	  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
	  if (delay > 24) {
	    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
	    if (interval) interval = clearInterval(interval);
	  } else {
	    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
	    frame = 1, setFrame(wake);
	  }
	}

	function timeout$1(callback, delay, time) {
	  var t = new Timer;
	  delay = delay == null ? 0 : +delay;
	  t.restart(function(elapsed) {
	    t.stop();
	    callback(elapsed + delay);
	  }, delay, time);
	  return t;
	}

	var emptyOn = dispatch("start", "end", "interrupt");
	var emptyTween = [];

	var CREATED = 0;
	var SCHEDULED = 1;
	var STARTING = 2;
	var STARTED = 3;
	var RUNNING = 4;
	var ENDING = 5;
	var ENDED = 6;

	function schedule(node, name, id, index, group, timing) {
	  var schedules = node.__transition;
	  if (!schedules) node.__transition = {};
	  else if (id in schedules) return;
	  create$1(node, id, {
	    name: name,
	    index: index, // For context during callback.
	    group: group, // For context during callback.
	    on: emptyOn,
	    tween: emptyTween,
	    time: timing.time,
	    delay: timing.delay,
	    duration: timing.duration,
	    ease: timing.ease,
	    timer: null,
	    state: CREATED
	  });
	}

	function init$1(node, id) {
	  var schedule = get$2(node, id);
	  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
	  return schedule;
	}

	function set$2(node, id) {
	  var schedule = get$2(node, id);
	  if (schedule.state > STARTING) throw new Error("too late; already started");
	  return schedule;
	}

	function get$2(node, id) {
	  var schedule = node.__transition;
	  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
	  return schedule;
	}

	function create$1(node, id, self) {
	  var schedules = node.__transition,
	      tween;

	  // Initialize the self timer when the transition is created.
	  // Note the actual delay is not known until the first callback!
	  schedules[id] = self;
	  self.timer = timer(schedule, 0, self.time);

	  function schedule(elapsed) {
	    self.state = SCHEDULED;
	    self.timer.restart(start, self.delay, self.time);

	    // If the elapsed delay is less than our first sleep, start immediately.
	    if (self.delay <= elapsed) start(elapsed - self.delay);
	  }

	  function start(elapsed) {
	    var i, j, n, o;

	    // If the state is not SCHEDULED, then we previously errored on start.
	    if (self.state !== SCHEDULED) return stop();

	    for (i in schedules) {
	      o = schedules[i];
	      if (o.name !== self.name) continue;

	      // While this element already has a starting transition during this frame,
	      // defer starting an interrupting transition until that transition has a
	      // chance to tick (and possibly end); see d3/d3-transition#54!
	      if (o.state === STARTED) return timeout$1(start);

	      // Interrupt the active transition, if any.
	      // Dispatch the interrupt event.
	      if (o.state === RUNNING) {
	        o.state = ENDED;
	        o.timer.stop();
	        o.on.call("interrupt", node, node.__data__, o.index, o.group);
	        delete schedules[i];
	      }

	      // Cancel any pre-empted transitions. No interrupt event is dispatched
	      // because the cancelled transitions never started. Note that this also
	      // removes this transition from the pending list!
	      else if (+i < id) {
	        o.state = ENDED;
	        o.timer.stop();
	        delete schedules[i];
	      }
	    }

	    // Defer the first tick to end of the current frame; see d3/d3#1576.
	    // Note the transition may be canceled after start and before the first tick!
	    // Note this must be scheduled before the start event; see d3/d3-transition#16!
	    // Assuming this is successful, subsequent callbacks go straight to tick.
	    timeout$1(function() {
	      if (self.state === STARTED) {
	        self.state = RUNNING;
	        self.timer.restart(tick, self.delay, self.time);
	        tick(elapsed);
	      }
	    });

	    // Dispatch the start event.
	    // Note this must be done before the tween are initialized.
	    self.state = STARTING;
	    self.on.call("start", node, node.__data__, self.index, self.group);
	    if (self.state !== STARTING) return; // interrupted
	    self.state = STARTED;

	    // Initialize the tween, deleting null tween.
	    tween = new Array(n = self.tween.length);
	    for (i = 0, j = -1; i < n; ++i) {
	      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
	        tween[++j] = o;
	      }
	    }
	    tween.length = j + 1;
	  }

	  function tick(elapsed) {
	    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
	        i = -1,
	        n = tween.length;

	    while (++i < n) {
	      tween[i].call(null, t);
	    }

	    // Dispatch the end event.
	    if (self.state === ENDING) {
	      self.on.call("end", node, node.__data__, self.index, self.group);
	      stop();
	    }
	  }

	  function stop() {
	    self.state = ENDED;
	    self.timer.stop();
	    delete schedules[id];
	    for (var i in schedules) return; // eslint-disable-line no-unused-vars
	    delete node.__transition;
	  }
	}

	function interrupt(node, name) {
	  var schedules = node.__transition,
	      schedule$$1,
	      active,
	      empty = true,
	      i;

	  if (!schedules) return;

	  name = name == null ? null : name + "";

	  for (i in schedules) {
	    if ((schedule$$1 = schedules[i]).name !== name) { empty = false; continue; }
	    active = schedule$$1.state > STARTING && schedule$$1.state < ENDING;
	    schedule$$1.state = ENDED;
	    schedule$$1.timer.stop();
	    if (active) schedule$$1.on.call("interrupt", node, node.__data__, schedule$$1.index, schedule$$1.group);
	    delete schedules[i];
	  }

	  if (empty) delete node.__transition;
	}

	function selection_interrupt(name) {
	  return this.each(function() {
	    interrupt(this, name);
	  });
	}

	function tweenRemove(id, name) {
	  var tween0, tween1;
	  return function() {
	    var schedule$$1 = set$2(this, id),
	        tween = schedule$$1.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and we’re done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = tween0 = tween;
	      for (var i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1 = tween1.slice();
	          tween1.splice(i, 1);
	          break;
	        }
	      }
	    }

	    schedule$$1.tween = tween1;
	  };
	}

	function tweenFunction(id, name, value) {
	  var tween0, tween1;
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    var schedule$$1 = set$2(this, id),
	        tween = schedule$$1.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and we’re done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = (tween0 = tween).slice();
	      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1[i] = t;
	          break;
	        }
	      }
	      if (i === n) tween1.push(t);
	    }

	    schedule$$1.tween = tween1;
	  };
	}

	function transition_tween(name, value) {
	  var id = this._id;

	  name += "";

	  if (arguments.length < 2) {
	    var tween = get$2(this.node(), id).tween;
	    for (var i = 0, n = tween.length, t; i < n; ++i) {
	      if ((t = tween[i]).name === name) {
	        return t.value;
	      }
	    }
	    return null;
	  }

	  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
	}

	function tweenValue(transition, name, value) {
	  var id = transition._id;

	  transition.each(function() {
	    var schedule$$1 = set$2(this, id);
	    (schedule$$1.value || (schedule$$1.value = {}))[name] = value.apply(this, arguments);
	  });

	  return function(node) {
	    return get$2(node, id).value[name];
	  };
	}

	function interpolate(a, b) {
	  var c;
	  return (typeof b === "number" ? interpolateNumber
	      : b instanceof color ? interpolateRgb
	      : (c = color(b)) ? (b = c, interpolateRgb)
	      : interpolateString)(a, b);
	}

	function attrRemove$1(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS$1(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant$1(name, interpolate$$1, value1) {
	  var value00,
	      interpolate0;
	  return function() {
	    var value0 = this.getAttribute(name);
	    return value0 === value1 ? null
	        : value0 === value00 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value1);
	  };
	}

	function attrConstantNS$1(fullname, interpolate$$1, value1) {
	  var value00,
	      interpolate0;
	  return function() {
	    var value0 = this.getAttributeNS(fullname.space, fullname.local);
	    return value0 === value1 ? null
	        : value0 === value00 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value1);
	  };
	}

	function attrFunction$1(name, interpolate$$1, value) {
	  var value00,
	      value10,
	      interpolate0;
	  return function() {
	    var value0, value1 = value(this);
	    if (value1 == null) return void this.removeAttribute(name);
	    value0 = this.getAttribute(name);
	    return value0 === value1 ? null
	        : value0 === value00 && value1 === value10 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
	  };
	}

	function attrFunctionNS$1(fullname, interpolate$$1, value) {
	  var value00,
	      value10,
	      interpolate0;
	  return function() {
	    var value0, value1 = value(this);
	    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
	    value0 = this.getAttributeNS(fullname.space, fullname.local);
	    return value0 === value1 ? null
	        : value0 === value00 && value1 === value10 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
	  };
	}

	function transition_attr(name, value) {
	  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
	  return this.attrTween(name, typeof value === "function"
	      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
	      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
	      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value + ""));
	}

	function attrTweenNS(fullname, value) {
	  function tween() {
	    var node = this, i = value.apply(node, arguments);
	    return i && function(t) {
	      node.setAttributeNS(fullname.space, fullname.local, i(t));
	    };
	  }
	  tween._value = value;
	  return tween;
	}

	function attrTween(name, value) {
	  function tween() {
	    var node = this, i = value.apply(node, arguments);
	    return i && function(t) {
	      node.setAttribute(name, i(t));
	    };
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_attrTween(name, value) {
	  var key = "attr." + name;
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  var fullname = namespace(name);
	  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
	}

	function delayFunction(id, value) {
	  return function() {
	    init$1(this, id).delay = +value.apply(this, arguments);
	  };
	}

	function delayConstant(id, value) {
	  return value = +value, function() {
	    init$1(this, id).delay = value;
	  };
	}

	function transition_delay(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? delayFunction
	          : delayConstant)(id, value))
	      : get$2(this.node(), id).delay;
	}

	function durationFunction(id, value) {
	  return function() {
	    set$2(this, id).duration = +value.apply(this, arguments);
	  };
	}

	function durationConstant(id, value) {
	  return value = +value, function() {
	    set$2(this, id).duration = value;
	  };
	}

	function transition_duration(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? durationFunction
	          : durationConstant)(id, value))
	      : get$2(this.node(), id).duration;
	}

	function easeConstant(id, value) {
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    set$2(this, id).ease = value;
	  };
	}

	function transition_ease(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each(easeConstant(id, value))
	      : get$2(this.node(), id).ease;
	}

	function transition_filter(match) {
	  if (typeof match !== "function") match = matcher$1(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, this._name, this._id);
	}

	function transition_merge(transition$$1) {
	  if (transition$$1._id !== this._id) throw new Error;

	  for (var groups0 = this._groups, groups1 = transition$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Transition(merges, this._parents, this._name, this._id);
	}

	function start(name) {
	  return (name + "").trim().split(/^|\s+/).every(function(t) {
	    var i = t.indexOf(".");
	    if (i >= 0) t = t.slice(0, i);
	    return !t || t === "start";
	  });
	}

	function onFunction(id, name, listener) {
	  var on0, on1, sit = start(name) ? init$1 : set$2;
	  return function() {
	    var schedule$$1 = sit(this, id),
	        on = schedule$$1.on;

	    // If this node shared a dispatch with the previous node,
	    // just assign the updated shared dispatch and we’re done!
	    // Otherwise, copy-on-write.
	    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

	    schedule$$1.on = on1;
	  };
	}

	function transition_on(name, listener) {
	  var id = this._id;

	  return arguments.length < 2
	      ? get$2(this.node(), id).on.on(name)
	      : this.each(onFunction(id, name, listener));
	}

	function removeFunction(id) {
	  return function() {
	    var parent = this.parentNode;
	    for (var i in this.__transition) if (+i !== id) return;
	    if (parent) parent.removeChild(this);
	  };
	}

	function transition_remove() {
	  return this.on("end.remove", removeFunction(this._id));
	}

	function transition_select(select$$1) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select$$1 !== "function") select$$1 = selector(select$$1);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select$$1.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	        schedule(subgroup[i], name, id, i, subgroup, get$2(node, id));
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, name, id);
	}

	function transition_selectAll(select$$1) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select$$1 !== "function") select$$1 = selectorAll(select$$1);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        for (var children = select$$1.call(node, node.__data__, i, group), child, inherit = get$2(node, id), k = 0, l = children.length; k < l; ++k) {
	          if (child = children[k]) {
	            schedule(child, name, id, k, children, inherit);
	          }
	        }
	        subgroups.push(children);
	        parents.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, parents, name, id);
	}

	var Selection$1 = selection.prototype.constructor;

	function transition_selection() {
	  return new Selection$1(this._groups, this._parents);
	}

	function styleRemove$1(name, interpolate$$1) {
	  var value00,
	      value10,
	      interpolate0;
	  return function() {
	    var value0 = styleValue(this, name),
	        value1 = (this.style.removeProperty(name), styleValue(this, name));
	    return value0 === value1 ? null
	        : value0 === value00 && value1 === value10 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
	  };
	}

	function styleRemoveEnd(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant$1(name, interpolate$$1, value1) {
	  var value00,
	      interpolate0;
	  return function() {
	    var value0 = styleValue(this, name);
	    return value0 === value1 ? null
	        : value0 === value00 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value1);
	  };
	}

	function styleFunction$1(name, interpolate$$1, value) {
	  var value00,
	      value10,
	      interpolate0;
	  return function() {
	    var value0 = styleValue(this, name),
	        value1 = value(this);
	    if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name));
	    return value0 === value1 ? null
	        : value0 === value00 && value1 === value10 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
	  };
	}

	function transition_style(name, value, priority) {
	  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
	  return value == null ? this
	          .styleTween(name, styleRemove$1(name, i))
	          .on("end.style." + name, styleRemoveEnd(name))
	      : this.styleTween(name, typeof value === "function"
	          ? styleFunction$1(name, i, tweenValue(this, "style." + name, value))
	          : styleConstant$1(name, i, value + ""), priority);
	}

	function styleTween(name, value, priority) {
	  function tween() {
	    var node = this, i = value.apply(node, arguments);
	    return i && function(t) {
	      node.style.setProperty(name, i(t), priority);
	    };
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_styleTween(name, value, priority) {
	  var key = "style." + (name += "");
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
	}

	function textConstant$1(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction$1(value) {
	  return function() {
	    var value1 = value(this);
	    this.textContent = value1 == null ? "" : value1;
	  };
	}

	function transition_text(value) {
	  return this.tween("text", typeof value === "function"
	      ? textFunction$1(tweenValue(this, "text", value))
	      : textConstant$1(value == null ? "" : value + ""));
	}

	function transition_transition() {
	  var name = this._name,
	      id0 = this._id,
	      id1 = newId();

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        var inherit = get$2(node, id0);
	        schedule(node, name, id1, i, group, {
	          time: inherit.time + inherit.delay + inherit.duration,
	          delay: 0,
	          duration: inherit.duration,
	          ease: inherit.ease
	        });
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id1);
	}

	var id = 0;

	function Transition(groups, parents, name, id) {
	  this._groups = groups;
	  this._parents = parents;
	  this._name = name;
	  this._id = id;
	}

	function transition(name) {
	  return selection().transition(name);
	}

	function newId() {
	  return ++id;
	}

	var selection_prototype = selection.prototype;

	Transition.prototype = transition.prototype = {
	  constructor: Transition,
	  select: transition_select,
	  selectAll: transition_selectAll,
	  filter: transition_filter,
	  merge: transition_merge,
	  selection: transition_selection,
	  transition: transition_transition,
	  call: selection_prototype.call,
	  nodes: selection_prototype.nodes,
	  node: selection_prototype.node,
	  size: selection_prototype.size,
	  empty: selection_prototype.empty,
	  each: selection_prototype.each,
	  on: transition_on,
	  attr: transition_attr,
	  attrTween: transition_attrTween,
	  style: transition_style,
	  styleTween: transition_styleTween,
	  text: transition_text,
	  remove: transition_remove,
	  tween: transition_tween,
	  delay: transition_delay,
	  duration: transition_duration,
	  ease: transition_ease
	};

	function cubicInOut(t) {
	  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
	}

	var pi = Math.PI;

	var tau = 2 * Math.PI;

	var defaultTiming = {
	  time: null, // Set on use.
	  delay: 0,
	  duration: 250,
	  ease: cubicInOut
	};

	function inherit(node, id) {
	  var timing;
	  while (!(timing = node.__transition) || !(timing = timing[id])) {
	    if (!(node = node.parentNode)) {
	      return defaultTiming.time = now(), defaultTiming;
	    }
	  }
	  return timing;
	}

	function selection_transition(name) {
	  var id,
	      timing;

	  if (name instanceof Transition) {
	    id = name._id, name = name._name;
	  } else {
	    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
	  }

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        schedule(node, name, id, i, group, timing || inherit(node, id));
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id);
	}

	selection.prototype.interrupt = selection_interrupt;
	selection.prototype.transition = selection_transition;

	var pi$1 = Math.PI;

	var pi$2 = Math.PI,
	    tau$2 = 2 * pi$2,
	    epsilon$1 = 1e-6,
	    tauEpsilon = tau$2 - epsilon$1;

	function Path() {
	  this._x0 = this._y0 = // start of current subpath
	  this._x1 = this._y1 = null; // end of current subpath
	  this._ = "";
	}

	function path() {
	  return new Path;
	}

	Path.prototype = path.prototype = {
	  constructor: Path,
	  moveTo: function(x, y) {
	    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
	  },
	  closePath: function() {
	    if (this._x1 !== null) {
	      this._x1 = this._x0, this._y1 = this._y0;
	      this._ += "Z";
	    }
	  },
	  lineTo: function(x, y) {
	    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  quadraticCurveTo: function(x1, y1, x, y) {
	    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
	    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  arcTo: function(x1, y1, x2, y2, r) {
	    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
	    var x0 = this._x1,
	        y0 = this._y1,
	        x21 = x2 - x1,
	        y21 = y2 - y1,
	        x01 = x0 - x1,
	        y01 = y0 - y1,
	        l01_2 = x01 * x01 + y01 * y01;

	    // Is the radius negative? Error.
	    if (r < 0) throw new Error("negative radius: " + r);

	    // Is this path empty? Move to (x1,y1).
	    if (this._x1 === null) {
	      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
	    }

	    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
	    else if (!(l01_2 > epsilon$1)) ;

	    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
	    // Equivalently, is (x1,y1) coincident with (x2,y2)?
	    // Or, is the radius zero? Line to (x1,y1).
	    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
	      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
	    }

	    // Otherwise, draw an arc!
	    else {
	      var x20 = x2 - x0,
	          y20 = y2 - y0,
	          l21_2 = x21 * x21 + y21 * y21,
	          l20_2 = x20 * x20 + y20 * y20,
	          l21 = Math.sqrt(l21_2),
	          l01 = Math.sqrt(l01_2),
	          l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
	          t01 = l / l01,
	          t21 = l / l21;

	      // If the start tangent is not coincident with (x0,y0), line to.
	      if (Math.abs(t01 - 1) > epsilon$1) {
	        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
	      }

	      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
	    }
	  },
	  arc: function(x, y, r, a0, a1, ccw) {
	    x = +x, y = +y, r = +r;
	    var dx = r * Math.cos(a0),
	        dy = r * Math.sin(a0),
	        x0 = x + dx,
	        y0 = y + dy,
	        cw = 1 ^ ccw,
	        da = ccw ? a0 - a1 : a1 - a0;

	    // Is the radius negative? Error.
	    if (r < 0) throw new Error("negative radius: " + r);

	    // Is this path empty? Move to (x0,y0).
	    if (this._x1 === null) {
	      this._ += "M" + x0 + "," + y0;
	    }

	    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
	    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
	      this._ += "L" + x0 + "," + y0;
	    }

	    // Is this arc empty? We’re done.
	    if (!r) return;

	    // Does the angle go the wrong way? Flip the direction.
	    if (da < 0) da = da % tau$2 + tau$2;

	    // Is this a complete circle? Draw two arcs to complete the circle.
	    if (da > tauEpsilon) {
	      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
	    }

	    // Is this arc non-empty? Draw an arc!
	    else if (da > epsilon$1) {
	      this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
	    }
	  },
	  rect: function(x, y, w, h) {
	    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
	  },
	  toString: function() {
	    return this._;
	  }
	};

	var prefix = "$";

	function Map() {}

	Map.prototype = map$1.prototype = {
	  constructor: Map,
	  has: function(key) {
	    return (prefix + key) in this;
	  },
	  get: function(key) {
	    return this[prefix + key];
	  },
	  set: function(key, value) {
	    this[prefix + key] = value;
	    return this;
	  },
	  remove: function(key) {
	    var property = prefix + key;
	    return property in this && delete this[property];
	  },
	  clear: function() {
	    for (var property in this) if (property[0] === prefix) delete this[property];
	  },
	  keys: function() {
	    var keys = [];
	    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
	    return keys;
	  },
	  values: function() {
	    var values = [];
	    for (var property in this) if (property[0] === prefix) values.push(this[property]);
	    return values;
	  },
	  entries: function() {
	    var entries = [];
	    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
	    return entries;
	  },
	  size: function() {
	    var size = 0;
	    for (var property in this) if (property[0] === prefix) ++size;
	    return size;
	  },
	  empty: function() {
	    for (var property in this) if (property[0] === prefix) return false;
	    return true;
	  },
	  each: function(f) {
	    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
	  }
	};

	function map$1(object, f) {
	  var map = new Map;

	  // Copy constructor.
	  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

	  // Index array by numeric index or specified key function.
	  else if (Array.isArray(object)) {
	    var i = -1,
	        n = object.length,
	        o;

	    if (f == null) while (++i < n) map.set(i, object[i]);
	    else while (++i < n) map.set(f(o = object[i], i, object), o);
	  }

	  // Convert object to map.
	  else if (object) for (var key in object) map.set(key, object[key]);

	  return map;
	}

	function Set() {}

	var proto$1 = map$1.prototype;

	Set.prototype = set$3.prototype = {
	  constructor: Set,
	  has: proto$1.has,
	  add: function(value) {
	    value += "";
	    this[prefix + value] = value;
	    return this;
	  },
	  remove: proto$1.remove,
	  clear: proto$1.clear,
	  values: proto$1.keys,
	  size: proto$1.size,
	  empty: proto$1.empty,
	  each: proto$1.each
	};

	function set$3(object, f) {
	  var set = new Set;

	  // Copy constructor.
	  if (object instanceof Set) object.each(function(value) { set.add(value); });

	  // Otherwise, assume it’s an array.
	  else if (object) {
	    var i = -1, n = object.length;
	    if (f == null) while (++i < n) set.add(object[i]);
	    else while (++i < n) set.add(f(object[i], i, object));
	  }

	  return set;
	}

	// TODO Optimize edge cases.

	var EOL = {},
	    EOF = {},
	    QUOTE = 34,
	    NEWLINE = 10,
	    RETURN = 13;

	function objectConverter(columns) {
	  return new Function("d", "return {" + columns.map(function(name, i) {
	    return JSON.stringify(name) + ": d[" + i + "]";
	  }).join(",") + "}");
	}

	function customConverter(columns, f) {
	  var object = objectConverter(columns);
	  return function(row, i) {
	    return f(object(row), i, columns);
	  };
	}

	// Compute unique columns in order of discovery.
	function inferColumns(rows) {
	  var columnSet = Object.create(null),
	      columns = [];

	  rows.forEach(function(row) {
	    for (var column in row) {
	      if (!(column in columnSet)) {
	        columns.push(columnSet[column] = column);
	      }
	    }
	  });

	  return columns;
	}

	function dsv(delimiter) {
	  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
	      DELIMITER = delimiter.charCodeAt(0);

	  function parse(text, f) {
	    var convert, columns, rows = parseRows(text, function(row, i) {
	      if (convert) return convert(row, i - 1);
	      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
	    });
	    rows.columns = columns || [];
	    return rows;
	  }

	  function parseRows(text, f) {
	    var rows = [], // output rows
	        N = text.length,
	        I = 0, // current character index
	        n = 0, // current line number
	        t, // current token
	        eof = N <= 0, // current token followed by EOF?
	        eol = false; // current token followed by EOL?

	    // Strip the trailing newline.
	    if (text.charCodeAt(N - 1) === NEWLINE) --N;
	    if (text.charCodeAt(N - 1) === RETURN) --N;

	    function token() {
	      if (eof) return EOF;
	      if (eol) return eol = false, EOL;

	      // Unescape quotes.
	      var i, j = I, c;
	      if (text.charCodeAt(j) === QUOTE) {
	        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
	        if ((i = I) >= N) eof = true;
	        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
	        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
	        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
	      }

	      // Find next delimiter or newline.
	      while (I < N) {
	        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
	        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
	        else if (c !== DELIMITER) continue;
	        return text.slice(j, i);
	      }

	      // Return last token before EOF.
	      return eof = true, text.slice(j, N);
	    }

	    while ((t = token()) !== EOF) {
	      var row = [];
	      while (t !== EOL && t !== EOF) row.push(t), t = token();
	      if (f && (row = f(row, n++)) == null) continue;
	      rows.push(row);
	    }

	    return rows;
	  }

	  function format(rows, columns) {
	    if (columns == null) columns = inferColumns(rows);
	    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
	      return columns.map(function(column) {
	        return formatValue(row[column]);
	      }).join(delimiter);
	    })).join("\n");
	  }

	  function formatRows(rows) {
	    return rows.map(formatRow).join("\n");
	  }

	  function formatRow(row) {
	    return row.map(formatValue).join(delimiter);
	  }

	  function formatValue(text) {
	    return text == null ? ""
	        : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
	        : text;
	  }

	  return {
	    parse: parse,
	    parseRows: parseRows,
	    format: format,
	    formatRows: formatRows
	  };
	}

	var csv = dsv(",");

	var csvParse = csv.parse;
	var csvParseRows = csv.parseRows;
	var csvFormat = csv.format;
	var csvFormatRows = csv.formatRows;

	var tsv = dsv("\t");

	var tsvParse = tsv.parse;
	var tsvParseRows = tsv.parseRows;
	var tsvFormat = tsv.format;
	var tsvFormatRows = tsv.formatRows;

	function tree_add(d) {
	  var x = +this._x.call(null, d),
	      y = +this._y.call(null, d);
	  return add(this.cover(x, y), x, y, d);
	}

	function add(tree, x, y, d) {
	  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

	  var parent,
	      node = tree._root,
	      leaf = {data: d},
	      x0 = tree._x0,
	      y0 = tree._y0,
	      x1 = tree._x1,
	      y1 = tree._y1,
	      xm,
	      ym,
	      xp,
	      yp,
	      right,
	      bottom,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return tree._root = leaf, tree;

	  // Find the existing leaf for the new point, or add it.
	  while (node.length) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
	  }

	  // Is the new point is exactly coincident with the existing point?
	  xp = +tree._x.call(null, node.data);
	  yp = +tree._y.call(null, node.data);
	  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

	  // Otherwise, split the leaf node until the old and new point are separated.
	  do {
	    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
	  return parent[j] = node, parent[i] = leaf, tree;
	}

	function addAll(data) {
	  var d, i, n = data.length,
	      x,
	      y,
	      xz = new Array(n),
	      yz = new Array(n),
	      x0 = Infinity,
	      y0 = Infinity,
	      x1 = -Infinity,
	      y1 = -Infinity;

	  // Compute the points and their extent.
	  for (i = 0; i < n; ++i) {
	    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
	    xz[i] = x;
	    yz[i] = y;
	    if (x < x0) x0 = x;
	    if (x > x1) x1 = x;
	    if (y < y0) y0 = y;
	    if (y > y1) y1 = y;
	  }

	  // If there were no (valid) points, inherit the existing extent.
	  if (x1 < x0) x0 = this._x0, x1 = this._x1;
	  if (y1 < y0) y0 = this._y0, y1 = this._y1;

	  // Expand the tree to cover the new points.
	  this.cover(x0, y0).cover(x1, y1);

	  // Add the new points.
	  for (i = 0; i < n; ++i) {
	    add(this, xz[i], yz[i], data[i]);
	  }

	  return this;
	}

	function tree_cover(x, y) {
	  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

	  var x0 = this._x0,
	      y0 = this._y0,
	      x1 = this._x1,
	      y1 = this._y1;

	  // If the quadtree has no extent, initialize them.
	  // Integer extent are necessary so that if we later double the extent,
	  // the existing quadrant boundaries don’t change due to floating point error!
	  if (isNaN(x0)) {
	    x1 = (x0 = Math.floor(x)) + 1;
	    y1 = (y0 = Math.floor(y)) + 1;
	  }

	  // Otherwise, double repeatedly to cover.
	  else if (x0 > x || x > x1 || y0 > y || y > y1) {
	    var z = x1 - x0,
	        node = this._root,
	        parent,
	        i;

	    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
	      case 0: {
	        do parent = new Array(4), parent[i] = node, node = parent;
	        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
	        break;
	      }
	      case 1: {
	        do parent = new Array(4), parent[i] = node, node = parent;
	        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
	        break;
	      }
	      case 2: {
	        do parent = new Array(4), parent[i] = node, node = parent;
	        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
	        break;
	      }
	      case 3: {
	        do parent = new Array(4), parent[i] = node, node = parent;
	        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
	        break;
	      }
	    }

	    if (this._root && this._root.length) this._root = node;
	  }

	  // If the quadtree covers the point already, just return.
	  else return this;

	  this._x0 = x0;
	  this._y0 = y0;
	  this._x1 = x1;
	  this._y1 = y1;
	  return this;
	}

	function tree_data() {
	  var data = [];
	  this.visit(function(node) {
	    if (!node.length) do data.push(node.data); while (node = node.next)
	  });
	  return data;
	}

	function tree_extent(_) {
	  return arguments.length
	      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
	      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
	}

	function Quad(node, x0, y0, x1, y1) {
	  this.node = node;
	  this.x0 = x0;
	  this.y0 = y0;
	  this.x1 = x1;
	  this.y1 = y1;
	}

	function tree_find(x, y, radius) {
	  var data,
	      x0 = this._x0,
	      y0 = this._y0,
	      x1,
	      y1,
	      x2,
	      y2,
	      x3 = this._x1,
	      y3 = this._y1,
	      quads = [],
	      node = this._root,
	      q,
	      i;

	  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
	  if (radius == null) radius = Infinity;
	  else {
	    x0 = x - radius, y0 = y - radius;
	    x3 = x + radius, y3 = y + radius;
	    radius *= radius;
	  }

	  while (q = quads.pop()) {

	    // Stop searching if this quadrant can’t contain a closer node.
	    if (!(node = q.node)
	        || (x1 = q.x0) > x3
	        || (y1 = q.y0) > y3
	        || (x2 = q.x1) < x0
	        || (y2 = q.y1) < y0) continue;

	    // Bisect the current quadrant.
	    if (node.length) {
	      var xm = (x1 + x2) / 2,
	          ym = (y1 + y2) / 2;

	      quads.push(
	        new Quad(node[3], xm, ym, x2, y2),
	        new Quad(node[2], x1, ym, xm, y2),
	        new Quad(node[1], xm, y1, x2, ym),
	        new Quad(node[0], x1, y1, xm, ym)
	      );

	      // Visit the closest quadrant first.
	      if (i = (y >= ym) << 1 | (x >= xm)) {
	        q = quads[quads.length - 1];
	        quads[quads.length - 1] = quads[quads.length - 1 - i];
	        quads[quads.length - 1 - i] = q;
	      }
	    }

	    // Visit this point. (Visiting coincident points isn’t necessary!)
	    else {
	      var dx = x - +this._x.call(null, node.data),
	          dy = y - +this._y.call(null, node.data),
	          d2 = dx * dx + dy * dy;
	      if (d2 < radius) {
	        var d = Math.sqrt(radius = d2);
	        x0 = x - d, y0 = y - d;
	        x3 = x + d, y3 = y + d;
	        data = node.data;
	      }
	    }
	  }

	  return data;
	}

	function tree_remove(d) {
	  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

	  var parent,
	      node = this._root,
	      retainer,
	      previous,
	      next,
	      x0 = this._x0,
	      y0 = this._y0,
	      x1 = this._x1,
	      y1 = this._y1,
	      x,
	      y,
	      xm,
	      ym,
	      right,
	      bottom,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return this;

	  // Find the leaf node for the point.
	  // While descending, also retain the deepest parent with a non-removed sibling.
	  if (node.length) while (true) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
	    if (!node.length) break;
	    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
	  }

	  // Find the point to remove.
	  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
	  if (next = node.next) delete node.next;

	  // If there are multiple coincident points, remove just the point.
	  if (previous) return (next ? previous.next = next : delete previous.next), this;

	  // If this is the root point, remove it.
	  if (!parent) return this._root = next, this;

	  // Remove this leaf.
	  next ? parent[i] = next : delete parent[i];

	  // If the parent now contains exactly one leaf, collapse superfluous parents.
	  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
	      && node === (parent[3] || parent[2] || parent[1] || parent[0])
	      && !node.length) {
	    if (retainer) retainer[j] = node;
	    else this._root = node;
	  }

	  return this;
	}

	function removeAll(data) {
	  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
	  return this;
	}

	function tree_root() {
	  return this._root;
	}

	function tree_size() {
	  var size = 0;
	  this.visit(function(node) {
	    if (!node.length) do ++size; while (node = node.next)
	  });
	  return size;
	}

	function tree_visit(callback) {
	  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
	  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
	  while (q = quads.pop()) {
	    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
	      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
	      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
	      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
	      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
	      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
	    }
	  }
	  return this;
	}

	function tree_visitAfter(callback) {
	  var quads = [], next = [], q;
	  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
	  while (q = quads.pop()) {
	    var node = q.node;
	    if (node.length) {
	      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
	      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
	      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
	      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
	      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
	    }
	    next.push(q);
	  }
	  while (q = next.pop()) {
	    callback(q.node, q.x0, q.y0, q.x1, q.y1);
	  }
	  return this;
	}

	function defaultX$1(d) {
	  return d[0];
	}

	function tree_x(_) {
	  return arguments.length ? (this._x = _, this) : this._x;
	}

	function defaultY$1(d) {
	  return d[1];
	}

	function tree_y(_) {
	  return arguments.length ? (this._y = _, this) : this._y;
	}

	function quadtree(nodes, x, y) {
	  var tree = new Quadtree(x == null ? defaultX$1 : x, y == null ? defaultY$1 : y, NaN, NaN, NaN, NaN);
	  return nodes == null ? tree : tree.addAll(nodes);
	}

	function Quadtree(x, y, x0, y0, x1, y1) {
	  this._x = x;
	  this._y = y;
	  this._x0 = x0;
	  this._y0 = y0;
	  this._x1 = x1;
	  this._y1 = y1;
	  this._root = undefined;
	}

	function leaf_copy(leaf) {
	  var copy = {data: leaf.data}, next = copy;
	  while (leaf = leaf.next) next = next.next = {data: leaf.data};
	  return copy;
	}

	var treeProto = quadtree.prototype = Quadtree.prototype;

	treeProto.copy = function() {
	  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
	      node = this._root,
	      nodes,
	      child;

	  if (!node) return copy;

	  if (!node.length) return copy._root = leaf_copy(node), copy;

	  nodes = [{source: node, target: copy._root = new Array(4)}];
	  while (node = nodes.pop()) {
	    for (var i = 0; i < 4; ++i) {
	      if (child = node.source[i]) {
	        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
	        else node.target[i] = leaf_copy(child);
	      }
	    }
	  }

	  return copy;
	};

	treeProto.add = tree_add;
	treeProto.addAll = addAll;
	treeProto.cover = tree_cover;
	treeProto.data = tree_data;
	treeProto.extent = tree_extent;
	treeProto.find = tree_find;
	treeProto.remove = tree_remove;
	treeProto.removeAll = removeAll;
	treeProto.root = tree_root;
	treeProto.size = tree_size;
	treeProto.visit = tree_visit;
	treeProto.visitAfter = tree_visitAfter;
	treeProto.x = tree_x;
	treeProto.y = tree_y;

	var initialAngle = Math.PI * (3 - Math.sqrt(5));

	// Computes the decimal coefficient and exponent of the specified number x with
	// significant digits p, where x is positive and p is in [1, 21] or undefined.
	// For example, formatDecimal(1.23) returns ["123", 0].
	function formatDecimal(x, p) {
	  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
	  var i, coefficient = x.slice(0, i);

	  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
	  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
	  return [
	    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
	    +x.slice(i + 1)
	  ];
	}

	function exponent$1(x) {
	  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
	}

	function formatGroup(grouping, thousands) {
	  return function(value, width) {
	    var i = value.length,
	        t = [],
	        j = 0,
	        g = grouping[0],
	        length = 0;

	    while (i > 0 && g > 0) {
	      if (length + g + 1 > width) g = Math.max(1, width - length);
	      t.push(value.substring(i -= g, i + g));
	      if ((length += g + 1) > width) break;
	      g = grouping[j = (j + 1) % grouping.length];
	    }

	    return t.reverse().join(thousands);
	  };
	}

	function formatNumerals(numerals) {
	  return function(value) {
	    return value.replace(/[0-9]/g, function(i) {
	      return numerals[+i];
	    });
	  };
	}

	// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
	var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

	function formatSpecifier(specifier) {
	  return new FormatSpecifier(specifier);
	}

	formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

	function FormatSpecifier(specifier) {
	  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
	  var match;
	  this.fill = match[1] || " ";
	  this.align = match[2] || ">";
	  this.sign = match[3] || "-";
	  this.symbol = match[4] || "";
	  this.zero = !!match[5];
	  this.width = match[6] && +match[6];
	  this.comma = !!match[7];
	  this.precision = match[8] && +match[8].slice(1);
	  this.trim = !!match[9];
	  this.type = match[10] || "";
	}

	FormatSpecifier.prototype.toString = function() {
	  return this.fill
	      + this.align
	      + this.sign
	      + this.symbol
	      + (this.zero ? "0" : "")
	      + (this.width == null ? "" : Math.max(1, this.width | 0))
	      + (this.comma ? "," : "")
	      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
	      + (this.trim ? "~" : "")
	      + this.type;
	};

	// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
	function formatTrim(s) {
	  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
	    switch (s[i]) {
	      case ".": i0 = i1 = i; break;
	      case "0": if (i0 === 0) i0 = i; i1 = i; break;
	      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
	    }
	  }
	  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
	}

	var prefixExponent;

	function formatPrefixAuto(x, p) {
	  var d = formatDecimal(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1],
	      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
	      n = coefficient.length;
	  return i === n ? coefficient
	      : i > n ? coefficient + new Array(i - n + 1).join("0")
	      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
	      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
	}

	function formatRounded(x, p) {
	  var d = formatDecimal(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1];
	  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
	      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
	      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
	}

	var formatTypes = {
	  "%": function(x, p) { return (x * 100).toFixed(p); },
	  "b": function(x) { return Math.round(x).toString(2); },
	  "c": function(x) { return x + ""; },
	  "d": function(x) { return Math.round(x).toString(10); },
	  "e": function(x, p) { return x.toExponential(p); },
	  "f": function(x, p) { return x.toFixed(p); },
	  "g": function(x, p) { return x.toPrecision(p); },
	  "o": function(x) { return Math.round(x).toString(8); },
	  "p": function(x, p) { return formatRounded(x * 100, p); },
	  "r": formatRounded,
	  "s": formatPrefixAuto,
	  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
	  "x": function(x) { return Math.round(x).toString(16); }
	};

	function identity$3(x) {
	  return x;
	}

	var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

	function formatLocale(locale) {
	  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,
	      currency = locale.currency,
	      decimal = locale.decimal,
	      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$3,
	      percent = locale.percent || "%";

	  function newFormat(specifier) {
	    specifier = formatSpecifier(specifier);

	    var fill = specifier.fill,
	        align = specifier.align,
	        sign = specifier.sign,
	        symbol = specifier.symbol,
	        zero = specifier.zero,
	        width = specifier.width,
	        comma = specifier.comma,
	        precision = specifier.precision,
	        trim = specifier.trim,
	        type = specifier.type;

	    // The "n" type is an alias for ",g".
	    if (type === "n") comma = true, type = "g";

	    // The "" type, and any invalid type, is an alias for ".12~g".
	    else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

	    // If zero fill is specified, padding goes after sign and before digits.
	    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

	    // Compute the prefix and suffix.
	    // For SI-prefix, the suffix is lazily computed.
	    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
	        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

	    // What format function should we use?
	    // Is this an integer type?
	    // Can this type generate exponential notation?
	    var formatType = formatTypes[type],
	        maybeSuffix = /[defgprs%]/.test(type);

	    // Set the default precision if not specified,
	    // or clamp the specified precision to the supported range.
	    // For significant precision, it must be in [1, 21].
	    // For fixed precision, it must be in [0, 20].
	    precision = precision == null ? 6
	        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
	        : Math.max(0, Math.min(20, precision));

	    function format(value) {
	      var valuePrefix = prefix,
	          valueSuffix = suffix,
	          i, n, c;

	      if (type === "c") {
	        valueSuffix = formatType(value) + valueSuffix;
	        value = "";
	      } else {
	        value = +value;

	        // Perform the initial formatting.
	        var valueNegative = value < 0;
	        value = formatType(Math.abs(value), precision);

	        // Trim insignificant zeros.
	        if (trim) value = formatTrim(value);

	        // If a negative value rounds to zero during formatting, treat as positive.
	        if (valueNegative && +value === 0) valueNegative = false;

	        // Compute the prefix and suffix.
	        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
	        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

	        // Break the formatted value into the integer “value” part that can be
	        // grouped, and fractional or exponential “suffix” part that is not.
	        if (maybeSuffix) {
	          i = -1, n = value.length;
	          while (++i < n) {
	            if (c = value.charCodeAt(i), 48 > c || c > 57) {
	              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
	              value = value.slice(0, i);
	              break;
	            }
	          }
	        }
	      }

	      // If the fill character is not "0", grouping is applied before padding.
	      if (comma && !zero) value = group(value, Infinity);

	      // Compute the padding.
	      var length = valuePrefix.length + value.length + valueSuffix.length,
	          padding = length < width ? new Array(width - length + 1).join(fill) : "";

	      // If the fill character is "0", grouping is applied after padding.
	      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

	      // Reconstruct the final output based on the desired alignment.
	      switch (align) {
	        case "<": value = valuePrefix + value + valueSuffix + padding; break;
	        case "=": value = valuePrefix + padding + value + valueSuffix; break;
	        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
	        default: value = padding + valuePrefix + value + valueSuffix; break;
	      }

	      return numerals(value);
	    }

	    format.toString = function() {
	      return specifier + "";
	    };

	    return format;
	  }

	  function formatPrefix(specifier, value) {
	    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
	        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
	        k = Math.pow(10, -e),
	        prefix = prefixes[8 + e / 3];
	    return function(value) {
	      return f(k * value) + prefix;
	    };
	  }

	  return {
	    format: newFormat,
	    formatPrefix: formatPrefix
	  };
	}

	var locale;
	var format;
	var formatPrefix;

	defaultLocale({
	  decimal: ".",
	  thousands: ",",
	  grouping: [3],
	  currency: ["$", ""]
	});

	function defaultLocale(definition) {
	  locale = formatLocale(definition);
	  format = locale.format;
	  formatPrefix = locale.formatPrefix;
	  return locale;
	}

	function precisionFixed(step) {
	  return Math.max(0, -exponent$1(Math.abs(step)));
	}

	function precisionPrefix(step, value) {
	  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
	}

	function precisionRound(step, max) {
	  step = Math.abs(step), max = Math.abs(max) - step;
	  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
	}

	// Adds floating point numbers with twice the normal precision.
	// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
	// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
	// 305–363 (1997).
	// Code adapted from GeographicLib by Charles F. F. Karney,
	// http://geographiclib.sourceforge.net/

	function adder() {
	  return new Adder;
	}

	function Adder() {
	  this.reset();
	}

	Adder.prototype = {
	  constructor: Adder,
	  reset: function() {
	    this.s = // rounded value
	    this.t = 0; // exact error
	  },
	  add: function(y) {
	    add$1(temp, y, this.t);
	    add$1(this, temp.s, this.s);
	    if (this.s) this.t += temp.t;
	    else this.s = temp.t;
	  },
	  valueOf: function() {
	    return this.s;
	  }
	};

	var temp = new Adder;

	function add$1(adder, a, b) {
	  var x = adder.s = a + b,
	      bv = x - a,
	      av = x - bv;
	  adder.t = (a - av) + (b - bv);
	}

	var pi$3 = Math.PI;

	var areaRingSum = adder();

	var areaSum = adder();

	var deltaSum = adder();

	var sum$1 = adder();

	var lengthSum = adder();

	var areaSum$1 = adder(),
	    areaRingSum$1 = adder();

	var lengthSum$1 = adder();

	// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of

	var array$3 = Array.prototype;

	var map$2 = array$3.map;
	var slice$5 = array$3.slice;

	function constant$a(x) {
	  return function() {
	    return x;
	  };
	}

	function number$2(x) {
	  return +x;
	}

	var unit = [0, 1];

	function deinterpolateLinear(a, b) {
	  return (b -= (a = +a))
	      ? function(x) { return (x - a) / b; }
	      : constant$a(b);
	}

	function deinterpolateClamp(deinterpolate) {
	  return function(a, b) {
	    var d = deinterpolate(a = +a, b = +b);
	    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
	  };
	}

	function reinterpolateClamp(reinterpolate) {
	  return function(a, b) {
	    var r = reinterpolate(a = +a, b = +b);
	    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
	  };
	}

	function bimap(domain, range, deinterpolate, reinterpolate) {
	  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
	  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
	  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
	  return function(x) { return r0(d0(x)); };
	}

	function polymap(domain, range, deinterpolate, reinterpolate) {
	  var j = Math.min(domain.length, range.length) - 1,
	      d = new Array(j),
	      r = new Array(j),
	      i = -1;

	  // Reverse descending domains.
	  if (domain[j] < domain[0]) {
	    domain = domain.slice().reverse();
	    range = range.slice().reverse();
	  }

	  while (++i < j) {
	    d[i] = deinterpolate(domain[i], domain[i + 1]);
	    r[i] = reinterpolate(range[i], range[i + 1]);
	  }

	  return function(x) {
	    var i = bisectRight(domain, x, 1, j) - 1;
	    return r[i](d[i](x));
	  };
	}

	function copy(source, target) {
	  return target
	      .domain(source.domain())
	      .range(source.range())
	      .interpolate(source.interpolate())
	      .clamp(source.clamp());
	}

	// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
	// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
	function continuous(deinterpolate, reinterpolate) {
	  var domain = unit,
	      range = unit,
	      interpolate$$1 = interpolateValue,
	      clamp = false,
	      piecewise$$1,
	      output,
	      input;

	  function rescale() {
	    piecewise$$1 = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
	    output = input = null;
	    return scale;
	  }

	  function scale(x) {
	    return (output || (output = piecewise$$1(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
	  }

	  scale.invert = function(y) {
	    return (input || (input = piecewise$$1(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain = map$2.call(_, number$2), rescale()) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range = slice$5.call(_), interpolate$$1 = interpolateRound, rescale();
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = !!_, rescale()) : clamp;
	  };

	  scale.interpolate = function(_) {
	    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
	  };

	  return rescale();
	}

	function tickFormat(domain, count, specifier) {
	  var start = domain[0],
	      stop = domain[domain.length - 1],
	      step = tickStep(start, stop, count == null ? 10 : count),
	      precision;
	  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
	  switch (specifier.type) {
	    case "s": {
	      var value = Math.max(Math.abs(start), Math.abs(stop));
	      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
	      return formatPrefix(specifier, value);
	    }
	    case "":
	    case "e":
	    case "g":
	    case "p":
	    case "r": {
	      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
	      break;
	    }
	    case "f":
	    case "%": {
	      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
	      break;
	    }
	  }
	  return format(specifier);
	}

	function linearish(scale) {
	  var domain = scale.domain;

	  scale.ticks = function(count) {
	    var d = domain();
	    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	  };

	  scale.tickFormat = function(count, specifier) {
	    return tickFormat(domain(), count, specifier);
	  };

	  scale.nice = function(count) {
	    if (count == null) count = 10;

	    var d = domain(),
	        i0 = 0,
	        i1 = d.length - 1,
	        start = d[i0],
	        stop = d[i1],
	        step;

	    if (stop < start) {
	      step = start, start = stop, stop = step;
	      step = i0, i0 = i1, i1 = step;
	    }

	    step = tickIncrement(start, stop, count);

	    if (step > 0) {
	      start = Math.floor(start / step) * step;
	      stop = Math.ceil(stop / step) * step;
	      step = tickIncrement(start, stop, count);
	    } else if (step < 0) {
	      start = Math.ceil(start * step) / step;
	      stop = Math.floor(stop * step) / step;
	      step = tickIncrement(start, stop, count);
	    }

	    if (step > 0) {
	      d[i0] = Math.floor(start / step) * step;
	      d[i1] = Math.ceil(stop / step) * step;
	      domain(d);
	    } else if (step < 0) {
	      d[i0] = Math.ceil(start * step) / step;
	      d[i1] = Math.floor(stop * step) / step;
	      domain(d);
	    }

	    return scale;
	  };

	  return scale;
	}

	function linear$3() {
	  var scale = continuous(deinterpolateLinear, interpolateNumber);

	  scale.copy = function() {
	    return copy(scale, linear$3());
	  };

	  return linearish(scale);
	}

	var t0$1 = new Date,
	    t1$1 = new Date;

	function newInterval(floori, offseti, count, field) {

	  function interval(date) {
	    return floori(date = new Date(+date)), date;
	  }

	  interval.floor = interval;

	  interval.ceil = function(date) {
	    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
	  };

	  interval.round = function(date) {
	    var d0 = interval(date),
	        d1 = interval.ceil(date);
	    return date - d0 < d1 - date ? d0 : d1;
	  };

	  interval.offset = function(date, step) {
	    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
	  };

	  interval.range = function(start, stop, step) {
	    var range = [], previous;
	    start = interval.ceil(start);
	    step = step == null ? 1 : Math.floor(step);
	    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
	    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
	    while (previous < start && start < stop);
	    return range;
	  };

	  interval.filter = function(test) {
	    return newInterval(function(date) {
	      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
	    }, function(date, step) {
	      if (date >= date) {
	        if (step < 0) while (++step <= 0) {
	          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
	        } else while (--step >= 0) {
	          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
	        }
	      }
	    });
	  };

	  if (count) {
	    interval.count = function(start, end) {
	      t0$1.setTime(+start), t1$1.setTime(+end);
	      floori(t0$1), floori(t1$1);
	      return Math.floor(count(t0$1, t1$1));
	    };

	    interval.every = function(step) {
	      step = Math.floor(step);
	      return !isFinite(step) || !(step > 0) ? null
	          : !(step > 1) ? interval
	          : interval.filter(field
	              ? function(d) { return field(d) % step === 0; }
	              : function(d) { return interval.count(0, d) % step === 0; });
	    };
	  }

	  return interval;
	}

	var millisecond = newInterval(function() {
	  // noop
	}, function(date, step) {
	  date.setTime(+date + step);
	}, function(start, end) {
	  return end - start;
	});

	// An optimized implementation for this simple case.
	millisecond.every = function(k) {
	  k = Math.floor(k);
	  if (!isFinite(k) || !(k > 0)) return null;
	  if (!(k > 1)) return millisecond;
	  return newInterval(function(date) {
	    date.setTime(Math.floor(date / k) * k);
	  }, function(date, step) {
	    date.setTime(+date + step * k);
	  }, function(start, end) {
	    return (end - start) / k;
	  });
	};
	var milliseconds = millisecond.range;

	var durationSecond = 1e3;
	var durationMinute = 6e4;
	var durationHour = 36e5;
	var durationDay = 864e5;
	var durationWeek = 6048e5;

	var second = newInterval(function(date) {
	  date.setTime(Math.floor(date / durationSecond) * durationSecond);
	}, function(date, step) {
	  date.setTime(+date + step * durationSecond);
	}, function(start, end) {
	  return (end - start) / durationSecond;
	}, function(date) {
	  return date.getUTCSeconds();
	});
	var seconds = second.range;

	var minute = newInterval(function(date) {
	  date.setTime(Math.floor(date / durationMinute) * durationMinute);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute);
	}, function(start, end) {
	  return (end - start) / durationMinute;
	}, function(date) {
	  return date.getMinutes();
	});
	var minutes = minute.range;

	var hour = newInterval(function(date) {
	  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
	  if (offset < 0) offset += durationHour;
	  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour);
	}, function(start, end) {
	  return (end - start) / durationHour;
	}, function(date) {
	  return date.getHours();
	});
	var hours = hour.range;

	var day = newInterval(function(date) {
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setDate(date.getDate() + step);
	}, function(start, end) {
	  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
	}, function(date) {
	  return date.getDate() - 1;
	});
	var days = day.range;

	function weekday(i) {
	  return newInterval(function(date) {
	    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setDate(date.getDate() + step * 7);
	  }, function(start, end) {
	    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
	  });
	}

	var sunday = weekday(0);
	var monday = weekday(1);
	var tuesday = weekday(2);
	var wednesday = weekday(3);
	var thursday = weekday(4);
	var friday = weekday(5);
	var saturday = weekday(6);

	var sundays = sunday.range;
	var mondays = monday.range;
	var thursdays = thursday.range;

	var month = newInterval(function(date) {
	  date.setDate(1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setMonth(date.getMonth() + step);
	}, function(start, end) {
	  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
	}, function(date) {
	  return date.getMonth();
	});
	var months = month.range;

	var year = newInterval(function(date) {
	  date.setMonth(0, 1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setFullYear(date.getFullYear() + step);
	}, function(start, end) {
	  return end.getFullYear() - start.getFullYear();
	}, function(date) {
	  return date.getFullYear();
	});

	// An optimized implementation for this simple case.
	year.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
	    date.setMonth(0, 1);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setFullYear(date.getFullYear() + step * k);
	  });
	};
	var years = year.range;

	var utcMinute = newInterval(function(date) {
	  date.setUTCSeconds(0, 0);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute);
	}, function(start, end) {
	  return (end - start) / durationMinute;
	}, function(date) {
	  return date.getUTCMinutes();
	});
	var utcMinutes = utcMinute.range;

	var utcHour = newInterval(function(date) {
	  date.setUTCMinutes(0, 0, 0);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour);
	}, function(start, end) {
	  return (end - start) / durationHour;
	}, function(date) {
	  return date.getUTCHours();
	});
	var utcHours = utcHour.range;

	var utcDay = newInterval(function(date) {
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCDate(date.getUTCDate() + step);
	}, function(start, end) {
	  return (end - start) / durationDay;
	}, function(date) {
	  return date.getUTCDate() - 1;
	});
	var utcDays = utcDay.range;

	function utcWeekday(i) {
	  return newInterval(function(date) {
	    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCDate(date.getUTCDate() + step * 7);
	  }, function(start, end) {
	    return (end - start) / durationWeek;
	  });
	}

	var utcSunday = utcWeekday(0);
	var utcMonday = utcWeekday(1);
	var utcTuesday = utcWeekday(2);
	var utcWednesday = utcWeekday(3);
	var utcThursday = utcWeekday(4);
	var utcFriday = utcWeekday(5);
	var utcSaturday = utcWeekday(6);

	var utcSundays = utcSunday.range;
	var utcMondays = utcMonday.range;
	var utcThursdays = utcThursday.range;

	var utcMonth = newInterval(function(date) {
	  date.setUTCDate(1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCMonth(date.getUTCMonth() + step);
	}, function(start, end) {
	  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
	}, function(date) {
	  return date.getUTCMonth();
	});
	var utcMonths = utcMonth.range;

	var utcYear = newInterval(function(date) {
	  date.setUTCMonth(0, 1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCFullYear(date.getUTCFullYear() + step);
	}, function(start, end) {
	  return end.getUTCFullYear() - start.getUTCFullYear();
	}, function(date) {
	  return date.getUTCFullYear();
	});

	// An optimized implementation for this simple case.
	utcYear.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
	    date.setUTCMonth(0, 1);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCFullYear(date.getUTCFullYear() + step * k);
	  });
	};
	var utcYears = utcYear.range;

	function localDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
	    date.setFullYear(d.y);
	    return date;
	  }
	  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
	}

	function utcDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
	    date.setUTCFullYear(d.y);
	    return date;
	  }
	  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
	}

	function newYear(y) {
	  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
	}

	function formatLocale$1(locale) {
	  var locale_dateTime = locale.dateTime,
	      locale_date = locale.date,
	      locale_time = locale.time,
	      locale_periods = locale.periods,
	      locale_weekdays = locale.days,
	      locale_shortWeekdays = locale.shortDays,
	      locale_months = locale.months,
	      locale_shortMonths = locale.shortMonths;

	  var periodRe = formatRe(locale_periods),
	      periodLookup = formatLookup(locale_periods),
	      weekdayRe = formatRe(locale_weekdays),
	      weekdayLookup = formatLookup(locale_weekdays),
	      shortWeekdayRe = formatRe(locale_shortWeekdays),
	      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
	      monthRe = formatRe(locale_months),
	      monthLookup = formatLookup(locale_months),
	      shortMonthRe = formatRe(locale_shortMonths),
	      shortMonthLookup = formatLookup(locale_shortMonths);

	  var formats = {
	    "a": formatShortWeekday,
	    "A": formatWeekday,
	    "b": formatShortMonth,
	    "B": formatMonth,
	    "c": null,
	    "d": formatDayOfMonth,
	    "e": formatDayOfMonth,
	    "f": formatMicroseconds,
	    "H": formatHour24,
	    "I": formatHour12,
	    "j": formatDayOfYear,
	    "L": formatMilliseconds,
	    "m": formatMonthNumber,
	    "M": formatMinutes,
	    "p": formatPeriod,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatSeconds,
	    "u": formatWeekdayNumberMonday,
	    "U": formatWeekNumberSunday,
	    "V": formatWeekNumberISO,
	    "w": formatWeekdayNumberSunday,
	    "W": formatWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatYear,
	    "Y": formatFullYear,
	    "Z": formatZone,
	    "%": formatLiteralPercent
	  };

	  var utcFormats = {
	    "a": formatUTCShortWeekday,
	    "A": formatUTCWeekday,
	    "b": formatUTCShortMonth,
	    "B": formatUTCMonth,
	    "c": null,
	    "d": formatUTCDayOfMonth,
	    "e": formatUTCDayOfMonth,
	    "f": formatUTCMicroseconds,
	    "H": formatUTCHour24,
	    "I": formatUTCHour12,
	    "j": formatUTCDayOfYear,
	    "L": formatUTCMilliseconds,
	    "m": formatUTCMonthNumber,
	    "M": formatUTCMinutes,
	    "p": formatUTCPeriod,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatUTCSeconds,
	    "u": formatUTCWeekdayNumberMonday,
	    "U": formatUTCWeekNumberSunday,
	    "V": formatUTCWeekNumberISO,
	    "w": formatUTCWeekdayNumberSunday,
	    "W": formatUTCWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatUTCYear,
	    "Y": formatUTCFullYear,
	    "Z": formatUTCZone,
	    "%": formatLiteralPercent
	  };

	  var parses = {
	    "a": parseShortWeekday,
	    "A": parseWeekday,
	    "b": parseShortMonth,
	    "B": parseMonth,
	    "c": parseLocaleDateTime,
	    "d": parseDayOfMonth,
	    "e": parseDayOfMonth,
	    "f": parseMicroseconds,
	    "H": parseHour24,
	    "I": parseHour24,
	    "j": parseDayOfYear,
	    "L": parseMilliseconds,
	    "m": parseMonthNumber,
	    "M": parseMinutes,
	    "p": parsePeriod,
	    "Q": parseUnixTimestamp,
	    "s": parseUnixTimestampSeconds,
	    "S": parseSeconds,
	    "u": parseWeekdayNumberMonday,
	    "U": parseWeekNumberSunday,
	    "V": parseWeekNumberISO,
	    "w": parseWeekdayNumberSunday,
	    "W": parseWeekNumberMonday,
	    "x": parseLocaleDate,
	    "X": parseLocaleTime,
	    "y": parseYear,
	    "Y": parseFullYear,
	    "Z": parseZone,
	    "%": parseLiteralPercent
	  };

	  // These recursive directive definitions must be deferred.
	  formats.x = newFormat(locale_date, formats);
	  formats.X = newFormat(locale_time, formats);
	  formats.c = newFormat(locale_dateTime, formats);
	  utcFormats.x = newFormat(locale_date, utcFormats);
	  utcFormats.X = newFormat(locale_time, utcFormats);
	  utcFormats.c = newFormat(locale_dateTime, utcFormats);

	  function newFormat(specifier, formats) {
	    return function(date) {
	      var string = [],
	          i = -1,
	          j = 0,
	          n = specifier.length,
	          c,
	          pad,
	          format;

	      if (!(date instanceof Date)) date = new Date(+date);

	      while (++i < n) {
	        if (specifier.charCodeAt(i) === 37) {
	          string.push(specifier.slice(j, i));
	          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
	          else pad = c === "e" ? " " : "0";
	          if (format = formats[c]) c = format(date, pad);
	          string.push(c);
	          j = i + 1;
	        }
	      }

	      string.push(specifier.slice(j, i));
	      return string.join("");
	    };
	  }

	  function newParse(specifier, newDate) {
	    return function(string) {
	      var d = newYear(1900),
	          i = parseSpecifier(d, specifier, string += "", 0),
	          week, day$$1;
	      if (i != string.length) return null;

	      // If a UNIX timestamp is specified, return it.
	      if ("Q" in d) return new Date(d.Q);

	      // The am-pm flag is 0 for AM, and 1 for PM.
	      if ("p" in d) d.H = d.H % 12 + d.p * 12;

	      // Convert day-of-week and week-of-year to day-of-year.
	      if ("V" in d) {
	        if (d.V < 1 || d.V > 53) return null;
	        if (!("w" in d)) d.w = 1;
	        if ("Z" in d) {
	          week = utcDate(newYear(d.y)), day$$1 = week.getUTCDay();
	          week = day$$1 > 4 || day$$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
	          week = utcDay.offset(week, (d.V - 1) * 7);
	          d.y = week.getUTCFullYear();
	          d.m = week.getUTCMonth();
	          d.d = week.getUTCDate() + (d.w + 6) % 7;
	        } else {
	          week = newDate(newYear(d.y)), day$$1 = week.getDay();
	          week = day$$1 > 4 || day$$1 === 0 ? monday.ceil(week) : monday(week);
	          week = day.offset(week, (d.V - 1) * 7);
	          d.y = week.getFullYear();
	          d.m = week.getMonth();
	          d.d = week.getDate() + (d.w + 6) % 7;
	        }
	      } else if ("W" in d || "U" in d) {
	        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
	        day$$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
	        d.m = 0;
	        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;
	      }

	      // If a time zone is specified, all fields are interpreted as UTC and then
	      // offset according to the specified time zone.
	      if ("Z" in d) {
	        d.H += d.Z / 100 | 0;
	        d.M += d.Z % 100;
	        return utcDate(d);
	      }

	      // Otherwise, all fields are in local time.
	      return newDate(d);
	    };
	  }

	  function parseSpecifier(d, specifier, string, j) {
	    var i = 0,
	        n = specifier.length,
	        m = string.length,
	        c,
	        parse;

	    while (i < n) {
	      if (j >= m) return -1;
	      c = specifier.charCodeAt(i++);
	      if (c === 37) {
	        c = specifier.charAt(i++);
	        parse = parses[c in pads ? specifier.charAt(i++) : c];
	        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
	      } else if (c != string.charCodeAt(j++)) {
	        return -1;
	      }
	    }

	    return j;
	  }

	  function parsePeriod(d, string, i) {
	    var n = periodRe.exec(string.slice(i));
	    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseShortWeekday(d, string, i) {
	    var n = shortWeekdayRe.exec(string.slice(i));
	    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseWeekday(d, string, i) {
	    var n = weekdayRe.exec(string.slice(i));
	    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseShortMonth(d, string, i) {
	    var n = shortMonthRe.exec(string.slice(i));
	    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseMonth(d, string, i) {
	    var n = monthRe.exec(string.slice(i));
	    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseLocaleDateTime(d, string, i) {
	    return parseSpecifier(d, locale_dateTime, string, i);
	  }

	  function parseLocaleDate(d, string, i) {
	    return parseSpecifier(d, locale_date, string, i);
	  }

	  function parseLocaleTime(d, string, i) {
	    return parseSpecifier(d, locale_time, string, i);
	  }

	  function formatShortWeekday(d) {
	    return locale_shortWeekdays[d.getDay()];
	  }

	  function formatWeekday(d) {
	    return locale_weekdays[d.getDay()];
	  }

	  function formatShortMonth(d) {
	    return locale_shortMonths[d.getMonth()];
	  }

	  function formatMonth(d) {
	    return locale_months[d.getMonth()];
	  }

	  function formatPeriod(d) {
	    return locale_periods[+(d.getHours() >= 12)];
	  }

	  function formatUTCShortWeekday(d) {
	    return locale_shortWeekdays[d.getUTCDay()];
	  }

	  function formatUTCWeekday(d) {
	    return locale_weekdays[d.getUTCDay()];
	  }

	  function formatUTCShortMonth(d) {
	    return locale_shortMonths[d.getUTCMonth()];
	  }

	  function formatUTCMonth(d) {
	    return locale_months[d.getUTCMonth()];
	  }

	  function formatUTCPeriod(d) {
	    return locale_periods[+(d.getUTCHours() >= 12)];
	  }

	  return {
	    format: function(specifier) {
	      var f = newFormat(specifier += "", formats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    parse: function(specifier) {
	      var p = newParse(specifier += "", localDate);
	      p.toString = function() { return specifier; };
	      return p;
	    },
	    utcFormat: function(specifier) {
	      var f = newFormat(specifier += "", utcFormats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    utcParse: function(specifier) {
	      var p = newParse(specifier, utcDate);
	      p.toString = function() { return specifier; };
	      return p;
	    }
	  };
	}

	var pads = {"-": "", "_": " ", "0": "0"},
	    numberRe = /^\s*\d+/, // note: ignores next directive
	    percentRe = /^%/,
	    requoteRe = /[\\^$*+?|[\]().{}]/g;

	function pad(value, fill, width) {
	  var sign = value < 0 ? "-" : "",
	      string = (sign ? -value : value) + "",
	      length = string.length;
	  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	}

	function requote(s) {
	  return s.replace(requoteRe, "\\$&");
	}

	function formatRe(names) {
	  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
	}

	function formatLookup(names) {
	  var map = {}, i = -1, n = names.length;
	  while (++i < n) map[names[i].toLowerCase()] = i;
	  return map;
	}

	function parseWeekdayNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.w = +n[0], i + n[0].length) : -1;
	}

	function parseWeekdayNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.u = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.U = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberISO(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.V = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.W = +n[0], i + n[0].length) : -1;
	}

	function parseFullYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 4));
	  return n ? (d.y = +n[0], i + n[0].length) : -1;
	}

	function parseYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
	}

	function parseZone(d, string, i) {
	  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
	  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
	}

	function parseMonthNumber(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
	}

	function parseDayOfMonth(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.d = +n[0], i + n[0].length) : -1;
	}

	function parseDayOfYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
	}

	function parseHour24(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.H = +n[0], i + n[0].length) : -1;
	}

	function parseMinutes(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.M = +n[0], i + n[0].length) : -1;
	}

	function parseSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.S = +n[0], i + n[0].length) : -1;
	}

	function parseMilliseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.L = +n[0], i + n[0].length) : -1;
	}

	function parseMicroseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 6));
	  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
	}

	function parseLiteralPercent(d, string, i) {
	  var n = percentRe.exec(string.slice(i, i + 1));
	  return n ? i + n[0].length : -1;
	}

	function parseUnixTimestamp(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.Q = +n[0], i + n[0].length) : -1;
	}

	function parseUnixTimestampSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
	}

	function formatDayOfMonth(d, p) {
	  return pad(d.getDate(), p, 2);
	}

	function formatHour24(d, p) {
	  return pad(d.getHours(), p, 2);
	}

	function formatHour12(d, p) {
	  return pad(d.getHours() % 12 || 12, p, 2);
	}

	function formatDayOfYear(d, p) {
	  return pad(1 + day.count(year(d), d), p, 3);
	}

	function formatMilliseconds(d, p) {
	  return pad(d.getMilliseconds(), p, 3);
	}

	function formatMicroseconds(d, p) {
	  return formatMilliseconds(d, p) + "000";
	}

	function formatMonthNumber(d, p) {
	  return pad(d.getMonth() + 1, p, 2);
	}

	function formatMinutes(d, p) {
	  return pad(d.getMinutes(), p, 2);
	}

	function formatSeconds(d, p) {
	  return pad(d.getSeconds(), p, 2);
	}

	function formatWeekdayNumberMonday(d) {
	  var day$$1 = d.getDay();
	  return day$$1 === 0 ? 7 : day$$1;
	}

	function formatWeekNumberSunday(d, p) {
	  return pad(sunday.count(year(d), d), p, 2);
	}

	function formatWeekNumberISO(d, p) {
	  var day$$1 = d.getDay();
	  d = (day$$1 >= 4 || day$$1 === 0) ? thursday(d) : thursday.ceil(d);
	  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
	}

	function formatWeekdayNumberSunday(d) {
	  return d.getDay();
	}

	function formatWeekNumberMonday(d, p) {
	  return pad(monday.count(year(d), d), p, 2);
	}

	function formatYear(d, p) {
	  return pad(d.getFullYear() % 100, p, 2);
	}

	function formatFullYear(d, p) {
	  return pad(d.getFullYear() % 10000, p, 4);
	}

	function formatZone(d) {
	  var z = d.getTimezoneOffset();
	  return (z > 0 ? "-" : (z *= -1, "+"))
	      + pad(z / 60 | 0, "0", 2)
	      + pad(z % 60, "0", 2);
	}

	function formatUTCDayOfMonth(d, p) {
	  return pad(d.getUTCDate(), p, 2);
	}

	function formatUTCHour24(d, p) {
	  return pad(d.getUTCHours(), p, 2);
	}

	function formatUTCHour12(d, p) {
	  return pad(d.getUTCHours() % 12 || 12, p, 2);
	}

	function formatUTCDayOfYear(d, p) {
	  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
	}

	function formatUTCMilliseconds(d, p) {
	  return pad(d.getUTCMilliseconds(), p, 3);
	}

	function formatUTCMicroseconds(d, p) {
	  return formatUTCMilliseconds(d, p) + "000";
	}

	function formatUTCMonthNumber(d, p) {
	  return pad(d.getUTCMonth() + 1, p, 2);
	}

	function formatUTCMinutes(d, p) {
	  return pad(d.getUTCMinutes(), p, 2);
	}

	function formatUTCSeconds(d, p) {
	  return pad(d.getUTCSeconds(), p, 2);
	}

	function formatUTCWeekdayNumberMonday(d) {
	  var dow = d.getUTCDay();
	  return dow === 0 ? 7 : dow;
	}

	function formatUTCWeekNumberSunday(d, p) {
	  return pad(utcSunday.count(utcYear(d), d), p, 2);
	}

	function formatUTCWeekNumberISO(d, p) {
	  var day$$1 = d.getUTCDay();
	  d = (day$$1 >= 4 || day$$1 === 0) ? utcThursday(d) : utcThursday.ceil(d);
	  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
	}

	function formatUTCWeekdayNumberSunday(d) {
	  return d.getUTCDay();
	}

	function formatUTCWeekNumberMonday(d, p) {
	  return pad(utcMonday.count(utcYear(d), d), p, 2);
	}

	function formatUTCYear(d, p) {
	  return pad(d.getUTCFullYear() % 100, p, 2);
	}

	function formatUTCFullYear(d, p) {
	  return pad(d.getUTCFullYear() % 10000, p, 4);
	}

	function formatUTCZone() {
	  return "+0000";
	}

	function formatLiteralPercent() {
	  return "%";
	}

	function formatUnixTimestamp(d) {
	  return +d;
	}

	function formatUnixTimestampSeconds(d) {
	  return Math.floor(+d / 1000);
	}

	var locale$1;
	var timeFormat;
	var timeParse;
	var utcFormat;
	var utcParse;

	defaultLocale$1({
	  dateTime: "%x, %X",
	  date: "%-m/%-d/%Y",
	  time: "%-I:%M:%S %p",
	  periods: ["AM", "PM"],
	  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	});

	function defaultLocale$1(definition) {
	  locale$1 = formatLocale$1(definition);
	  timeFormat = locale$1.format;
	  timeParse = locale$1.parse;
	  utcFormat = locale$1.utcFormat;
	  utcParse = locale$1.utcParse;
	  return locale$1;
	}

	var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

	function formatIsoNative(date) {
	  return date.toISOString();
	}

	var formatIso = Date.prototype.toISOString
	    ? formatIsoNative
	    : utcFormat(isoSpecifier);

	function parseIsoNative(string) {
	  var date = new Date(string);
	  return isNaN(date) ? null : date;
	}

	var parseIso = +new Date("2000-01-01T00:00:00.000Z")
	    ? parseIsoNative
	    : utcParse(isoSpecifier);

	function sequential(interpolator) {
	  var x0 = 0,
	      x1 = 1,
	      clamp = false;

	  function scale(x) {
	    var t = (x - x0) / (x1 - x0);
	    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = !!_, scale) : clamp;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  scale.copy = function() {
	    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
	  };

	  return linearish(scale);
	}

	function colors(specifier) {
	  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
	  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
	  return colors;
	}

	colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

	colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

	colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

	colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

	colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

	colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

	colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

	colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

	colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

	function ramp(scheme) {
	  return rgbBasis(scheme[scheme.length - 1]);
	}

	var scheme = new Array(3).concat(
	  "d8b365f5f5f55ab4ac",
	  "a6611adfc27d80cdc1018571",
	  "a6611adfc27df5f5f580cdc1018571",
	  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
	  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
	  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
	  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
	  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
	  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
	).map(colors);

	ramp(scheme);

	var scheme$1 = new Array(3).concat(
	  "af8dc3f7f7f77fbf7b",
	  "7b3294c2a5cfa6dba0008837",
	  "7b3294c2a5cff7f7f7a6dba0008837",
	  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
	  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
	  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
	  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
	  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
	  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
	).map(colors);

	ramp(scheme$1);

	var scheme$2 = new Array(3).concat(
	  "e9a3c9f7f7f7a1d76a",
	  "d01c8bf1b6dab8e1864dac26",
	  "d01c8bf1b6daf7f7f7b8e1864dac26",
	  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
	  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
	  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
	  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
	  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
	  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
	).map(colors);

	ramp(scheme$2);

	var scheme$3 = new Array(3).concat(
	  "998ec3f7f7f7f1a340",
	  "5e3c99b2abd2fdb863e66101",
	  "5e3c99b2abd2f7f7f7fdb863e66101",
	  "542788998ec3d8daebfee0b6f1a340b35806",
	  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
	  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
	  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
	  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
	  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
	).map(colors);

	ramp(scheme$3);

	var scheme$4 = new Array(3).concat(
	  "ef8a62f7f7f767a9cf",
	  "ca0020f4a58292c5de0571b0",
	  "ca0020f4a582f7f7f792c5de0571b0",
	  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
	  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
	  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
	  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
	  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
	  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
	).map(colors);

	ramp(scheme$4);

	var scheme$5 = new Array(3).concat(
	  "ef8a62ffffff999999",
	  "ca0020f4a582bababa404040",
	  "ca0020f4a582ffffffbababa404040",
	  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
	  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
	  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
	  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
	  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
	  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
	).map(colors);

	ramp(scheme$5);

	var scheme$6 = new Array(3).concat(
	  "fc8d59ffffbf91bfdb",
	  "d7191cfdae61abd9e92c7bb6",
	  "d7191cfdae61ffffbfabd9e92c7bb6",
	  "d73027fc8d59fee090e0f3f891bfdb4575b4",
	  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
	  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
	  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
	  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
	  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
	).map(colors);

	ramp(scheme$6);

	var scheme$7 = new Array(3).concat(
	  "fc8d59ffffbf91cf60",
	  "d7191cfdae61a6d96a1a9641",
	  "d7191cfdae61ffffbfa6d96a1a9641",
	  "d73027fc8d59fee08bd9ef8b91cf601a9850",
	  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
	  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
	  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
	  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
	  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
	).map(colors);

	ramp(scheme$7);

	var scheme$8 = new Array(3).concat(
	  "fc8d59ffffbf99d594",
	  "d7191cfdae61abdda42b83ba",
	  "d7191cfdae61ffffbfabdda42b83ba",
	  "d53e4ffc8d59fee08be6f59899d5943288bd",
	  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
	  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
	  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
	  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
	  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
	).map(colors);

	ramp(scheme$8);

	var scheme$9 = new Array(3).concat(
	  "e5f5f999d8c92ca25f",
	  "edf8fbb2e2e266c2a4238b45",
	  "edf8fbb2e2e266c2a42ca25f006d2c",
	  "edf8fbccece699d8c966c2a42ca25f006d2c",
	  "edf8fbccece699d8c966c2a441ae76238b45005824",
	  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
	  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
	).map(colors);

	ramp(scheme$9);

	var scheme$a = new Array(3).concat(
	  "e0ecf49ebcda8856a7",
	  "edf8fbb3cde38c96c688419d",
	  "edf8fbb3cde38c96c68856a7810f7c",
	  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
	  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
	  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
	  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
	).map(colors);

	ramp(scheme$a);

	var scheme$b = new Array(3).concat(
	  "e0f3dba8ddb543a2ca",
	  "f0f9e8bae4bc7bccc42b8cbe",
	  "f0f9e8bae4bc7bccc443a2ca0868ac",
	  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
	  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
	  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
	  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
	).map(colors);

	var GnBu = ramp(scheme$b);

	var scheme$c = new Array(3).concat(
	  "fee8c8fdbb84e34a33",
	  "fef0d9fdcc8afc8d59d7301f",
	  "fef0d9fdcc8afc8d59e34a33b30000",
	  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
	  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
	  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
	  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
	).map(colors);

	ramp(scheme$c);

	var scheme$d = new Array(3).concat(
	  "ece2f0a6bddb1c9099",
	  "f6eff7bdc9e167a9cf02818a",
	  "f6eff7bdc9e167a9cf1c9099016c59",
	  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
	  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
	  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
	  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
	).map(colors);

	ramp(scheme$d);

	var scheme$e = new Array(3).concat(
	  "ece7f2a6bddb2b8cbe",
	  "f1eef6bdc9e174a9cf0570b0",
	  "f1eef6bdc9e174a9cf2b8cbe045a8d",
	  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
	  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
	  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
	  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
	).map(colors);

	ramp(scheme$e);

	var scheme$f = new Array(3).concat(
	  "e7e1efc994c7dd1c77",
	  "f1eef6d7b5d8df65b0ce1256",
	  "f1eef6d7b5d8df65b0dd1c77980043",
	  "f1eef6d4b9dac994c7df65b0dd1c77980043",
	  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
	  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
	  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
	).map(colors);

	ramp(scheme$f);

	var scheme$g = new Array(3).concat(
	  "fde0ddfa9fb5c51b8a",
	  "feebe2fbb4b9f768a1ae017e",
	  "feebe2fbb4b9f768a1c51b8a7a0177",
	  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
	  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
	  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
	  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
	).map(colors);

	var RdPu = ramp(scheme$g);

	var scheme$h = new Array(3).concat(
	  "edf8b17fcdbb2c7fb8",
	  "ffffcca1dab441b6c4225ea8",
	  "ffffcca1dab441b6c42c7fb8253494",
	  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
	  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
	  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
	  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
	).map(colors);

	ramp(scheme$h);

	var scheme$i = new Array(3).concat(
	  "f7fcb9addd8e31a354",
	  "ffffccc2e69978c679238443",
	  "ffffccc2e69978c67931a354006837",
	  "ffffccd9f0a3addd8e78c67931a354006837",
	  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
	  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
	  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
	).map(colors);

	ramp(scheme$i);

	var scheme$j = new Array(3).concat(
	  "fff7bcfec44fd95f0e",
	  "ffffd4fed98efe9929cc4c02",
	  "ffffd4fed98efe9929d95f0e993404",
	  "ffffd4fee391fec44ffe9929d95f0e993404",
	  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
	  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
	  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
	).map(colors);

	ramp(scheme$j);

	var scheme$k = new Array(3).concat(
	  "ffeda0feb24cf03b20",
	  "ffffb2fecc5cfd8d3ce31a1c",
	  "ffffb2fecc5cfd8d3cf03b20bd0026",
	  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
	  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
	  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
	  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
	).map(colors);

	ramp(scheme$k);

	var scheme$l = new Array(3).concat(
	  "deebf79ecae13182bd",
	  "eff3ffbdd7e76baed62171b5",
	  "eff3ffbdd7e76baed63182bd08519c",
	  "eff3ffc6dbef9ecae16baed63182bd08519c",
	  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
	  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
	  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
	).map(colors);

	ramp(scheme$l);

	var scheme$m = new Array(3).concat(
	  "e5f5e0a1d99b31a354",
	  "edf8e9bae4b374c476238b45",
	  "edf8e9bae4b374c47631a354006d2c",
	  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
	  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
	  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
	  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
	).map(colors);

	ramp(scheme$m);

	var scheme$n = new Array(3).concat(
	  "f0f0f0bdbdbd636363",
	  "f7f7f7cccccc969696525252",
	  "f7f7f7cccccc969696636363252525",
	  "f7f7f7d9d9d9bdbdbd969696636363252525",
	  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
	  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
	  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
	).map(colors);

	var Greys = ramp(scheme$n);

	var scheme$o = new Array(3).concat(
	  "efedf5bcbddc756bb1",
	  "f2f0f7cbc9e29e9ac86a51a3",
	  "f2f0f7cbc9e29e9ac8756bb154278f",
	  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
	  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
	  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
	  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
	).map(colors);

	ramp(scheme$o);

	var scheme$p = new Array(3).concat(
	  "fee0d2fc9272de2d26",
	  "fee5d9fcae91fb6a4acb181d",
	  "fee5d9fcae91fb6a4ade2d26a50f15",
	  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
	  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
	  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
	  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
	).map(colors);

	ramp(scheme$p);

	var scheme$q = new Array(3).concat(
	  "fee6cefdae6be6550d",
	  "feeddefdbe85fd8d3cd94701",
	  "feeddefdbe85fd8d3ce6550da63603",
	  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
	  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
	  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
	  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
	).map(colors);

	ramp(scheme$q);

	cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

	var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

	var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

	var c = cubehelix();

	var c$1 = rgb(),
	    pi_1_3 = Math.PI / 3,
	    pi_2_3 = Math.PI * 2 / 3;

	function ramp$1(range) {
	  var n = range.length;
	  return function(t) {
	    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
	  };
	}

	ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

	var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

	var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

	var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

	function constant$b(x) {
	  return function constant() {
	    return x;
	  };
	}

	var pi$4 = Math.PI;

	function Linear(context) {
	  this._context = context;
	}

	Linear.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; // proceed
	      default: this._context.lineTo(x, y); break;
	    }
	  }
	};

	function curveLinear(context) {
	  return new Linear(context);
	}

	function x$3(p) {
	  return p[0];
	}

	function y$3(p) {
	  return p[1];
	}

	function line() {
	  var x$$1 = x$3,
	      y$$1 = y$3,
	      defined = constant$b(true),
	      context = null,
	      curve = curveLinear,
	      output = null;

	  function line(data) {
	    var i,
	        n = data.length,
	        d,
	        defined0 = false,
	        buffer;

	    if (context == null) output = curve(buffer = path());

	    for (i = 0; i <= n; ++i) {
	      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
	        if (defined0 = !defined0) output.lineStart();
	        else output.lineEnd();
	      }
	      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
	    }

	    if (buffer) return output = null, buffer + "" || null;
	  }

	  line.x = function(_) {
	    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$b(+_), line) : x$$1;
	  };

	  line.y = function(_) {
	    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$b(+_), line) : y$$1;
	  };

	  line.defined = function(_) {
	    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$b(!!_), line) : defined;
	  };

	  line.curve = function(_) {
	    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
	  };

	  line.context = function(_) {
	    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
	  };

	  return line;
	}

	function area$3() {
	  var x0 = x$3,
	      x1 = null,
	      y0 = constant$b(0),
	      y1 = y$3,
	      defined = constant$b(true),
	      context = null,
	      curve = curveLinear,
	      output = null;

	  function area(data) {
	    var i,
	        j,
	        k,
	        n = data.length,
	        d,
	        defined0 = false,
	        buffer,
	        x0z = new Array(n),
	        y0z = new Array(n);

	    if (context == null) output = curve(buffer = path());

	    for (i = 0; i <= n; ++i) {
	      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
	        if (defined0 = !defined0) {
	          j = i;
	          output.areaStart();
	          output.lineStart();
	        } else {
	          output.lineEnd();
	          output.lineStart();
	          for (k = i - 1; k >= j; --k) {
	            output.point(x0z[k], y0z[k]);
	          }
	          output.lineEnd();
	          output.areaEnd();
	        }
	      }
	      if (defined0) {
	        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
	        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
	      }
	    }

	    if (buffer) return output = null, buffer + "" || null;
	  }

	  function arealine() {
	    return line().defined(defined).curve(curve).context(context);
	  }

	  area.x = function(_) {
	    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$b(+_), x1 = null, area) : x0;
	  };

	  area.x0 = function(_) {
	    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$b(+_), area) : x0;
	  };

	  area.x1 = function(_) {
	    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$b(+_), area) : x1;
	  };

	  area.y = function(_) {
	    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$b(+_), y1 = null, area) : y0;
	  };

	  area.y0 = function(_) {
	    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$b(+_), area) : y0;
	  };

	  area.y1 = function(_) {
	    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$b(+_), area) : y1;
	  };

	  area.lineX0 =
	  area.lineY0 = function() {
	    return arealine().x(x0).y(y0);
	  };

	  area.lineY1 = function() {
	    return arealine().x(x0).y(y1);
	  };

	  area.lineX1 = function() {
	    return arealine().x(x1).y(y0);
	  };

	  area.defined = function(_) {
	    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$b(!!_), area) : defined;
	  };

	  area.curve = function(_) {
	    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
	  };

	  area.context = function(_) {
	    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
	  };

	  return area;
	}

	function sign$1(x) {
	  return x < 0 ? -1 : 1;
	}

	// Calculate the slopes of the tangents (Hermite-type interpolation) based on
	// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
	// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
	// NOV(II), P. 443, 1990.
	function slope3(that, x2, y2) {
	  var h0 = that._x1 - that._x0,
	      h1 = x2 - that._x1,
	      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
	      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
	      p = (s0 * h1 + s1 * h0) / (h0 + h1);
	  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
	}

	// Calculate a one-sided slope.
	function slope2(that, t) {
	  var h = that._x1 - that._x0;
	  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
	}

	// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
	// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
	// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
	function point$5(that, t0, t1) {
	  var x0 = that._x0,
	      y0 = that._y0,
	      x1 = that._x1,
	      y1 = that._y1,
	      dx = (x1 - x0) / 3;
	  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
	}

	function MonotoneX(context) {
	  this._context = context;
	}

	MonotoneX.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 =
	    this._t0 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 2: this._context.lineTo(this._x1, this._y1); break;
	      case 3: point$5(this, this._t0, slope2(this, this._t0)); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    var t1 = NaN;

	    x = +x, y = +y;
	    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; point$5(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
	      default: point$5(this, this._t0, t1 = slope3(this, x, y)); break;
	    }

	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	    this._t0 = t1;
	  }
	};

	function MonotoneY(context) {
	  this._context = new ReflectContext(context);
	}

	(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
	  MonotoneX.prototype.point.call(this, y, x);
	};

	function ReflectContext(context) {
	  this._context = context;
	}

	ReflectContext.prototype = {
	  moveTo: function(x, y) { this._context.moveTo(y, x); },
	  closePath: function() { this._context.closePath(); },
	  lineTo: function(x, y) { this._context.lineTo(y, x); },
	  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
	};

	function Step(context, t) {
	  this._context = context;
	  this._t = t;
	}

	Step.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x = this._y = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; // proceed
	      default: {
	        if (this._t <= 0) {
	          this._context.lineTo(this._x, y);
	          this._context.lineTo(x, y);
	        } else {
	          var x1 = this._x * (1 - this._t) + x * this._t;
	          this._context.lineTo(x1, this._y);
	          this._context.lineTo(x1, y);
	        }
	        break;
	      }
	    }
	    this._x = x, this._y = y;
	  }
	};

	function stepBefore(context) {
	  return new Step(context, 0);
	}

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

	var Context = function () {
	  function Context(width, height, _ref, _ref2) {
	    var _ref4 = slicedToArray(_ref, 2),
	        xmin = _ref4[0],
	        xmax = _ref4[1];

	    var _ref3 = slicedToArray(_ref2, 2),
	        ymin = _ref3[0],
	        ymax = _ref3[1];

	    classCallCheck(this, Context);

	    this.width = width;
	    this.height = height;
	    this.xmin = xmin;
	    this.xmax = xmax;
	    this.xToViewport = linear$3().domain([xmin, xmax]).range([0, width]);
	    this.yToViewport = linear$3().domain([ymin, ymax]).range([height, 0]);
	  }

	  createClass(Context, [{
	    key: 'x',
	    value: function x(u) {
	      return this.xToViewport.invert(u);
	    }
	  }, {
	    key: 'y',
	    value: function y(v) {
	      return this.yToViewport.invert(v);
	    }
	  }, {
	    key: 'u',
	    value: function u(x) {
	      return this.xToViewport(x);
	    }
	  }, {
	    key: 'v',
	    value: function v(y) {
	      return this.yToViewport(y);
	    }
	  }, {
	    key: 'xDomain',
	    value: function xDomain() {
	      return this.xToViewport.domain();
	    }
	  }, {
	    key: 'yDomain',
	    value: function yDomain() {
	      return this.yToViewport.domain();
	    }
	  }]);
	  return Context;
	}();

	/**
	 * Computes the maximum of the given values
	 * @param {Array<number>} input
	 * @return {number}
	 */
	function max$3(input) {
	    if (!Array.isArray(input)) {
	        throw new Error('input must be an array');
	    }

	    if (input.length === 0) {
	        throw new Error('input must not be empty');
	    }

	    var max = input[0];
	    for (var i = 1; i < input.length; i++) {
	        if (input[i] > max) max = input[i];
	    }
	    return max;
	}

	/**
	 * Computes the minimum of the given values
	 * @param {Array<number>} input
	 * @return {number}
	 */
	function min$2(input) {
	    if (!Array.isArray(input)) {
	        throw new Error('input must be an array');
	    }

	    if (input.length === 0) {
	        throw new Error('input must not be empty');
	    }

	    var min = input[0];
	    for (var i = 1; i < input.length; i++) {
	        if (input[i] < min) min = input[i];
	    }
	    return min;
	}

	function rescale(input, options = {}) {
	    if (!Array.isArray(input)) {
	        throw new TypeError('input must be an array');
	    } else if (input.length === 0) {
	        throw new TypeError('input must not be empty');
	    }

	    let output;
	    if (options.output !== undefined) {
	        if (!Array.isArray(options.output)) {
	            throw new TypeError('output option must be an array if specified');
	        }
	        output = options.output;
	    } else {
	        output = new Array(input.length);
	    }

	    const currentMin = min$2(input);
	    const currentMax = max$3(input);

	    if (currentMin === currentMax) {
	        throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
	    }

	    const {
	        min: minValue = options.autoMinMax ? currentMin : 0,
	        max: maxValue = options.autoMinMax ? currentMax : 1
	    } = options;

	    if (minValue >= maxValue) {
	        throw new RangeError('min option must be smaller than max option');
	    }

	    const factor = (maxValue - minValue) / (currentMax - currentMin);
	    for (var i = 0; i < input.length; i++) {
	        output[i] = (input[i] - currentMin) * factor + minValue;
	    }

	    return output;
	}

	/**
	 * @class LuDecomposition
	 * @link https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs
	 * @param {Matrix} matrix
	 */
	class LuDecomposition$$1 {
	  constructor(matrix) {
	    matrix = WrapperMatrix2D.checkMatrix(matrix);

	    var lu = matrix.clone();
	    var rows = lu.rows;
	    var columns = lu.columns;
	    var pivotVector = new Array(rows);
	    var pivotSign = 1;
	    var i, j, k, p, s, t, v;
	    var LUcolj, kmax;

	    for (i = 0; i < rows; i++) {
	      pivotVector[i] = i;
	    }

	    LUcolj = new Array(rows);

	    for (j = 0; j < columns; j++) {
	      for (i = 0; i < rows; i++) {
	        LUcolj[i] = lu.get(i, j);
	      }

	      for (i = 0; i < rows; i++) {
	        kmax = Math.min(i, j);
	        s = 0;
	        for (k = 0; k < kmax; k++) {
	          s += lu.get(i, k) * LUcolj[k];
	        }
	        LUcolj[i] -= s;
	        lu.set(i, j, LUcolj[i]);
	      }

	      p = j;
	      for (i = j + 1; i < rows; i++) {
	        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
	          p = i;
	        }
	      }

	      if (p !== j) {
	        for (k = 0; k < columns; k++) {
	          t = lu.get(p, k);
	          lu.set(p, k, lu.get(j, k));
	          lu.set(j, k, t);
	        }

	        v = pivotVector[p];
	        pivotVector[p] = pivotVector[j];
	        pivotVector[j] = v;

	        pivotSign = -pivotSign;
	      }

	      if (j < rows && lu.get(j, j) !== 0) {
	        for (i = j + 1; i < rows; i++) {
	          lu.set(i, j, lu.get(i, j) / lu.get(j, j));
	        }
	      }
	    }

	    this.LU = lu;
	    this.pivotVector = pivotVector;
	    this.pivotSign = pivotSign;
	  }

	  /**
	   *
	   * @return {boolean}
	   */
	  isSingular() {
	    var data = this.LU;
	    var col = data.columns;
	    for (var j = 0; j < col; j++) {
	      if (data[j][j] === 0) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   *
	   * @param {Matrix} value
	   * @return {Matrix}
	   */
	  solve(value) {
	    value = Matrix.checkMatrix(value);

	    var lu = this.LU;
	    var rows = lu.rows;

	    if (rows !== value.rows) {
	      throw new Error('Invalid matrix dimensions');
	    }
	    if (this.isSingular()) {
	      throw new Error('LU matrix is singular');
	    }

	    var count = value.columns;
	    var X = value.subMatrixRow(this.pivotVector, 0, count - 1);
	    var columns = lu.columns;
	    var i, j, k;

	    for (k = 0; k < columns; k++) {
	      for (i = k + 1; i < columns; i++) {
	        for (j = 0; j < count; j++) {
	          X[i][j] -= X[k][j] * lu[i][k];
	        }
	      }
	    }
	    for (k = columns - 1; k >= 0; k--) {
	      for (j = 0; j < count; j++) {
	        X[k][j] /= lu[k][k];
	      }
	      for (i = 0; i < k; i++) {
	        for (j = 0; j < count; j++) {
	          X[i][j] -= X[k][j] * lu[i][k];
	        }
	      }
	    }
	    return X;
	  }

	  /**
	   *
	   * @return {number}
	   */
	  get determinant() {
	    var data = this.LU;
	    if (!data.isSquare()) {
	      throw new Error('Matrix must be square');
	    }
	    var determinant = this.pivotSign;
	    var col = data.columns;
	    for (var j = 0; j < col; j++) {
	      determinant *= data[j][j];
	    }
	    return determinant;
	  }

	  /**
	   *
	   * @return {Matrix}
	   */
	  get lowerTriangularMatrix() {
	    var data = this.LU;
	    var rows = data.rows;
	    var columns = data.columns;
	    var X = new Matrix(rows, columns);
	    for (var i = 0; i < rows; i++) {
	      for (var j = 0; j < columns; j++) {
	        if (i > j) {
	          X[i][j] = data[i][j];
	        } else if (i === j) {
	          X[i][j] = 1;
	        } else {
	          X[i][j] = 0;
	        }
	      }
	    }
	    return X;
	  }

	  /**
	   *
	   * @return {Matrix}
	   */
	  get upperTriangularMatrix() {
	    var data = this.LU;
	    var rows = data.rows;
	    var columns = data.columns;
	    var X = new Matrix(rows, columns);
	    for (var i = 0; i < rows; i++) {
	      for (var j = 0; j < columns; j++) {
	        if (i <= j) {
	          X[i][j] = data[i][j];
	        } else {
	          X[i][j] = 0;
	        }
	      }
	    }
	    return X;
	  }

	  /**
	   *
	   * @return {Array<number>}
	   */
	  get pivotPermutationVector() {
	    return this.pivotVector.slice();
	  }
	}

	function hypotenuse(a, b) {
	  var r = 0;
	  if (Math.abs(a) > Math.abs(b)) {
	    r = b / a;
	    return Math.abs(a) * Math.sqrt(1 + r * r);
	  }
	  if (b !== 0) {
	    r = a / b;
	    return Math.abs(b) * Math.sqrt(1 + r * r);
	  }
	  return 0;
	}

	function getFilled2DArray(rows, columns, value) {
	  var array = new Array(rows);
	  for (var i = 0; i < rows; i++) {
	    array[i] = new Array(columns);
	    for (var j = 0; j < columns; j++) {
	      array[i][j] = value;
	    }
	  }
	  return array;
	}

	/**
	 * @class SingularValueDecomposition
	 * @see https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs
	 * @param {Matrix} value
	 * @param {object} [options]
	 * @param {boolean} [options.computeLeftSingularVectors=true]
	 * @param {boolean} [options.computeRightSingularVectors=true]
	 * @param {boolean} [options.autoTranspose=false]
	 */
	class SingularValueDecomposition$$1 {
	  constructor(value, options = {}) {
	    value = WrapperMatrix2D.checkMatrix(value);

	    var m = value.rows;
	    var n = value.columns;

	    const {
	      computeLeftSingularVectors = true,
	      computeRightSingularVectors = true,
	      autoTranspose = false
	    } = options;

	    var wantu = Boolean(computeLeftSingularVectors);
	    var wantv = Boolean(computeRightSingularVectors);

	    var swapped = false;
	    var a;
	    if (m < n) {
	      if (!autoTranspose) {
	        a = value.clone();
	        // eslint-disable-next-line no-console
	        console.warn(
	          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose'
	        );
	      } else {
	        a = value.transpose();
	        m = a.rows;
	        n = a.columns;
	        swapped = true;
	        var aux = wantu;
	        wantu = wantv;
	        wantv = aux;
	      }
	    } else {
	      a = value.clone();
	    }

	    var nu = Math.min(m, n);
	    var ni = Math.min(m + 1, n);
	    var s = new Array(ni);
	    var U = getFilled2DArray(m, nu, 0);
	    var V = getFilled2DArray(n, n, 0);

	    var e = new Array(n);
	    var work = new Array(m);

	    var si = new Array(ni);
	    for (let i = 0; i < ni; i++) si[i] = i;

	    var nct = Math.min(m - 1, n);
	    var nrt = Math.max(0, Math.min(n - 2, m));
	    var mrc = Math.max(nct, nrt);

	    for (let k = 0; k < mrc; k++) {
	      if (k < nct) {
	        s[k] = 0;
	        for (let i = k; i < m; i++) {
	          s[k] = hypotenuse(s[k], a[i][k]);
	        }
	        if (s[k] !== 0) {
	          if (a[k][k] < 0) {
	            s[k] = -s[k];
	          }
	          for (let i = k; i < m; i++) {
	            a[i][k] /= s[k];
	          }
	          a[k][k] += 1;
	        }
	        s[k] = -s[k];
	      }

	      for (let j = k + 1; j < n; j++) {
	        if (k < nct && s[k] !== 0) {
	          let t = 0;
	          for (let i = k; i < m; i++) {
	            t += a[i][k] * a[i][j];
	          }
	          t = -t / a[k][k];
	          for (let i = k; i < m; i++) {
	            a[i][j] += t * a[i][k];
	          }
	        }
	        e[j] = a[k][j];
	      }

	      if (wantu && k < nct) {
	        for (let i = k; i < m; i++) {
	          U[i][k] = a[i][k];
	        }
	      }

	      if (k < nrt) {
	        e[k] = 0;
	        for (let i = k + 1; i < n; i++) {
	          e[k] = hypotenuse(e[k], e[i]);
	        }
	        if (e[k] !== 0) {
	          if (e[k + 1] < 0) {
	            e[k] = 0 - e[k];
	          }
	          for (let i = k + 1; i < n; i++) {
	            e[i] /= e[k];
	          }
	          e[k + 1] += 1;
	        }
	        e[k] = -e[k];
	        if (k + 1 < m && e[k] !== 0) {
	          for (let i = k + 1; i < m; i++) {
	            work[i] = 0;
	          }
	          for (let i = k + 1; i < m; i++) {
	            for (let j = k + 1; j < n; j++) {
	              work[i] += e[j] * a[i][j];
	            }
	          }
	          for (let j = k + 1; j < n; j++) {
	            let t = -e[j] / e[k + 1];
	            for (let i = k + 1; i < m; i++) {
	              a[i][j] += t * work[i];
	            }
	          }
	        }
	        if (wantv) {
	          for (let i = k + 1; i < n; i++) {
	            V[i][k] = e[i];
	          }
	        }
	      }
	    }

	    let p = Math.min(n, m + 1);
	    if (nct < n) {
	      s[nct] = a[nct][nct];
	    }
	    if (m < p) {
	      s[p - 1] = 0;
	    }
	    if (nrt + 1 < p) {
	      e[nrt] = a[nrt][p - 1];
	    }
	    e[p - 1] = 0;

	    if (wantu) {
	      for (let j = nct; j < nu; j++) {
	        for (let i = 0; i < m; i++) {
	          U[i][j] = 0;
	        }
	        U[j][j] = 1;
	      }
	      for (let k = nct - 1; k >= 0; k--) {
	        if (s[k] !== 0) {
	          for (let j = k + 1; j < nu; j++) {
	            let t = 0;
	            for (let i = k; i < m; i++) {
	              t += U[i][k] * U[i][j];
	            }
	            t = -t / U[k][k];
	            for (let i = k; i < m; i++) {
	              U[i][j] += t * U[i][k];
	            }
	          }
	          for (let i = k; i < m; i++) {
	            U[i][k] = -U[i][k];
	          }
	          U[k][k] = 1 + U[k][k];
	          for (let i = 0; i < k - 1; i++) {
	            U[i][k] = 0;
	          }
	        } else {
	          for (let i = 0; i < m; i++) {
	            U[i][k] = 0;
	          }
	          U[k][k] = 1;
	        }
	      }
	    }

	    if (wantv) {
	      for (let k = n - 1; k >= 0; k--) {
	        if (k < nrt && e[k] !== 0) {
	          for (let j = k + 1; j < n; j++) {
	            let t = 0;
	            for (let i = k + 1; i < n; i++) {
	              t += V[i][k] * V[i][j];
	            }
	            t = -t / V[k + 1][k];
	            for (let i = k + 1; i < n; i++) {
	              V[i][j] += t * V[i][k];
	            }
	          }
	        }
	        for (let i = 0; i < n; i++) {
	          V[i][k] = 0;
	        }
	        V[k][k] = 1;
	      }
	    }

	    var pp = p - 1;
	    var eps = Number.EPSILON;
	    while (p > 0) {
	      let k, kase;
	      for (k = p - 2; k >= -1; k--) {
	        if (k === -1) {
	          break;
	        }
	        const alpha =
	          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
	        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
	          e[k] = 0;
	          break;
	        }
	      }
	      if (k === p - 2) {
	        kase = 4;
	      } else {
	        let ks;
	        for (ks = p - 1; ks >= k; ks--) {
	          if (ks === k) {
	            break;
	          }
	          let t =
	            (ks !== p ? Math.abs(e[ks]) : 0) +
	            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
	          if (Math.abs(s[ks]) <= eps * t) {
	            s[ks] = 0;
	            break;
	          }
	        }
	        if (ks === k) {
	          kase = 3;
	        } else if (ks === p - 1) {
	          kase = 1;
	        } else {
	          kase = 2;
	          k = ks;
	        }
	      }

	      k++;

	      switch (kase) {
	        case 1: {
	          let f = e[p - 2];
	          e[p - 2] = 0;
	          for (let j = p - 2; j >= k; j--) {
	            let t = hypotenuse(s[j], f);
	            let cs = s[j] / t;
	            let sn = f / t;
	            s[j] = t;
	            if (j !== k) {
	              f = -sn * e[j - 1];
	              e[j - 1] = cs * e[j - 1];
	            }
	            if (wantv) {
	              for (let i = 0; i < n; i++) {
	                t = cs * V[i][j] + sn * V[i][p - 1];
	                V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
	                V[i][j] = t;
	              }
	            }
	          }
	          break;
	        }
	        case 2: {
	          let f = e[k - 1];
	          e[k - 1] = 0;
	          for (let j = k; j < p; j++) {
	            let t = hypotenuse(s[j], f);
	            let cs = s[j] / t;
	            let sn = f / t;
	            s[j] = t;
	            f = -sn * e[j];
	            e[j] = cs * e[j];
	            if (wantu) {
	              for (let i = 0; i < m; i++) {
	                t = cs * U[i][j] + sn * U[i][k - 1];
	                U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
	                U[i][j] = t;
	              }
	            }
	          }
	          break;
	        }
	        case 3: {
	          const scale = Math.max(
	            Math.abs(s[p - 1]),
	            Math.abs(s[p - 2]),
	            Math.abs(e[p - 2]),
	            Math.abs(s[k]),
	            Math.abs(e[k])
	          );
	          const sp = s[p - 1] / scale;
	          const spm1 = s[p - 2] / scale;
	          const epm1 = e[p - 2] / scale;
	          const sk = s[k] / scale;
	          const ek = e[k] / scale;
	          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
	          const c = sp * epm1 * (sp * epm1);
	          let shift = 0;
	          if (b !== 0 || c !== 0) {
	            if (b < 0) {
	              shift = 0 - Math.sqrt(b * b + c);
	            } else {
	              shift = Math.sqrt(b * b + c);
	            }
	            shift = c / (b + shift);
	          }
	          let f = (sk + sp) * (sk - sp) + shift;
	          let g = sk * ek;
	          for (let j = k; j < p - 1; j++) {
	            let t = hypotenuse(f, g);
	            if (t === 0) t = Number.MIN_VALUE;
	            let cs = f / t;
	            let sn = g / t;
	            if (j !== k) {
	              e[j - 1] = t;
	            }
	            f = cs * s[j] + sn * e[j];
	            e[j] = cs * e[j] - sn * s[j];
	            g = sn * s[j + 1];
	            s[j + 1] = cs * s[j + 1];
	            if (wantv) {
	              for (let i = 0; i < n; i++) {
	                t = cs * V[i][j] + sn * V[i][j + 1];
	                V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
	                V[i][j] = t;
	              }
	            }
	            t = hypotenuse(f, g);
	            if (t === 0) t = Number.MIN_VALUE;
	            cs = f / t;
	            sn = g / t;
	            s[j] = t;
	            f = cs * e[j] + sn * s[j + 1];
	            s[j + 1] = -sn * e[j] + cs * s[j + 1];
	            g = sn * e[j + 1];
	            e[j + 1] = cs * e[j + 1];
	            if (wantu && j < m - 1) {
	              for (let i = 0; i < m; i++) {
	                t = cs * U[i][j] + sn * U[i][j + 1];
	                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
	                U[i][j] = t;
	              }
	            }
	          }
	          e[p - 2] = f;
	          break;
	        }
	        case 4: {
	          if (s[k] <= 0) {
	            s[k] = s[k] < 0 ? -s[k] : 0;
	            if (wantv) {
	              for (let i = 0; i <= pp; i++) {
	                V[i][k] = -V[i][k];
	              }
	            }
	          }
	          while (k < pp) {
	            if (s[k] >= s[k + 1]) {
	              break;
	            }
	            let t = s[k];
	            s[k] = s[k + 1];
	            s[k + 1] = t;
	            if (wantv && k < n - 1) {
	              for (let i = 0; i < n; i++) {
	                t = V[i][k + 1];
	                V[i][k + 1] = V[i][k];
	                V[i][k] = t;
	              }
	            }
	            if (wantu && k < m - 1) {
	              for (let i = 0; i < m; i++) {
	                t = U[i][k + 1];
	                U[i][k + 1] = U[i][k];
	                U[i][k] = t;
	              }
	            }
	            k++;
	          }
	          p--;
	          break;
	        }
	        // no default
	      }
	    }

	    if (swapped) {
	      var tmp = V;
	      V = U;
	      U = tmp;
	    }

	    this.m = m;
	    this.n = n;
	    this.s = s;
	    this.U = U;
	    this.V = V;
	  }

	  /**
	   * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).
	   * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
	   * var svd = SingularValueDecomposition(A);
	   * var x = svd.solve(b);
	   * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
	   * @return {Matrix} - The vector x
	   */
	  solve(value) {
	    var Y = value;
	    var e = this.threshold;
	    var scols = this.s.length;
	    var Ls = Matrix.zeros(scols, scols);

	    for (let i = 0; i < scols; i++) {
	      if (Math.abs(this.s[i]) <= e) {
	        Ls[i][i] = 0;
	      } else {
	        Ls[i][i] = 1 / this.s[i];
	      }
	    }

	    var U = this.U;
	    var V = this.rightSingularVectors;

	    var VL = V.mmul(Ls);
	    var vrows = V.rows;
	    var urows = U.length;
	    var VLU = Matrix.zeros(vrows, urows);

	    for (let i = 0; i < vrows; i++) {
	      for (let j = 0; j < urows; j++) {
	        let sum = 0;
	        for (let k = 0; k < scols; k++) {
	          sum += VL[i][k] * U[j][k];
	        }
	        VLU[i][j] = sum;
	      }
	    }

	    return VLU.mmul(Y);
	  }

	  /**
	   *
	   * @param {Array<number>} value
	   * @return {Matrix}
	   */
	  solveForDiagonal(value) {
	    return this.solve(Matrix.diag(value));
	  }

	  /**
	   * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :
	   * var svd = SingularValueDecomposition(A);
	   * var inverseA = svd.inverse();
	   * @return {Matrix} - The approximation of the inverse of the matrix
	   */
	  inverse() {
	    var V = this.V;
	    var e = this.threshold;
	    var vrows = V.length;
	    var vcols = V[0].length;
	    var X = new Matrix(vrows, this.s.length);

	    for (let i = 0; i < vrows; i++) {
	      for (let j = 0; j < vcols; j++) {
	        if (Math.abs(this.s[j]) > e) {
	          X[i][j] = V[i][j] / this.s[j];
	        } else {
	          X[i][j] = 0;
	        }
	      }
	    }

	    var U = this.U;

	    var urows = U.length;
	    var ucols = U[0].length;
	    var Y = new Matrix(vrows, urows);

	    for (let i = 0; i < vrows; i++) {
	      for (let j = 0; j < urows; j++) {
	        let sum = 0;
	        for (let k = 0; k < ucols; k++) {
	          sum += X[i][k] * U[j][k];
	        }
	        Y[i][j] = sum;
	      }
	    }

	    return Y;
	  }

	  /**
	   *
	   * @return {number}
	   */
	  get condition() {
	    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
	  }

	  /**
	   *
	   * @return {number}
	   */
	  get norm2() {
	    return this.s[0];
	  }

	  /**
	   *
	   * @return {number}
	   */
	  get rank() {
	    var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
	    var r = 0;
	    var s = this.s;
	    for (var i = 0, ii = s.length; i < ii; i++) {
	      if (s[i] > tol) {
	        r++;
	      }
	    }
	    return r;
	  }

	  /**
	   *
	   * @return {Array<number>}
	   */
	  get diagonal() {
	    return this.s;
	  }

	  /**
	   *
	   * @return {number}
	   */
	  get threshold() {
	    return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
	  }

	  /**
	   *
	   * @return {Matrix}
	   */
	  get leftSingularVectors() {
	    if (!Matrix.isMatrix(this.U)) {
	      this.U = new Matrix(this.U);
	    }
	    return this.U;
	  }

	  /**
	   *
	   * @return {Matrix}
	   */
	  get rightSingularVectors() {
	    if (!Matrix.isMatrix(this.V)) {
	      this.V = new Matrix(this.V);
	    }
	    return this.V;
	  }

	  /**
	   *
	   * @return {Matrix}
	   */
	  get diagonalMatrix() {
	    return Matrix.diag(this.s);
	  }
	}

	/**
	 * @private
	 * Check that a row index is not out of bounds
	 * @param {Matrix} matrix
	 * @param {number} index
	 * @param {boolean} [outer]
	 */
	function checkRowIndex(matrix, index, outer) {
	  var max = outer ? matrix.rows : matrix.rows - 1;
	  if (index < 0 || index > max) {
	    throw new RangeError('Row index out of range');
	  }
	}

	/**
	 * @private
	 * Check that a column index is not out of bounds
	 * @param {Matrix} matrix
	 * @param {number} index
	 * @param {boolean} [outer]
	 */
	function checkColumnIndex(matrix, index, outer) {
	  var max = outer ? matrix.columns : matrix.columns - 1;
	  if (index < 0 || index > max) {
	    throw new RangeError('Column index out of range');
	  }
	}

	/**
	 * @private
	 * Check that the provided vector is an array with the right length
	 * @param {Matrix} matrix
	 * @param {Array|Matrix} vector
	 * @return {Array}
	 * @throws {RangeError}
	 */
	function checkRowVector(matrix, vector) {
	  if (vector.to1DArray) {
	    vector = vector.to1DArray();
	  }
	  if (vector.length !== matrix.columns) {
	    throw new RangeError(
	      'vector size must be the same as the number of columns'
	    );
	  }
	  return vector;
	}

	/**
	 * @private
	 * Check that the provided vector is an array with the right length
	 * @param {Matrix} matrix
	 * @param {Array|Matrix} vector
	 * @return {Array}
	 * @throws {RangeError}
	 */
	function checkColumnVector(matrix, vector) {
	  if (vector.to1DArray) {
	    vector = vector.to1DArray();
	  }
	  if (vector.length !== matrix.rows) {
	    throw new RangeError('vector size must be the same as the number of rows');
	  }
	  return vector;
	}

	function checkIndices(matrix, rowIndices, columnIndices) {
	  return {
	    row: checkRowIndices(matrix, rowIndices),
	    column: checkColumnIndices(matrix, columnIndices)
	  };
	}

	function checkRowIndices(matrix, rowIndices) {
	  if (typeof rowIndices !== 'object') {
	    throw new TypeError('unexpected type for row indices');
	  }

	  var rowOut = rowIndices.some((r) => {
	    return r < 0 || r >= matrix.rows;
	  });

	  if (rowOut) {
	    throw new RangeError('row indices are out of range');
	  }

	  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

	  return rowIndices;
	}

	function checkColumnIndices(matrix, columnIndices) {
	  if (typeof columnIndices !== 'object') {
	    throw new TypeError('unexpected type for column indices');
	  }

	  var columnOut = columnIndices.some((c) => {
	    return c < 0 || c >= matrix.columns;
	  });

	  if (columnOut) {
	    throw new RangeError('column indices are out of range');
	  }
	  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

	  return columnIndices;
	}

	function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
	  if (arguments.length !== 5) {
	    throw new RangeError('expected 4 arguments');
	  }
	  checkNumber('startRow', startRow);
	  checkNumber('endRow', endRow);
	  checkNumber('startColumn', startColumn);
	  checkNumber('endColumn', endColumn);
	  if (
	    startRow > endRow ||
	    startColumn > endColumn ||
	    startRow < 0 ||
	    startRow >= matrix.rows ||
	    endRow < 0 ||
	    endRow >= matrix.rows ||
	    startColumn < 0 ||
	    startColumn >= matrix.columns ||
	    endColumn < 0 ||
	    endColumn >= matrix.columns
	  ) {
	    throw new RangeError('Submatrix indices are out of range');
	  }
	}

	function sumByRow(matrix) {
	  var sum = Matrix.zeros(matrix.rows, 1);
	  for (var i = 0; i < matrix.rows; ++i) {
	    for (var j = 0; j < matrix.columns; ++j) {
	      sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));
	    }
	  }
	  return sum;
	}

	function sumByColumn(matrix) {
	  var sum = Matrix.zeros(1, matrix.columns);
	  for (var i = 0; i < matrix.rows; ++i) {
	    for (var j = 0; j < matrix.columns; ++j) {
	      sum.set(0, j, sum.get(0, j) + matrix.get(i, j));
	    }
	  }
	  return sum;
	}

	function sumAll(matrix) {
	  var v = 0;
	  for (var i = 0; i < matrix.rows; i++) {
	    for (var j = 0; j < matrix.columns; j++) {
	      v += matrix.get(i, j);
	    }
	  }
	  return v;
	}

	function checkNumber(name, value) {
	  if (typeof value !== 'number') {
	    throw new TypeError(`${name} must be a number`);
	  }
	}

	class BaseView extends AbstractMatrix() {
	  constructor(matrix, rows, columns) {
	    super();
	    this.matrix = matrix;
	    this.rows = rows;
	    this.columns = columns;
	  }

	  static get [Symbol.species]() {
	    return Matrix;
	  }
	}

	class MatrixTransposeView extends BaseView {
	  constructor(matrix) {
	    super(matrix, matrix.columns, matrix.rows);
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(columnIndex, rowIndex, value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(columnIndex, rowIndex);
	  }
	}

	class MatrixRowView extends BaseView {
	  constructor(matrix, row) {
	    super(matrix, 1, matrix.columns);
	    this.row = row;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(this.row, columnIndex, value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(this.row, columnIndex);
	  }
	}

	class MatrixSubView extends BaseView {
	  constructor(matrix, startRow, endRow, startColumn, endColumn) {
	    checkRange(matrix, startRow, endRow, startColumn, endColumn);
	    super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
	    this.startRow = startRow;
	    this.startColumn = startColumn;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(
	      this.startRow + rowIndex,
	      this.startColumn + columnIndex,
	      value
	    );
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(
	      this.startRow + rowIndex,
	      this.startColumn + columnIndex
	    );
	  }
	}

	class MatrixSelectionView extends BaseView {
	  constructor(matrix, rowIndices, columnIndices) {
	    var indices = checkIndices(matrix, rowIndices, columnIndices);
	    super(matrix, indices.row.length, indices.column.length);
	    this.rowIndices = indices.row;
	    this.columnIndices = indices.column;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(
	      this.rowIndices[rowIndex],
	      this.columnIndices[columnIndex],
	      value
	    );
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(
	      this.rowIndices[rowIndex],
	      this.columnIndices[columnIndex]
	    );
	  }
	}

	class MatrixRowSelectionView extends BaseView {
	  constructor(matrix, rowIndices) {
	    rowIndices = checkRowIndices(matrix, rowIndices);
	    super(matrix, rowIndices.length, matrix.columns);
	    this.rowIndices = rowIndices;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
	  }
	}

	class MatrixColumnSelectionView extends BaseView {
	  constructor(matrix, columnIndices) {
	    columnIndices = checkColumnIndices(matrix, columnIndices);
	    super(matrix, matrix.rows, columnIndices.length);
	    this.columnIndices = columnIndices;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
	  }
	}

	class MatrixColumnView extends BaseView {
	  constructor(matrix, column) {
	    super(matrix, matrix.rows, 1);
	    this.column = column;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(rowIndex, this.column, value);
	    return this;
	  }

	  get(rowIndex) {
	    return this.matrix.get(rowIndex, this.column);
	  }
	}

	class MatrixFlipRowView extends BaseView {
	  constructor(matrix) {
	    super(matrix, matrix.rows, matrix.columns);
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
	  }
	}

	class MatrixFlipColumnView extends BaseView {
	  constructor(matrix) {
	    super(matrix, matrix.rows, matrix.columns);
	  }

	  set(rowIndex, columnIndex, value) {
	    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
	  }
	}

	function AbstractMatrix(superCtor) {
	  if (superCtor === undefined) superCtor = Object;

	  /**
	   * Real matrix
	   * @class Matrix
	   * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,
	   * 2D array containing the data or Matrix instance to clone
	   * @param {number} [nColumns] - Number of columns of the new matrix
	   */
	  class Matrix extends superCtor {
	    static get [Symbol.species]() {
	      return this;
	    }

	    /**
	     * Constructs a Matrix with the chosen dimensions from a 1D array
	     * @param {number} newRows - Number of rows
	     * @param {number} newColumns - Number of columns
	     * @param {Array} newData - A 1D array containing data for the matrix
	     * @return {Matrix} - The new matrix
	     */
	    static from1DArray(newRows, newColumns, newData) {
	      var length = newRows * newColumns;
	      if (length !== newData.length) {
	        throw new RangeError('Data length does not match given dimensions');
	      }
	      var newMatrix = new this(newRows, newColumns);
	      for (var row = 0; row < newRows; row++) {
	        for (var column = 0; column < newColumns; column++) {
	          newMatrix.set(row, column, newData[row * newColumns + column]);
	        }
	      }
	      return newMatrix;
	    }

	    /**
	         * Creates a row vector, a matrix with only one row.
	         * @param {Array} newData - A 1D array containing data for the vector
	         * @return {Matrix} - The new matrix
	         */
	    static rowVector(newData) {
	      var vector = new this(1, newData.length);
	      for (var i = 0; i < newData.length; i++) {
	        vector.set(0, i, newData[i]);
	      }
	      return vector;
	    }

	    /**
	         * Creates a column vector, a matrix with only one column.
	         * @param {Array} newData - A 1D array containing data for the vector
	         * @return {Matrix} - The new matrix
	         */
	    static columnVector(newData) {
	      var vector = new this(newData.length, 1);
	      for (var i = 0; i < newData.length; i++) {
	        vector.set(i, 0, newData[i]);
	      }
	      return vector;
	    }

	    /**
	         * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).
	         * @param {number} rows - Number of rows
	         * @param {number} columns - Number of columns
	         * @return {Matrix} - The new matrix
	         */
	    static empty(rows, columns) {
	      return new this(rows, columns);
	    }

	    /**
	         * Creates a matrix with the given dimensions. Values will be set to zero.
	         * @param {number} rows - Number of rows
	         * @param {number} columns - Number of columns
	         * @return {Matrix} - The new matrix
	         */
	    static zeros(rows, columns) {
	      return this.empty(rows, columns).fill(0);
	    }

	    /**
	         * Creates a matrix with the given dimensions. Values will be set to one.
	         * @param {number} rows - Number of rows
	         * @param {number} columns - Number of columns
	         * @return {Matrix} - The new matrix
	         */
	    static ones(rows, columns) {
	      return this.empty(rows, columns).fill(1);
	    }

	    /**
	         * Creates a matrix with the given dimensions. Values will be randomly set.
	         * @param {number} rows - Number of rows
	         * @param {number} columns - Number of columns
	         * @param {function} [rng=Math.random] - Random number generator
	         * @return {Matrix} The new matrix
	         */
	    static rand(rows, columns, rng) {
	      if (rng === undefined) rng = Math.random;
	      var matrix = this.empty(rows, columns);
	      for (var i = 0; i < rows; i++) {
	        for (var j = 0; j < columns; j++) {
	          matrix.set(i, j, rng());
	        }
	      }
	      return matrix;
	    }

	    /**
	         * Creates a matrix with the given dimensions. Values will be random integers.
	         * @param {number} rows - Number of rows
	         * @param {number} columns - Number of columns
	         * @param {number} [maxValue=1000] - Maximum value
	         * @param {function} [rng=Math.random] - Random number generator
	         * @return {Matrix} The new matrix
	         */
	    static randInt(rows, columns, maxValue, rng) {
	      if (maxValue === undefined) maxValue = 1000;
	      if (rng === undefined) rng = Math.random;
	      var matrix = this.empty(rows, columns);
	      for (var i = 0; i < rows; i++) {
	        for (var j = 0; j < columns; j++) {
	          var value = Math.floor(rng() * maxValue);
	          matrix.set(i, j, value);
	        }
	      }
	      return matrix;
	    }

	    /**
	         * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.
	         * @param {number} rows - Number of rows
	         * @param {number} [columns=rows] - Number of columns
	         * @param {number} [value=1] - Value to fill the diagonal with
	         * @return {Matrix} - The new identity matrix
	         */
	    static eye(rows, columns, value) {
	      if (columns === undefined) columns = rows;
	      if (value === undefined) value = 1;
	      var min = Math.min(rows, columns);
	      var matrix = this.zeros(rows, columns);
	      for (var i = 0; i < min; i++) {
	        matrix.set(i, i, value);
	      }
	      return matrix;
	    }

	    /**
	         * Creates a diagonal matrix based on the given array.
	         * @param {Array} data - Array containing the data for the diagonal
	         * @param {number} [rows] - Number of rows (Default: data.length)
	         * @param {number} [columns] - Number of columns (Default: rows)
	         * @return {Matrix} - The new diagonal matrix
	         */
	    static diag(data, rows, columns) {
	      var l = data.length;
	      if (rows === undefined) rows = l;
	      if (columns === undefined) columns = rows;
	      var min = Math.min(l, rows, columns);
	      var matrix = this.zeros(rows, columns);
	      for (var i = 0; i < min; i++) {
	        matrix.set(i, i, data[i]);
	      }
	      return matrix;
	    }

	    /**
	         * Returns a matrix whose elements are the minimum between matrix1 and matrix2
	         * @param {Matrix} matrix1
	         * @param {Matrix} matrix2
	         * @return {Matrix}
	         */
	    static min(matrix1, matrix2) {
	      matrix1 = this.checkMatrix(matrix1);
	      matrix2 = this.checkMatrix(matrix2);
	      var rows = matrix1.rows;
	      var columns = matrix1.columns;
	      var result = new this(rows, columns);
	      for (var i = 0; i < rows; i++) {
	        for (var j = 0; j < columns; j++) {
	          result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
	        }
	      }
	      return result;
	    }

	    /**
	         * Returns a matrix whose elements are the maximum between matrix1 and matrix2
	         * @param {Matrix} matrix1
	         * @param {Matrix} matrix2
	         * @return {Matrix}
	         */
	    static max(matrix1, matrix2) {
	      matrix1 = this.checkMatrix(matrix1);
	      matrix2 = this.checkMatrix(matrix2);
	      var rows = matrix1.rows;
	      var columns = matrix1.columns;
	      var result = new this(rows, columns);
	      for (var i = 0; i < rows; i++) {
	        for (var j = 0; j < columns; j++) {
	          result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
	        }
	      }
	      return result;
	    }

	    /**
	         * Check that the provided value is a Matrix and tries to instantiate one if not
	         * @param {*} value - The value to check
	         * @return {Matrix}
	         */
	    static checkMatrix(value) {
	      return Matrix.isMatrix(value) ? value : new this(value);
	    }

	    /**
	         * Returns true if the argument is a Matrix, false otherwise
	         * @param {*} value - The value to check
	         * @return {boolean}
	         */
	    static isMatrix(value) {
	      return (value != null) && (value.klass === 'Matrix');
	    }

	    /**
	         * @prop {number} size - The number of elements in the matrix.
	         */
	    get size() {
	      return this.rows * this.columns;
	    }

	    /**
	         * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.
	         * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)
	         * @return {Matrix} this
	         */
	    apply(callback) {
	      if (typeof callback !== 'function') {
	        throw new TypeError('callback must be a function');
	      }
	      var ii = this.rows;
	      var jj = this.columns;
	      for (var i = 0; i < ii; i++) {
	        for (var j = 0; j < jj; j++) {
	          callback.call(this, i, j);
	        }
	      }
	      return this;
	    }

	    /**
	         * Returns a new 1D array filled row by row with the matrix values
	         * @return {Array}
	         */
	    to1DArray() {
	      var array = new Array(this.size);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          array[i * this.columns + j] = this.get(i, j);
	        }
	      }
	      return array;
	    }

	    /**
	         * Returns a 2D array containing a copy of the data
	         * @return {Array}
	         */
	    to2DArray() {
	      var copy = new Array(this.rows);
	      for (var i = 0; i < this.rows; i++) {
	        copy[i] = new Array(this.columns);
	        for (var j = 0; j < this.columns; j++) {
	          copy[i][j] = this.get(i, j);
	        }
	      }
	      return copy;
	    }

	    /**
	         * @return {boolean} true if the matrix has one row
	         */
	    isRowVector() {
	      return this.rows === 1;
	    }

	    /**
	         * @return {boolean} true if the matrix has one column
	         */
	    isColumnVector() {
	      return this.columns === 1;
	    }

	    /**
	         * @return {boolean} true if the matrix has one row or one column
	         */
	    isVector() {
	      return (this.rows === 1) || (this.columns === 1);
	    }

	    /**
	         * @return {boolean} true if the matrix has the same number of rows and columns
	         */
	    isSquare() {
	      return this.rows === this.columns;
	    }

	    /**
	         * @return {boolean} true if the matrix is square and has the same values on both sides of the diagonal
	         */
	    isSymmetric() {
	      if (this.isSquare()) {
	        for (var i = 0; i < this.rows; i++) {
	          for (var j = 0; j <= i; j++) {
	            if (this.get(i, j) !== this.get(j, i)) {
	              return false;
	            }
	          }
	        }
	        return true;
	      }
	      return false;
	    }

	    /**
	         * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1
	         * @abstract
	         * @param {number} rowIndex - Index of the row
	         * @param {number} columnIndex - Index of the column
	         * @param {number} value - The new value for the element
	         * @return {Matrix} this
	         */
	    set(rowIndex, columnIndex, value) { // eslint-disable-line no-unused-vars
	      throw new Error('set method is unimplemented');
	    }

	    /**
	         * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]
	         * @abstract
	         * @param {number} rowIndex - Index of the row
	         * @param {number} columnIndex - Index of the column
	         * @return {number}
	         */
	    get(rowIndex, columnIndex) { // eslint-disable-line no-unused-vars
	      throw new Error('get method is unimplemented');
	    }

	    /**
	         * Creates a new matrix that is a repetition of the current matrix. New matrix has rowRep times the number of
	         * rows of the matrix, and colRep times the number of columns of the matrix
	         * @param {number} rowRep - Number of times the rows should be repeated
	         * @param {number} colRep - Number of times the columns should be re
	         * @return {Matrix}
	         * @example
	         * var matrix = new Matrix([[1,2]]);
	         * matrix.repeat(2); // [[1,2],[1,2]]
	         */
	    repeat(rowRep, colRep) {
	      rowRep = rowRep || 1;
	      colRep = colRep || 1;
	      var matrix = new this.constructor[Symbol.species](this.rows * rowRep, this.columns * colRep);
	      for (var i = 0; i < rowRep; i++) {
	        for (var j = 0; j < colRep; j++) {
	          matrix.setSubMatrix(this, this.rows * i, this.columns * j);
	        }
	      }
	      return matrix;
	    }

	    /**
	         * Fills the matrix with a given value. All elements will be set to this value.
	         * @param {number} value - New value
	         * @return {Matrix} this
	         */
	    fill(value) {
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          this.set(i, j, value);
	        }
	      }
	      return this;
	    }

	    /**
	         * Negates the matrix. All elements will be multiplied by (-1)
	         * @return {Matrix} this
	         */
	    neg() {
	      return this.mulS(-1);
	    }

	    /**
	         * Returns a new array from the given row index
	         * @param {number} index - Row index
	         * @return {Array}
	         */
	    getRow(index) {
	      checkRowIndex(this, index);
	      var row = new Array(this.columns);
	      for (var i = 0; i < this.columns; i++) {
	        row[i] = this.get(index, i);
	      }
	      return row;
	    }

	    /**
	         * Returns a new row vector from the given row index
	         * @param {number} index - Row index
	         * @return {Matrix}
	         */
	    getRowVector(index) {
	      return this.constructor.rowVector(this.getRow(index));
	    }

	    /**
	         * Sets a row at the given index
	         * @param {number} index - Row index
	         * @param {Array|Matrix} array - Array or vector
	         * @return {Matrix} this
	         */
	    setRow(index, array) {
	      checkRowIndex(this, index);
	      array = checkRowVector(this, array);
	      for (var i = 0; i < this.columns; i++) {
	        this.set(index, i, array[i]);
	      }
	      return this;
	    }

	    /**
	         * Swaps two rows
	         * @param {number} row1 - First row index
	         * @param {number} row2 - Second row index
	         * @return {Matrix} this
	         */
	    swapRows(row1, row2) {
	      checkRowIndex(this, row1);
	      checkRowIndex(this, row2);
	      for (var i = 0; i < this.columns; i++) {
	        var temp = this.get(row1, i);
	        this.set(row1, i, this.get(row2, i));
	        this.set(row2, i, temp);
	      }
	      return this;
	    }

	    /**
	         * Returns a new array from the given column index
	         * @param {number} index - Column index
	         * @return {Array}
	         */
	    getColumn(index) {
	      checkColumnIndex(this, index);
	      var column = new Array(this.rows);
	      for (var i = 0; i < this.rows; i++) {
	        column[i] = this.get(i, index);
	      }
	      return column;
	    }

	    /**
	         * Returns a new column vector from the given column index
	         * @param {number} index - Column index
	         * @return {Matrix}
	         */
	    getColumnVector(index) {
	      return this.constructor.columnVector(this.getColumn(index));
	    }

	    /**
	         * Sets a column at the given index
	         * @param {number} index - Column index
	         * @param {Array|Matrix} array - Array or vector
	         * @return {Matrix} this
	         */
	    setColumn(index, array) {
	      checkColumnIndex(this, index);
	      array = checkColumnVector(this, array);
	      for (var i = 0; i < this.rows; i++) {
	        this.set(i, index, array[i]);
	      }
	      return this;
	    }

	    /**
	         * Swaps two columns
	         * @param {number} column1 - First column index
	         * @param {number} column2 - Second column index
	         * @return {Matrix} this
	         */
	    swapColumns(column1, column2) {
	      checkColumnIndex(this, column1);
	      checkColumnIndex(this, column2);
	      for (var i = 0; i < this.rows; i++) {
	        var temp = this.get(i, column1);
	        this.set(i, column1, this.get(i, column2));
	        this.set(i, column2, temp);
	      }
	      return this;
	    }

	    /**
	         * Adds the values of a vector to each row
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	    addRowVector(vector) {
	      vector = checkRowVector(this, vector);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          this.set(i, j, this.get(i, j) + vector[j]);
	        }
	      }
	      return this;
	    }

	    /**
	         * Subtracts the values of a vector from each row
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	    subRowVector(vector) {
	      vector = checkRowVector(this, vector);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          this.set(i, j, this.get(i, j) - vector[j]);
	        }
	      }
	      return this;
	    }

	    /**
	         * Multiplies the values of a vector with each row
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	    mulRowVector(vector) {
	      vector = checkRowVector(this, vector);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          this.set(i, j, this.get(i, j) * vector[j]);
	        }
	      }
	      return this;
	    }

	    /**
	         * Divides the values of each row by those of a vector
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	    divRowVector(vector) {
	      vector = checkRowVector(this, vector);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          this.set(i, j, this.get(i, j) / vector[j]);
	        }
	      }
	      return this;
	    }

	    /**
	         * Adds the values of a vector to each column
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	    addColumnVector(vector) {
	      vector = checkColumnVector(this, vector);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          this.set(i, j, this.get(i, j) + vector[i]);
	        }
	      }
	      return this;
	    }

	    /**
	         * Subtracts the values of a vector from each column
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	    subColumnVector(vector) {
	      vector = checkColumnVector(this, vector);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          this.set(i, j, this.get(i, j) - vector[i]);
	        }
	      }
	      return this;
	    }

	    /**
	         * Multiplies the values of a vector with each column
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	    mulColumnVector(vector) {
	      vector = checkColumnVector(this, vector);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          this.set(i, j, this.get(i, j) * vector[i]);
	        }
	      }
	      return this;
	    }

	    /**
	         * Divides the values of each column by those of a vector
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	    divColumnVector(vector) {
	      vector = checkColumnVector(this, vector);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          this.set(i, j, this.get(i, j) / vector[i]);
	        }
	      }
	      return this;
	    }

	    /**
	         * Multiplies the values of a row with a scalar
	         * @param {number} index - Row index
	         * @param {number} value
	         * @return {Matrix} this
	         */
	    mulRow(index, value) {
	      checkRowIndex(this, index);
	      for (var i = 0; i < this.columns; i++) {
	        this.set(index, i, this.get(index, i) * value);
	      }
	      return this;
	    }

	    /**
	         * Multiplies the values of a column with a scalar
	         * @param {number} index - Column index
	         * @param {number} value
	         * @return {Matrix} this
	         */
	    mulColumn(index, value) {
	      checkColumnIndex(this, index);
	      for (var i = 0; i < this.rows; i++) {
	        this.set(i, index, this.get(i, index) * value);
	      }
	      return this;
	    }

	    /**
	         * Returns the maximum value of the matrix
	         * @return {number}
	         */
	    max() {
	      var v = this.get(0, 0);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          if (this.get(i, j) > v) {
	            v = this.get(i, j);
	          }
	        }
	      }
	      return v;
	    }

	    /**
	         * Returns the index of the maximum value
	         * @return {Array}
	         */
	    maxIndex() {
	      var v = this.get(0, 0);
	      var idx = [0, 0];
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          if (this.get(i, j) > v) {
	            v = this.get(i, j);
	            idx[0] = i;
	            idx[1] = j;
	          }
	        }
	      }
	      return idx;
	    }

	    /**
	         * Returns the minimum value of the matrix
	         * @return {number}
	         */
	    min() {
	      var v = this.get(0, 0);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          if (this.get(i, j) < v) {
	            v = this.get(i, j);
	          }
	        }
	      }
	      return v;
	    }

	    /**
	         * Returns the index of the minimum value
	         * @return {Array}
	         */
	    minIndex() {
	      var v = this.get(0, 0);
	      var idx = [0, 0];
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          if (this.get(i, j) < v) {
	            v = this.get(i, j);
	            idx[0] = i;
	            idx[1] = j;
	          }
	        }
	      }
	      return idx;
	    }

	    /**
	         * Returns the maximum value of one row
	         * @param {number} row - Row index
	         * @return {number}
	         */
	    maxRow(row) {
	      checkRowIndex(this, row);
	      var v = this.get(row, 0);
	      for (var i = 1; i < this.columns; i++) {
	        if (this.get(row, i) > v) {
	          v = this.get(row, i);
	        }
	      }
	      return v;
	    }

	    /**
	         * Returns the index of the maximum value of one row
	         * @param {number} row - Row index
	         * @return {Array}
	         */
	    maxRowIndex(row) {
	      checkRowIndex(this, row);
	      var v = this.get(row, 0);
	      var idx = [row, 0];
	      for (var i = 1; i < this.columns; i++) {
	        if (this.get(row, i) > v) {
	          v = this.get(row, i);
	          idx[1] = i;
	        }
	      }
	      return idx;
	    }

	    /**
	         * Returns the minimum value of one row
	         * @param {number} row - Row index
	         * @return {number}
	         */
	    minRow(row) {
	      checkRowIndex(this, row);
	      var v = this.get(row, 0);
	      for (var i = 1; i < this.columns; i++) {
	        if (this.get(row, i) < v) {
	          v = this.get(row, i);
	        }
	      }
	      return v;
	    }

	    /**
	         * Returns the index of the maximum value of one row
	         * @param {number} row - Row index
	         * @return {Array}
	         */
	    minRowIndex(row) {
	      checkRowIndex(this, row);
	      var v = this.get(row, 0);
	      var idx = [row, 0];
	      for (var i = 1; i < this.columns; i++) {
	        if (this.get(row, i) < v) {
	          v = this.get(row, i);
	          idx[1] = i;
	        }
	      }
	      return idx;
	    }

	    /**
	         * Returns the maximum value of one column
	         * @param {number} column - Column index
	         * @return {number}
	         */
	    maxColumn(column) {
	      checkColumnIndex(this, column);
	      var v = this.get(0, column);
	      for (var i = 1; i < this.rows; i++) {
	        if (this.get(i, column) > v) {
	          v = this.get(i, column);
	        }
	      }
	      return v;
	    }

	    /**
	         * Returns the index of the maximum value of one column
	         * @param {number} column - Column index
	         * @return {Array}
	         */
	    maxColumnIndex(column) {
	      checkColumnIndex(this, column);
	      var v = this.get(0, column);
	      var idx = [0, column];
	      for (var i = 1; i < this.rows; i++) {
	        if (this.get(i, column) > v) {
	          v = this.get(i, column);
	          idx[0] = i;
	        }
	      }
	      return idx;
	    }

	    /**
	         * Returns the minimum value of one column
	         * @param {number} column - Column index
	         * @return {number}
	         */
	    minColumn(column) {
	      checkColumnIndex(this, column);
	      var v = this.get(0, column);
	      for (var i = 1; i < this.rows; i++) {
	        if (this.get(i, column) < v) {
	          v = this.get(i, column);
	        }
	      }
	      return v;
	    }

	    /**
	         * Returns the index of the minimum value of one column
	         * @param {number} column - Column index
	         * @return {Array}
	         */
	    minColumnIndex(column) {
	      checkColumnIndex(this, column);
	      var v = this.get(0, column);
	      var idx = [0, column];
	      for (var i = 1; i < this.rows; i++) {
	        if (this.get(i, column) < v) {
	          v = this.get(i, column);
	          idx[0] = i;
	        }
	      }
	      return idx;
	    }

	    /**
	         * Returns an array containing the diagonal values of the matrix
	         * @return {Array}
	         */
	    diag() {
	      var min = Math.min(this.rows, this.columns);
	      var diag = new Array(min);
	      for (var i = 0; i < min; i++) {
	        diag[i] = this.get(i, i);
	      }
	      return diag;
	    }

	    /**
	         * Returns the sum by the argument given, if no argument given,
	         * it returns the sum of all elements of the matrix.
	         * @param {string} by - sum by 'row' or 'column'.
	         * @return {Matrix|number}
	         */
	    sum(by) {
	      switch (by) {
	        case 'row':
	          return sumByRow(this);
	        case 'column':
	          return sumByColumn(this);
	        default:
	          return sumAll(this);
	      }
	    }

	    /**
	         * Returns the mean of all elements of the matrix
	         * @return {number}
	         */
	    mean() {
	      return this.sum() / this.size;
	    }

	    /**
	         * Returns the product of all elements of the matrix
	         * @return {number}
	         */
	    prod() {
	      var prod = 1;
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          prod *= this.get(i, j);
	        }
	      }
	      return prod;
	    }

	    /**
	         * Returns the norm of a matrix.
	         * @param {string} type - "frobenius" (default) or "max" return resp. the Frobenius norm and the max norm.
	         * @return {number}
	         */
	    norm(type = 'frobenius') {
	      var result = 0;
	      if (type === 'max') {
	        return this.max();
	      } else if (type === 'frobenius') {
	        for (var i = 0; i < this.rows; i++) {
	          for (var j = 0; j < this.columns; j++) {
	            result = result + this.get(i, j) * this.get(i, j);
	          }
	        }
	        return Math.sqrt(result);
	      } else {
	        throw new RangeError(`unknown norm type: ${type}`);
	      }
	    }

	    /**
	         * Computes the cumulative sum of the matrix elements (in place, row by row)
	         * @return {Matrix} this
	         */
	    cumulativeSum() {
	      var sum = 0;
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          sum += this.get(i, j);
	          this.set(i, j, sum);
	        }
	      }
	      return this;
	    }

	    /**
	         * Computes the dot (scalar) product between the matrix and another
	         * @param {Matrix} vector2 vector
	         * @return {number}
	         */
	    dot(vector2) {
	      if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
	      var vector1 = this.to1DArray();
	      if (vector1.length !== vector2.length) {
	        throw new RangeError('vectors do not have the same size');
	      }
	      var dot = 0;
	      for (var i = 0; i < vector1.length; i++) {
	        dot += vector1[i] * vector2[i];
	      }
	      return dot;
	    }

	    /**
	         * Returns the matrix product between this and other
	         * @param {Matrix} other
	         * @return {Matrix}
	         */
	    mmul(other) {
	      other = this.constructor.checkMatrix(other);
	      if (this.columns !== other.rows) {
	        // eslint-disable-next-line no-console
	        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
	      }

	      var m = this.rows;
	      var n = this.columns;
	      var p = other.columns;

	      var result = new this.constructor[Symbol.species](m, p);

	      var Bcolj = new Array(n);
	      for (var j = 0; j < p; j++) {
	        for (var k = 0; k < n; k++) {
	          Bcolj[k] = other.get(k, j);
	        }

	        for (var i = 0; i < m; i++) {
	          var s = 0;
	          for (k = 0; k < n; k++) {
	            s += this.get(i, k) * Bcolj[k];
	          }

	          result.set(i, j, s);
	        }
	      }
	      return result;
	    }

	    strassen2x2(other) {
	      var result = new this.constructor[Symbol.species](2, 2);
	      const a11 = this.get(0, 0);
	      const b11 = other.get(0, 0);
	      const a12 = this.get(0, 1);
	      const b12 = other.get(0, 1);
	      const a21 = this.get(1, 0);
	      const b21 = other.get(1, 0);
	      const a22 = this.get(1, 1);
	      const b22 = other.get(1, 1);

	      // Compute intermediate values.
	      const m1 = (a11 + a22) * (b11 + b22);
	      const m2 = (a21 + a22) * b11;
	      const m3 = a11 * (b12 - b22);
	      const m4 = a22 * (b21 - b11);
	      const m5 = (a11 + a12) * b22;
	      const m6 = (a21 - a11) * (b11 + b12);
	      const m7 = (a12 - a22) * (b21 + b22);

	      // Combine intermediate values into the output.
	      const c00 = m1 + m4 - m5 + m7;
	      const c01 = m3 + m5;
	      const c10 = m2 + m4;
	      const c11 = m1 - m2 + m3 + m6;

	      result.set(0, 0, c00);
	      result.set(0, 1, c01);
	      result.set(1, 0, c10);
	      result.set(1, 1, c11);
	      return result;
	    }

	    strassen3x3(other) {
	      var result = new this.constructor[Symbol.species](3, 3);

	      const a00 = this.get(0, 0);
	      const a01 = this.get(0, 1);
	      const a02 = this.get(0, 2);
	      const a10 = this.get(1, 0);
	      const a11 = this.get(1, 1);
	      const a12 = this.get(1, 2);
	      const a20 = this.get(2, 0);
	      const a21 = this.get(2, 1);
	      const a22 = this.get(2, 2);

	      const b00 = other.get(0, 0);
	      const b01 = other.get(0, 1);
	      const b02 = other.get(0, 2);
	      const b10 = other.get(1, 0);
	      const b11 = other.get(1, 1);
	      const b12 = other.get(1, 2);
	      const b20 = other.get(2, 0);
	      const b21 = other.get(2, 1);
	      const b22 = other.get(2, 2);

	      const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
	      const m2 = (a00 - a10) * (-b01 + b11);
	      const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
	      const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
	      const m5 = (a10 + a11) * (-b00 + b01);
	      const m6 = a00 * b00;
	      const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
	      const m8 = (-a00 + a20) * (b02 - b12);
	      const m9 = (a20 + a21) * (-b00 + b02);
	      const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
	      const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
	      const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
	      const m13 = (a02 - a22) * (b11 - b21);
	      const m14 = a02 * b20;
	      const m15 = (a21 + a22) * (-b20 + b21);
	      const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
	      const m17 = (a02 - a12) * (b12 - b22);
	      const m18 = (a11 + a12) * (-b20 + b22);
	      const m19 = a01 * b10;
	      const m20 = a12 * b21;
	      const m21 = a10 * b02;
	      const m22 = a20 * b01;
	      const m23 = a22 * b22;

	      const c00 = m6 + m14 + m19;
	      const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
	      const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
	      const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
	      const c11 = m2 + m4 + m5 + m6 + m20;
	      const c12 = m14 + m16 + m17 + m18 + m21;
	      const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
	      const c21 = m12 + m13 + m14 + m15 + m22;
	      const c22 = m6 + m7 + m8 + m9 + m23;

	      result.set(0, 0, c00);
	      result.set(0, 1, c01);
	      result.set(0, 2, c02);
	      result.set(1, 0, c10);
	      result.set(1, 1, c11);
	      result.set(1, 2, c12);
	      result.set(2, 0, c20);
	      result.set(2, 1, c21);
	      result.set(2, 2, c22);
	      return result;
	    }

	    /**
	         * Returns the matrix product between x and y. More efficient than mmul(other) only when we multiply squared matrix and when the size of the matrix is > 1000.
	         * @param {Matrix} y
	         * @return {Matrix}
	         */
	    mmulStrassen(y) {
	      var x = this.clone();
	      var r1 = x.rows;
	      var c1 = x.columns;
	      var r2 = y.rows;
	      var c2 = y.columns;
	      if (c1 !== r2) {
	        // eslint-disable-next-line no-console
	        console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);
	      }

	      // Put a matrix into the top left of a matrix of zeros.
	      // `rows` and `cols` are the dimensions of the output matrix.
	      function embed(mat, rows, cols) {
	        var r = mat.rows;
	        var c = mat.columns;
	        if ((r === rows) && (c === cols)) {
	          return mat;
	        } else {
	          var resultat = Matrix.zeros(rows, cols);
	          resultat = resultat.setSubMatrix(mat, 0, 0);
	          return resultat;
	        }
	      }


	      // Make sure both matrices are the same size.
	      // This is exclusively for simplicity:
	      // this algorithm can be implemented with matrices of different sizes.

	      var r = Math.max(r1, r2);
	      var c = Math.max(c1, c2);
	      x = embed(x, r, c);
	      y = embed(y, r, c);

	      // Our recursive multiplication function.
	      function blockMult(a, b, rows, cols) {
	        // For small matrices, resort to naive multiplication.
	        if (rows <= 512 || cols <= 512) {
	          return a.mmul(b); // a is equivalent to this
	        }

	        // Apply dynamic padding.
	        if ((rows % 2 === 1) && (cols % 2 === 1)) {
	          a = embed(a, rows + 1, cols + 1);
	          b = embed(b, rows + 1, cols + 1);
	        } else if (rows % 2 === 1) {
	          a = embed(a, rows + 1, cols);
	          b = embed(b, rows + 1, cols);
	        } else if (cols % 2 === 1) {
	          a = embed(a, rows, cols + 1);
	          b = embed(b, rows, cols + 1);
	        }

	        var halfRows = parseInt(a.rows / 2, 10);
	        var halfCols = parseInt(a.columns / 2, 10);
	        // Subdivide input matrices.
	        var a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
	        var b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);

	        var a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
	        var b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);

	        var a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
	        var b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);

	        var a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
	        var b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);

	        // Compute intermediate values.
	        var m1 = blockMult(Matrix.add(a11, a22), Matrix.add(b11, b22), halfRows, halfCols);
	        var m2 = blockMult(Matrix.add(a21, a22), b11, halfRows, halfCols);
	        var m3 = blockMult(a11, Matrix.sub(b12, b22), halfRows, halfCols);
	        var m4 = blockMult(a22, Matrix.sub(b21, b11), halfRows, halfCols);
	        var m5 = blockMult(Matrix.add(a11, a12), b22, halfRows, halfCols);
	        var m6 = blockMult(Matrix.sub(a21, a11), Matrix.add(b11, b12), halfRows, halfCols);
	        var m7 = blockMult(Matrix.sub(a12, a22), Matrix.add(b21, b22), halfRows, halfCols);

	        // Combine intermediate values into the output.
	        var c11 = Matrix.add(m1, m4);
	        c11.sub(m5);
	        c11.add(m7);
	        var c12 = Matrix.add(m3, m5);
	        var c21 = Matrix.add(m2, m4);
	        var c22 = Matrix.sub(m1, m2);
	        c22.add(m3);
	        c22.add(m6);

	        // Crop output to the desired size (undo dynamic padding).
	        var resultat = Matrix.zeros(2 * c11.rows, 2 * c11.columns);
	        resultat = resultat.setSubMatrix(c11, 0, 0);
	        resultat = resultat.setSubMatrix(c12, c11.rows, 0);
	        resultat = resultat.setSubMatrix(c21, 0, c11.columns);
	        resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);
	        return resultat.subMatrix(0, rows - 1, 0, cols - 1);
	      }
	      return blockMult(x, y, r, c);
	    }

	    /**
	         * Returns a row-by-row scaled matrix
	         * @param {number} [min=0] - Minimum scaled value
	         * @param {number} [max=1] - Maximum scaled value
	         * @return {Matrix} - The scaled matrix
	         */
	    scaleRows(min, max) {
	      min = min === undefined ? 0 : min;
	      max = max === undefined ? 1 : max;
	      if (min >= max) {
	        throw new RangeError('min should be strictly smaller than max');
	      }
	      var newMatrix = this.constructor.empty(this.rows, this.columns);
	      for (var i = 0; i < this.rows; i++) {
	        var scaled = rescale(this.getRow(i), { min, max });
	        newMatrix.setRow(i, scaled);
	      }
	      return newMatrix;
	    }

	    /**
	         * Returns a new column-by-column scaled matrix
	         * @param {number} [min=0] - Minimum scaled value
	         * @param {number} [max=1] - Maximum scaled value
	         * @return {Matrix} - The new scaled matrix
	         * @example
	         * var matrix = new Matrix([[1,2],[-1,0]]);
	         * var scaledMatrix = matrix.scaleColumns(); // [[1,1],[0,0]]
	         */
	    scaleColumns(min, max) {
	      min = min === undefined ? 0 : min;
	      max = max === undefined ? 1 : max;
	      if (min >= max) {
	        throw new RangeError('min should be strictly smaller than max');
	      }
	      var newMatrix = this.constructor.empty(this.rows, this.columns);
	      for (var i = 0; i < this.columns; i++) {
	        var scaled = rescale(this.getColumn(i), {
	          min: min,
	          max: max
	        });
	        newMatrix.setColumn(i, scaled);
	      }
	      return newMatrix;
	    }


	    /**
	         * Returns the Kronecker product (also known as tensor product) between this and other
	         * See https://en.wikipedia.org/wiki/Kronecker_product
	         * @param {Matrix} other
	         * @return {Matrix}
	         */
	    kroneckerProduct(other) {
	      other = this.constructor.checkMatrix(other);

	      var m = this.rows;
	      var n = this.columns;
	      var p = other.rows;
	      var q = other.columns;

	      var result = new this.constructor[Symbol.species](m * p, n * q);
	      for (var i = 0; i < m; i++) {
	        for (var j = 0; j < n; j++) {
	          for (var k = 0; k < p; k++) {
	            for (var l = 0; l < q; l++) {
	              result[p * i + k][q * j + l] = this.get(i, j) * other.get(k, l);
	            }
	          }
	        }
	      }
	      return result;
	    }

	    /**
	         * Transposes the matrix and returns a new one containing the result
	         * @return {Matrix}
	         */
	    transpose() {
	      var result = new this.constructor[Symbol.species](this.columns, this.rows);
	      for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	          result.set(j, i, this.get(i, j));
	        }
	      }
	      return result;
	    }

	    /**
	         * Sorts the rows (in place)
	         * @param {function} compareFunction - usual Array.prototype.sort comparison function
	         * @return {Matrix} this
	         */
	    sortRows(compareFunction) {
	      if (compareFunction === undefined) compareFunction = compareNumbers;
	      for (var i = 0; i < this.rows; i++) {
	        this.setRow(i, this.getRow(i).sort(compareFunction));
	      }
	      return this;
	    }

	    /**
	         * Sorts the columns (in place)
	         * @param {function} compareFunction - usual Array.prototype.sort comparison function
	         * @return {Matrix} this
	         */
	    sortColumns(compareFunction) {
	      if (compareFunction === undefined) compareFunction = compareNumbers;
	      for (var i = 0; i < this.columns; i++) {
	        this.setColumn(i, this.getColumn(i).sort(compareFunction));
	      }
	      return this;
	    }

	    /**
	         * Returns a subset of the matrix
	         * @param {number} startRow - First row index
	         * @param {number} endRow - Last row index
	         * @param {number} startColumn - First column index
	         * @param {number} endColumn - Last column index
	         * @return {Matrix}
	         */
	    subMatrix(startRow, endRow, startColumn, endColumn) {
	      checkRange(this, startRow, endRow, startColumn, endColumn);
	      var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, endColumn - startColumn + 1);
	      for (var i = startRow; i <= endRow; i++) {
	        for (var j = startColumn; j <= endColumn; j++) {
	          newMatrix[i - startRow][j - startColumn] = this.get(i, j);
	        }
	      }
	      return newMatrix;
	    }

	    /**
	         * Returns a subset of the matrix based on an array of row indices
	         * @param {Array} indices - Array containing the row indices
	         * @param {number} [startColumn = 0] - First column index
	         * @param {number} [endColumn = this.columns-1] - Last column index
	         * @return {Matrix}
	         */
	    subMatrixRow(indices, startColumn, endColumn) {
	      if (startColumn === undefined) startColumn = 0;
	      if (endColumn === undefined) endColumn = this.columns - 1;
	      if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
	        throw new RangeError('Argument out of range');
	      }

	      var newMatrix = new this.constructor[Symbol.species](indices.length, endColumn - startColumn + 1);
	      for (var i = 0; i < indices.length; i++) {
	        for (var j = startColumn; j <= endColumn; j++) {
	          if (indices[i] < 0 || indices[i] >= this.rows) {
	            throw new RangeError(`Row index out of range: ${indices[i]}`);
	          }
	          newMatrix.set(i, j - startColumn, this.get(indices[i], j));
	        }
	      }
	      return newMatrix;
	    }

	    /**
	         * Returns a subset of the matrix based on an array of column indices
	         * @param {Array} indices - Array containing the column indices
	         * @param {number} [startRow = 0] - First row index
	         * @param {number} [endRow = this.rows-1] - Last row index
	         * @return {Matrix}
	         */
	    subMatrixColumn(indices, startRow, endRow) {
	      if (startRow === undefined) startRow = 0;
	      if (endRow === undefined) endRow = this.rows - 1;
	      if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {
	        throw new RangeError('Argument out of range');
	      }

	      var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, indices.length);
	      for (var i = 0; i < indices.length; i++) {
	        for (var j = startRow; j <= endRow; j++) {
	          if (indices[i] < 0 || indices[i] >= this.columns) {
	            throw new RangeError(`Column index out of range: ${indices[i]}`);
	          }
	          newMatrix.set(j - startRow, i, this.get(j, indices[i]));
	        }
	      }
	      return newMatrix;
	    }

	    /**
	         * Set a part of the matrix to the given sub-matrix
	         * @param {Matrix|Array< Array >} matrix - The source matrix from which to extract values.
	         * @param {number} startRow - The index of the first row to set
	         * @param {number} startColumn - The index of the first column to set
	         * @return {Matrix}
	         */
	    setSubMatrix(matrix, startRow, startColumn) {
	      matrix = this.constructor.checkMatrix(matrix);
	      var endRow = startRow + matrix.rows - 1;
	      var endColumn = startColumn + matrix.columns - 1;
	      checkRange(this, startRow, endRow, startColumn, endColumn);
	      for (var i = 0; i < matrix.rows; i++) {
	        for (var j = 0; j < matrix.columns; j++) {
	          this[startRow + i][startColumn + j] = matrix.get(i, j);
	        }
	      }
	      return this;
	    }

	    /**
	         * Return a new matrix based on a selection of rows and columns
	         * @param {Array<number>} rowIndices - The row indices to select. Order matters and an index can be more than once.
	         * @param {Array<number>} columnIndices - The column indices to select. Order matters and an index can be use more than once.
	         * @return {Matrix} The new matrix
	         */
	    selection(rowIndices, columnIndices) {
	      var indices = checkIndices(this, rowIndices, columnIndices);
	      var newMatrix = new this.constructor[Symbol.species](rowIndices.length, columnIndices.length);
	      for (var i = 0; i < indices.row.length; i++) {
	        var rowIndex = indices.row[i];
	        for (var j = 0; j < indices.column.length; j++) {
	          var columnIndex = indices.column[j];
	          newMatrix[i][j] = this.get(rowIndex, columnIndex);
	        }
	      }
	      return newMatrix;
	    }

	    /**
	         * Returns the trace of the matrix (sum of the diagonal elements)
	         * @return {number}
	         */
	    trace() {
	      var min = Math.min(this.rows, this.columns);
	      var trace = 0;
	      for (var i = 0; i < min; i++) {
	        trace += this.get(i, i);
	      }
	      return trace;
	    }

	    /*
	         Matrix views
	         */

	    /**
	         * Returns a view of the transposition of the matrix
	         * @return {MatrixTransposeView}
	         */
	    transposeView() {
	      return new MatrixTransposeView(this);
	    }

	    /**
	         * Returns a view of the row vector with the given index
	         * @param {number} row - row index of the vector
	         * @return {MatrixRowView}
	         */
	    rowView(row) {
	      checkRowIndex(this, row);
	      return new MatrixRowView(this, row);
	    }

	    /**
	         * Returns a view of the column vector with the given index
	         * @param {number} column - column index of the vector
	         * @return {MatrixColumnView}
	         */
	    columnView(column) {
	      checkColumnIndex(this, column);
	      return new MatrixColumnView(this, column);
	    }

	    /**
	         * Returns a view of the matrix flipped in the row axis
	         * @return {MatrixFlipRowView}
	         */
	    flipRowView() {
	      return new MatrixFlipRowView(this);
	    }

	    /**
	         * Returns a view of the matrix flipped in the column axis
	         * @return {MatrixFlipColumnView}
	         */
	    flipColumnView() {
	      return new MatrixFlipColumnView(this);
	    }

	    /**
	         * Returns a view of a submatrix giving the index boundaries
	         * @param {number} startRow - first row index of the submatrix
	         * @param {number} endRow - last row index of the submatrix
	         * @param {number} startColumn - first column index of the submatrix
	         * @param {number} endColumn - last column index of the submatrix
	         * @return {MatrixSubView}
	         */
	    subMatrixView(startRow, endRow, startColumn, endColumn) {
	      return new MatrixSubView(this, startRow, endRow, startColumn, endColumn);
	    }

	    /**
	         * Returns a view of the cross of the row indices and the column indices
	         * @example
	         * // resulting vector is [[2], [2]]
	         * var matrix = new Matrix([[1,2,3], [4,5,6]]).selectionView([0, 0], [1])
	         * @param {Array<number>} rowIndices
	         * @param {Array<number>} columnIndices
	         * @return {MatrixSelectionView}
	         */
	    selectionView(rowIndices, columnIndices) {
	      return new MatrixSelectionView(this, rowIndices, columnIndices);
	    }

	    /**
	         * Returns a view of the row indices
	         * @example
	         * // resulting vector is [[1,2,3], [1,2,3]]
	         * var matrix = new Matrix([[1,2,3], [4,5,6]]).rowSelectionView([0, 0])
	         * @param {Array<number>} rowIndices
	         * @return {MatrixRowSelectionView}
	         */
	    rowSelectionView(rowIndices) {
	      return new MatrixRowSelectionView(this, rowIndices);
	    }

	    /**
	         * Returns a view of the column indices
	         * @example
	         * // resulting vector is [[2, 2], [5, 5]]
	         * var matrix = new Matrix([[1,2,3], [4,5,6]]).columnSelectionView([1, 1])
	         * @param {Array<number>} columnIndices
	         * @return {MatrixColumnSelectionView}
	         */
	    columnSelectionView(columnIndices) {
	      return new MatrixColumnSelectionView(this, columnIndices);
	    }


	    /**
	        * Calculates and returns the determinant of a matrix as a Number
	        * @example
	        *   new Matrix([[1,2,3], [4,5,6]]).det()
	        * @return {number}
	        */
	    det() {
	      if (this.isSquare()) {
	        var a, b, c, d;
	        if (this.columns === 2) {
	          // 2 x 2 matrix
	          a = this.get(0, 0);
	          b = this.get(0, 1);
	          c = this.get(1, 0);
	          d = this.get(1, 1);

	          return a * d - (b * c);
	        } else if (this.columns === 3) {
	          // 3 x 3 matrix
	          var subMatrix0, subMatrix1, subMatrix2;
	          subMatrix0 = this.selectionView([1, 2], [1, 2]);
	          subMatrix1 = this.selectionView([1, 2], [0, 2]);
	          subMatrix2 = this.selectionView([1, 2], [0, 1]);
	          a = this.get(0, 0);
	          b = this.get(0, 1);
	          c = this.get(0, 2);

	          return a * subMatrix0.det() - b * subMatrix1.det() + c * subMatrix2.det();
	        } else {
	          // general purpose determinant using the LU decomposition
	          return new LuDecomposition$$1(this).determinant;
	        }
	      } else {
	        throw Error('Determinant can only be calculated for a square matrix.');
	      }
	    }

	    /**
	         * Returns inverse of a matrix if it exists or the pseudoinverse
	         * @param {number} threshold - threshold for taking inverse of singular values (default = 1e-15)
	         * @return {Matrix} the (pseudo)inverted matrix.
	         */
	    pseudoInverse(threshold) {
	      if (threshold === undefined) threshold = Number.EPSILON;
	      var svdSolution = new SingularValueDecomposition$$1(this, { autoTranspose: true });

	      var U = svdSolution.leftSingularVectors;
	      var V = svdSolution.rightSingularVectors;
	      var s = svdSolution.diagonal;

	      for (var i = 0; i < s.length; i++) {
	        if (Math.abs(s[i]) > threshold) {
	          s[i] = 1.0 / s[i];
	        } else {
	          s[i] = 0.0;
	        }
	      }

	      // convert list to diagonal
	      s = this.constructor[Symbol.species].diag(s);
	      return V.mmul(s.mmul(U.transposeView()));
	    }

	    /**
	         * Creates an exact and independent copy of the matrix
	         * @return {Matrix}
	         */
	    clone() {
	      var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);
	      for (var row = 0; row < this.rows; row++) {
	        for (var column = 0; column < this.columns; column++) {
	          newMatrix.set(row, column, this.get(row, column));
	        }
	      }
	      return newMatrix;
	    }
	  }

	  Matrix.prototype.klass = 'Matrix';

	  function compareNumbers(a, b) {
	    return a - b;
	  }

	  /*
	     Synonyms
	     */

	  Matrix.random = Matrix.rand;
	  Matrix.diagonal = Matrix.diag;
	  Matrix.prototype.diagonal = Matrix.prototype.diag;
	  Matrix.identity = Matrix.eye;
	  Matrix.prototype.negate = Matrix.prototype.neg;
	  Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;
	  Matrix.prototype.determinant = Matrix.prototype.det;

	  /*
	     Add dynamically instance and static methods for mathematical operations
	     */

	  var inplaceOperator = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;

	  var inplaceOperatorScalar = `
(function %name%S(value) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) %op% value);
        }
    }
    return this;
})
`;

	  var inplaceOperatorMatrix = `
(function %name%M(matrix) {
    matrix = this.constructor.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
        this.columns !== matrix.columns) {
        throw new RangeError('Matrices dimensions must be equal');
    }
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));
        }
    }
    return this;
})
`;

	  var staticOperator = `
(function %name%(matrix, value) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%(value);
})
`;

	  var inplaceMethod = `
(function %name%() {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j)));
        }
    }
    return this;
})
`;

	  var staticMethod = `
(function %name%(matrix) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%();
})
`;

	  var inplaceMethodWithArgs = `
(function %name%(%args%) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), %args%));
        }
    }
    return this;
})
`;

	  var staticMethodWithArgs = `
(function %name%(matrix, %args%) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%(%args%);
})
`;


	  var inplaceMethodWithOneArgScalar = `
(function %name%S(value) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), value));
        }
    }
    return this;
})
`;
	  var inplaceMethodWithOneArgMatrix = `
(function %name%M(matrix) {
    matrix = this.constructor.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
        this.columns !== matrix.columns) {
        throw new RangeError('Matrices dimensions must be equal');
    }
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));
        }
    }
    return this;
})
`;

	  var inplaceMethodWithOneArg = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;

	  var staticMethodWithOneArg = staticMethodWithArgs;

	  var operators = [
	    // Arithmetic operators
	    ['+', 'add'],
	    ['-', 'sub', 'subtract'],
	    ['*', 'mul', 'multiply'],
	    ['/', 'div', 'divide'],
	    ['%', 'mod', 'modulus'],
	    // Bitwise operators
	    ['&', 'and'],
	    ['|', 'or'],
	    ['^', 'xor'],
	    ['<<', 'leftShift'],
	    ['>>', 'signPropagatingRightShift'],
	    ['>>>', 'rightShift', 'zeroFillRightShift']
	  ];

	  var i;
	  var eval2 = eval; // eslint-disable-line no-eval
	  for (var operator of operators) {
	    var inplaceOp = eval2(fillTemplateFunction(inplaceOperator, { name: operator[1], op: operator[0] }));
	    var inplaceOpS = eval2(fillTemplateFunction(inplaceOperatorScalar, { name: `${operator[1]}S`, op: operator[0] }));
	    var inplaceOpM = eval2(fillTemplateFunction(inplaceOperatorMatrix, { name: `${operator[1]}M`, op: operator[0] }));
	    var staticOp = eval2(fillTemplateFunction(staticOperator, { name: operator[1] }));
	    for (i = 1; i < operator.length; i++) {
	      Matrix.prototype[operator[i]] = inplaceOp;
	      Matrix.prototype[`${operator[i]}S`] = inplaceOpS;
	      Matrix.prototype[`${operator[i]}M`] = inplaceOpM;
	      Matrix[operator[i]] = staticOp;
	    }
	  }

	  var methods = [['~', 'not']];

	  [
	    'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil',
	    'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p',
	    'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'
	  ].forEach(function (mathMethod) {
	    methods.push([`Math.${mathMethod}`, mathMethod]);
	  });

	  for (var method of methods) {
	    var inplaceMeth = eval2(fillTemplateFunction(inplaceMethod, { name: method[1], method: method[0] }));
	    var staticMeth = eval2(fillTemplateFunction(staticMethod, { name: method[1] }));
	    for (i = 1; i < method.length; i++) {
	      Matrix.prototype[method[i]] = inplaceMeth;
	      Matrix[method[i]] = staticMeth;
	    }
	  }

	  var methodsWithArgs = [['Math.pow', 1, 'pow']];

	  for (var methodWithArg of methodsWithArgs) {
	    var args = 'arg0';
	    for (i = 1; i < methodWithArg[1]; i++) {
	      args += `, arg${i}`;
	    }
	    if (methodWithArg[1] !== 1) {
	      var inplaceMethWithArgs = eval2(fillTemplateFunction(inplaceMethodWithArgs, {
	        name: methodWithArg[2],
	        method: methodWithArg[0],
	        args: args
	      }));
	      var staticMethWithArgs = eval2(fillTemplateFunction(staticMethodWithArgs, { name: methodWithArg[2], args: args }));
	      for (i = 2; i < methodWithArg.length; i++) {
	        Matrix.prototype[methodWithArg[i]] = inplaceMethWithArgs;
	        Matrix[methodWithArg[i]] = staticMethWithArgs;
	      }
	    } else {
	      var tmplVar = {
	        name: methodWithArg[2],
	        args: args,
	        method: methodWithArg[0]
	      };
	      var inplaceMethod2 = eval2(fillTemplateFunction(inplaceMethodWithOneArg, tmplVar));
	      var inplaceMethodS = eval2(fillTemplateFunction(inplaceMethodWithOneArgScalar, tmplVar));
	      var inplaceMethodM = eval2(fillTemplateFunction(inplaceMethodWithOneArgMatrix, tmplVar));
	      var staticMethod2 = eval2(fillTemplateFunction(staticMethodWithOneArg, tmplVar));
	      for (i = 2; i < methodWithArg.length; i++) {
	        Matrix.prototype[methodWithArg[i]] = inplaceMethod2;
	        Matrix.prototype[`${methodWithArg[i]}M`] = inplaceMethodM;
	        Matrix.prototype[`${methodWithArg[i]}S`] = inplaceMethodS;
	        Matrix[methodWithArg[i]] = staticMethod2;
	      }
	    }
	  }

	  function fillTemplateFunction(template, values) {
	    for (var value in values) {
	      template = template.replace(new RegExp(`%${value}%`, 'g'), values[value]);
	    }
	    return template;
	  }

	  return Matrix;
	}

	class Matrix extends AbstractMatrix(Array) {
	  constructor(nRows, nColumns) {
	    var i;
	    if (arguments.length === 1 && typeof nRows === 'number') {
	      return new Array(nRows);
	    }
	    if (Matrix.isMatrix(nRows)) {
	      return nRows.clone();
	    } else if (Number.isInteger(nRows) && nRows > 0) {
	      // Create an empty matrix
	      super(nRows);
	      if (Number.isInteger(nColumns) && nColumns > 0) {
	        for (i = 0; i < nRows; i++) {
	          this[i] = new Array(nColumns);
	        }
	      } else {
	        throw new TypeError('nColumns must be a positive integer');
	      }
	    } else if (Array.isArray(nRows)) {
	      // Copy the values from the 2D array
	      const matrix = nRows;
	      nRows = matrix.length;
	      nColumns = matrix[0].length;
	      if (typeof nColumns !== 'number' || nColumns === 0) {
	        throw new TypeError(
	          'Data must be a 2D array with at least one element'
	        );
	      }
	      super(nRows);
	      for (i = 0; i < nRows; i++) {
	        if (matrix[i].length !== nColumns) {
	          throw new RangeError('Inconsistent array dimensions');
	        }
	        this[i] = [].concat(matrix[i]);
	      }
	    } else {
	      throw new TypeError(
	        'First argument must be a positive number or an array'
	      );
	    }
	    this.rows = nRows;
	    this.columns = nColumns;
	    return this;
	  }

	  set(rowIndex, columnIndex, value) {
	    this[rowIndex][columnIndex] = value;
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this[rowIndex][columnIndex];
	  }

	  /**
	   * Removes a row from the given index
	   * @param {number} index - Row index
	   * @return {Matrix} this
	   */
	  removeRow(index) {
	    checkRowIndex(this, index);
	    if (this.rows === 1) {
	      throw new RangeError('A matrix cannot have less than one row');
	    }
	    this.splice(index, 1);
	    this.rows -= 1;
	    return this;
	  }

	  /**
	   * Adds a row at the given index
	   * @param {number} [index = this.rows] - Row index
	   * @param {Array|Matrix} array - Array or vector
	   * @return {Matrix} this
	   */
	  addRow(index, array) {
	    if (array === undefined) {
	      array = index;
	      index = this.rows;
	    }
	    checkRowIndex(this, index, true);
	    array = checkRowVector(this, array, true);
	    this.splice(index, 0, array);
	    this.rows += 1;
	    return this;
	  }

	  /**
	   * Removes a column from the given index
	   * @param {number} index - Column index
	   * @return {Matrix} this
	   */
	  removeColumn(index) {
	    checkColumnIndex(this, index);
	    if (this.columns === 1) {
	      throw new RangeError('A matrix cannot have less than one column');
	    }
	    for (var i = 0; i < this.rows; i++) {
	      this[i].splice(index, 1);
	    }
	    this.columns -= 1;
	    return this;
	  }

	  /**
	   * Adds a column at the given index
	   * @param {number} [index = this.columns] - Column index
	   * @param {Array|Matrix} array - Array or vector
	   * @return {Matrix} this
	   */
	  addColumn(index, array) {
	    if (typeof array === 'undefined') {
	      array = index;
	      index = this.columns;
	    }
	    checkColumnIndex(this, index, true);
	    array = checkColumnVector(this, array);
	    for (var i = 0; i < this.rows; i++) {
	      this[i].splice(index, 0, array[i]);
	    }
	    this.columns += 1;
	    return this;
	  }
	}

	class WrapperMatrix1D extends AbstractMatrix() {
	  /**
	   * @class WrapperMatrix1D
	   * @param {Array<number>} data
	   * @param {object} [options]
	   * @param {object} [options.rows = 1]
	   */
	  constructor(data, options = {}) {
	    const { rows = 1 } = options;

	    if (data.length % rows !== 0) {
	      throw new Error('the data length is not divisible by the number of rows');
	    }
	    super();
	    this.rows = rows;
	    this.columns = data.length / rows;
	    this.data = data;
	  }

	  set(rowIndex, columnIndex, value) {
	    var index = this._calculateIndex(rowIndex, columnIndex);
	    this.data[index] = value;
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    var index = this._calculateIndex(rowIndex, columnIndex);
	    return this.data[index];
	  }

	  _calculateIndex(row, column) {
	    return row * this.columns + column;
	  }

	  static get [Symbol.species]() {
	    return Matrix;
	  }
	}

	class WrapperMatrix2D extends AbstractMatrix() {
	  /**
	   * @class WrapperMatrix2D
	   * @param {Array<Array<number>>} data
	   */
	  constructor(data) {
	    super();
	    this.data = data;
	    this.rows = data.length;
	    this.columns = data[0].length;
	  }

	  set(rowIndex, columnIndex, value) {
	    this.data[rowIndex][columnIndex] = value;
	    return this;
	  }

	  get(rowIndex, columnIndex) {
	    return this.data[rowIndex][columnIndex];
	  }

	  static get [Symbol.species]() {
	    return Matrix;
	  }
	}

	/**
	 * @class QrDecomposition
	 * @link https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs
	 * @param {Matrix} value
	 */
	class QrDecomposition$$1 {
	  constructor(value) {
	    value = WrapperMatrix2D.checkMatrix(value);

	    var qr = value.clone();
	    var m = value.rows;
	    var n = value.columns;
	    var rdiag = new Array(n);
	    var i, j, k, s;

	    for (k = 0; k < n; k++) {
	      var nrm = 0;
	      for (i = k; i < m; i++) {
	        nrm = hypotenuse(nrm, qr.get(i, k));
	      }
	      if (nrm !== 0) {
	        if (qr.get(k, k) < 0) {
	          nrm = -nrm;
	        }
	        for (i = k; i < m; i++) {
	          qr.set(i, k, qr.get(i, k) / nrm);
	        }
	        qr.set(k, k, qr.get(k, k) + 1);
	        for (j = k + 1; j < n; j++) {
	          s = 0;
	          for (i = k; i < m; i++) {
	            s += qr.get(i, k) * qr.get(i, j);
	          }
	          s = -s / qr.get(k, k);
	          for (i = k; i < m; i++) {
	            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
	          }
	        }
	      }
	      rdiag[k] = -nrm;
	    }

	    this.QR = qr;
	    this.Rdiag = rdiag;
	  }

	  /**
	   * Solve a problem of least square (Ax=b) by using the QR decomposition. Useful when A is rectangular, but not working when A is singular.
	   * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
	   * var qr = QrDecomposition(A);
	   * var x = qr.solve(b);
	   * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
	   * @return {Matrix} - The vector x
	   */
	  solve(value) {
	    value = Matrix.checkMatrix(value);

	    var qr = this.QR;
	    var m = qr.rows;

	    if (value.rows !== m) {
	      throw new Error('Matrix row dimensions must agree');
	    }
	    if (!this.isFullRank()) {
	      throw new Error('Matrix is rank deficient');
	    }

	    var count = value.columns;
	    var X = value.clone();
	    var n = qr.columns;
	    var i, j, k, s;

	    for (k = 0; k < n; k++) {
	      for (j = 0; j < count; j++) {
	        s = 0;
	        for (i = k; i < m; i++) {
	          s += qr[i][k] * X[i][j];
	        }
	        s = -s / qr[k][k];
	        for (i = k; i < m; i++) {
	          X[i][j] += s * qr[i][k];
	        }
	      }
	    }
	    for (k = n - 1; k >= 0; k--) {
	      for (j = 0; j < count; j++) {
	        X[k][j] /= this.Rdiag[k];
	      }
	      for (i = 0; i < k; i++) {
	        for (j = 0; j < count; j++) {
	          X[i][j] -= X[k][j] * qr[i][k];
	        }
	      }
	    }

	    return X.subMatrix(0, n - 1, 0, count - 1);
	  }

	  /**
	   *
	   * @return {boolean}
	   */
	  isFullRank() {
	    var columns = this.QR.columns;
	    for (var i = 0; i < columns; i++) {
	      if (this.Rdiag[i] === 0) {
	        return false;
	      }
	    }
	    return true;
	  }

	  /**
	   *
	   * @return {Matrix}
	   */
	  get upperTriangularMatrix() {
	    var qr = this.QR;
	    var n = qr.columns;
	    var X = new Matrix(n, n);
	    var i, j;
	    for (i = 0; i < n; i++) {
	      for (j = 0; j < n; j++) {
	        if (i < j) {
	          X[i][j] = qr[i][j];
	        } else if (i === j) {
	          X[i][j] = this.Rdiag[i];
	        } else {
	          X[i][j] = 0;
	        }
	      }
	    }
	    return X;
	  }

	  /**
	   *
	   * @return {Matrix}
	   */
	  get orthogonalMatrix() {
	    var qr = this.QR;
	    var rows = qr.rows;
	    var columns = qr.columns;
	    var X = new Matrix(rows, columns);
	    var i, j, k, s;

	    for (k = columns - 1; k >= 0; k--) {
	      for (i = 0; i < rows; i++) {
	        X[i][k] = 0;
	      }
	      X[k][k] = 1;
	      for (j = k; j < columns; j++) {
	        if (qr[k][k] !== 0) {
	          s = 0;
	          for (i = k; i < rows; i++) {
	            s += qr[i][k] * X[i][j];
	          }

	          s = -s / qr[k][k];

	          for (i = k; i < rows; i++) {
	            X[i][j] += s * qr[i][k];
	          }
	        }
	      }
	    }
	    return X;
	  }
	}

	/**
	 * Computes the inverse of a Matrix
	 * @param {Matrix} matrix
	 * @param {boolean} [useSVD=false]
	 * @return {Matrix}
	 */
	function inverse$$1(matrix, useSVD = false) {
	  matrix = WrapperMatrix2D.checkMatrix(matrix);
	  if (useSVD) {
	    return new SingularValueDecomposition$$1(matrix).inverse();
	  } else {
	    return solve$$1(matrix, Matrix.eye(matrix.rows));
	  }
	}

	/**
	 *
	 * @param {Matrix} leftHandSide
	 * @param {Matrix} rightHandSide
	 * @param {boolean} [useSVD = false]
	 * @return {Matrix}
	 */
	function solve$$1(leftHandSide, rightHandSide, useSVD = false) {
	  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
	  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
	  if (useSVD) {
	    return new SingularValueDecomposition$$1(leftHandSide).solve(rightHandSide);
	  } else {
	    return leftHandSide.isSquare()
	      ? new LuDecomposition$$1(leftHandSide).solve(rightHandSide)
	      : new QrDecomposition$$1(leftHandSide).solve(rightHandSide);
	  }
	}

	/**
	 * @class CholeskyDecomposition
	 * @link https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs
	 * @param {Matrix} value
	 */
	class CholeskyDecomposition$$1 {
	  constructor(value) {
	    value = WrapperMatrix2D.checkMatrix(value);
	    if (!value.isSymmetric()) {
	      throw new Error('Matrix is not symmetric');
	    }

	    var a = value;
	    var dimension = a.rows;
	    var l = new Matrix(dimension, dimension);
	    var positiveDefinite = true;
	    var i, j, k;

	    for (j = 0; j < dimension; j++) {
	      var Lrowj = l[j];
	      var d = 0;
	      for (k = 0; k < j; k++) {
	        var Lrowk = l[k];
	        var s = 0;
	        for (i = 0; i < k; i++) {
	          s += Lrowk[i] * Lrowj[i];
	        }
	        Lrowj[k] = s = (a.get(j, k) - s) / l[k][k];
	        d = d + s * s;
	      }

	      d = a.get(j, j) - d;

	      positiveDefinite &= d > 0;
	      l[j][j] = Math.sqrt(Math.max(d, 0));
	      for (k = j + 1; k < dimension; k++) {
	        l[j][k] = 0;
	      }
	    }

	    if (!positiveDefinite) {
	      throw new Error('Matrix is not positive definite');
	    }

	    this.L = l;
	  }

	  /**
	   *
	   * @param {Matrix} value
	   * @return {Matrix}
	   */
	  solve(value) {
	    value = WrapperMatrix2D.checkMatrix(value);

	    var l = this.L;
	    var dimension = l.rows;

	    if (value.rows !== dimension) {
	      throw new Error('Matrix dimensions do not match');
	    }

	    var count = value.columns;
	    var B = value.clone();
	    var i, j, k;

	    for (k = 0; k < dimension; k++) {
	      for (j = 0; j < count; j++) {
	        for (i = 0; i < k; i++) {
	          B[k][j] -= B[i][j] * l[k][i];
	        }
	        B[k][j] /= l[k][k];
	      }
	    }

	    for (k = dimension - 1; k >= 0; k--) {
	      for (j = 0; j < count; j++) {
	        for (i = k + 1; i < dimension; i++) {
	          B[k][j] -= B[i][j] * l[i][k];
	        }
	        B[k][j] /= l[k][k];
	      }
	    }

	    return B;
	  }

	  /**
	   *
	   * @return {Matrix}
	   */
	  get lowerTriangularMatrix() {
	    return this.L;
	  }
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var func = Symbol('func');
	var validate = Symbol('validate');

	var symbols$1 = {
		func: func,
		validate: validate
	};

	const { func: func$1 } = symbols$1;

	const numberPredicates = {
	  positive: (value) => (value > 0),
	  negative: (value) => (value < 0),
	  nonNegative: (value) => (value >= 0),
	  integer: (value) => (value === (value | 0)),

	  [func$1]: {
	    is: (fn) => fn,
	    eq: (v) => (value) => (value === v),
	    gt: (v) => (value) => (value > v),
	    gte: (v) => (value) => (value >= v),
	    lt: (v) => (value) => (value < v),
	    lte: (v) => (value) => (value <= v)
	  }
	};

	var number$4 = {
	  predicates: numberPredicates,
	  validator: (value) => {
	    return typeof value === 'number'
	  }
	};

	const { func: func$2 } = symbols$1;

	const stringPredicates = {
	  empty: (value) => (value === ''),
	  nonEmpty: (value) => (value !== ''),

	  [func$2]: {
	    is: (fn) => fn,
	    eq: (v) => (value) => (value === v),
	    length: (v) => (value) => (value.length === v),
	    minLength: (v) => (value) => (value.length >= v),
	    maxLength: (v) => (value) => (value.length <= v),
	    matches: (v) => (value) => v.test(value),
	    startsWith: (v) => (value) => value.startsWith(v),
	    endsWith: (v) => (value) => value.endsWith(v)
	  }
	};

	var string = {
	  predicates: stringPredicates,
	  validator: (value) => {
	    return typeof value === 'string'
	  }
	};

	const { func: func$3 } = symbols$1;

	const objectPredicates = {
	  plain: (value) => {
	    if (typeof value !== 'object') return false

	    const proto = Object.getPrototypeOf(value);
	    return proto === null || proto === Object.getPrototypeOf({})
	  },
	  empty: (value) => Object.keys(value).length === 0,
	  nonEmpty: (value) => Object.keys(value).length > 0,

	  [func$3]: {
	    is: (fn) => fn,
	    instanceOf: (v) => (value) => (value instanceof v)
	  }
	};

	var object$2 = {
	  predicates: objectPredicates,
	  validator: (value) => {
	    return typeof value === 'object'
	  }
	};

	var owLite = createCommonjsModule(function (module) {






	const typePredicates = {
	  number: number$4,
	  string,
	  object: object$2
	};

	const createOw = ({
	  validators = [],
	  predicates = typePredicates,
	  type = null
	} = { }) => {
	  const ow = new Proxy(function () { }, {
	    get: (obj, key) => {
	      if (key === symbols$1.validate) {
	        return (value, label = 'argument') => {
	          if (!type) {
	            return new Error('missing required type specifier')
	          }

	          for (let i = 0; i < validators.length; ++i) {
	            const validator = validators[i];
	            const result = validator.fn(value);

	            if (!result) {
	              if (i === 0) {
	                throw new Error(`Expected ${label} \`${value}\` to be of type \`${type}\`, but received type \`${typeof value}\``)
	              } else {
	                throw new Error(`Expected ${type} \`${label}\` \`${value}\` failed predicate \`${validator.key}\``)
	              }
	            }
	          }
	        }
	      }

	      const predicate = predicates[key];

	      if (predicate) {
	        if (typeof predicate === 'function') {
	          validators.push({
	            key,
	            fn: predicate
	          });

	          return ow
	        } else {
	          return createOw({
	            type: key,
	            validators: [
	              {
	                key,
	                fn: predicate.validator
	              }
	            ],
	            predicates: predicate.predicates
	          })
	        }
	      } else {
	        const fn = predicates[symbols$1.func] && predicates[symbols$1.func][key];

	        if (fn) {
	          return new Proxy(function () { }, {
	            get: () => {
	              throw new Error(`invalid use of functional predicate "${key}"`)
	            },

	            apply: (obj, thisArg, args) => {
	              validators.push({
	                key,
	                fn: fn(...args)
	              });

	              return ow
	            }
	          })
	        } else {
	          if (key === 'default' || key === '__esModule') {
	            return ow
	          }

	          return ow
	          // throw new Error(`unrecognized predicate "${key}"`)
	        }
	      }
	    },

	    apply: (obj, thisArg, args) => {
	      if (args.length !== 2 && args.length !== 3) {
	        throw new Error('invalid number of arguments to "ow"')
	      } else {
	        args[1][symbols$1.validate](args[0], args[2]);
	      }
	    }
	  });

	  return ow
	};

	module.exports = createOw();
	});

	unwrapExports(owLite);

	var rng = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var RNG = function () {
	  function RNG() {
	    _classCallCheck(this, RNG);
	  }

	  _createClass(RNG, [{
	    key: 'next',
	    value: function next() {
	      throw new Error('RNG.next must be overridden');
	    }
	  }, {
	    key: 'seed',
	    value: function seed(_seed, opts) {
	      throw new Error('RNG.seed must be overridden');
	    }
	  }, {
	    key: 'clone',
	    value: function clone(seed, opts) {
	      throw new Error('RNG.clone must be overridden');
	    }
	  }, {
	    key: '_seed',
	    value: function _seed(seed, opts) {
	      // TODO: add entropy and stuff

	      if (seed === (seed | 0)) {
	        return seed;
	      } else {
	        var strSeed = '' + seed;
	        var s = 0;

	        for (var k = 0; k < strSeed.length; ++k) {
	          s ^= strSeed.charCodeAt(k) | 0;
	        }

	        return s;
	      }
	    }
	  }, {
	    key: 'name',
	    get: function get() {
	      throw new Error('RNG.name must be overridden');
	    }
	  }]);

	  return RNG;
	}();

	exports.default = RNG;

	});

	unwrapExports(rng);

	var xor128 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



	var _rng2 = _interopRequireDefault(rng);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var RNGXOR128 = function (_RNG) {
	  _inherits(RNGXOR128, _RNG);

	  function RNGXOR128(seed, opts) {
	    _classCallCheck(this, RNGXOR128);

	    var _this = _possibleConstructorReturn(this, (RNGXOR128.__proto__ || Object.getPrototypeOf(RNGXOR128)).call(this));

	    _this.x = 0;
	    _this.y = 0;
	    _this.z = 0;
	    _this.w = 0;

	    _this.seed(seed, opts);
	    return _this;
	  }

	  _createClass(RNGXOR128, [{
	    key: 'next',
	    value: function next() {
	      var t = this.x ^ this.x << 1;
	      this.x = this.y;
	      this.y = this.z;
	      this.z = this.w;
	      this.w = this.w ^ (this.w >>> 19 ^ t ^ t >>> 8);
	      return (this.w >>> 0) / 0x100000000;
	    }
	  }, {
	    key: 'seed',
	    value: function seed(_seed, opts) {
	      // this._rng = seedrandom(this._seed(seed, opts))

	      this.x = this._seed(_seed, opts);

	      // discard an initial batch of 64 values
	      for (var i = 0; i < 64; ++i) {
	        this.next();
	      }
	    }
	  }, {
	    key: 'clone',
	    value: function clone(seed, opts) {
	      return new RNGXOR128(seed, opts);
	    }
	  }, {
	    key: 'name',
	    get: function get() {
	      return 'xor128';
	    }
	  }]);

	  return RNGXOR128;
	}(_rng2.default);

	exports.default = RNGXOR128;

	});

	unwrapExports(xor128);

	var _function = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



	var _owLite2 = _interopRequireDefault(owLite);



	var _rng2 = _interopRequireDefault(rng);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var RNGFunction = function (_RNG) {
	  _inherits(RNGFunction, _RNG);

	  function RNGFunction(seed, opts) {
	    _classCallCheck(this, RNGFunction);

	    var _this = _possibleConstructorReturn(this, (RNGFunction.__proto__ || Object.getPrototypeOf(RNGFunction)).call(this));

	    _this.seed(seed, opts);
	    return _this;
	  }

	  _createClass(RNGFunction, [{
	    key: 'next',
	    value: function next() {
	      return this._rng();
	    }
	  }, {
	    key: 'seed',
	    value: function seed(_seed) {
	      (0, _owLite2.default)(_seed, _owLite2.default.function);
	      this._rng = _seed;
	    }
	  }, {
	    key: 'clone',
	    value: function clone(seed, opts) {
	      return new RNGFunction(seed, opts);
	    }
	  }, {
	    key: 'name',
	    get: function get() {
	      return 'function';
	    }
	  }]);

	  return RNGFunction;
	}(_rng2.default);

	exports.default = RNGFunction;

	});

	unwrapExports(_function);

	var mathRandom = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



	var _rng2 = _interopRequireDefault(rng);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var RNGMathRandom = function (_RNG) {
	  _inherits(RNGMathRandom, _RNG);

	  function RNGMathRandom() {
	    _classCallCheck(this, RNGMathRandom);

	    return _possibleConstructorReturn(this, (RNGMathRandom.__proto__ || Object.getPrototypeOf(RNGMathRandom)).apply(this, arguments));
	  }

	  _createClass(RNGMathRandom, [{
	    key: 'next',
	    value: function next() {
	      return Math.random();
	    }
	  }, {
	    key: 'seed',
	    value: function seed(_seed, opts) {
	      // intentionally empty
	    }
	  }, {
	    key: 'clone',
	    value: function clone() {
	      return new RNGMathRandom();
	    }
	  }, {
	    key: 'name',
	    get: function get() {
	      return 'default';
	    }
	  }]);

	  return RNGMathRandom;
	}(_rng2.default);

	exports.default = RNGMathRandom;

	});

	unwrapExports(mathRandom);

	var rngFactory = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



	var _rng2 = _interopRequireDefault(rng);



	var _xor2 = _interopRequireDefault(xor128);



	var _function2 = _interopRequireDefault(_function);



	var _mathRandom2 = _interopRequireDefault(mathRandom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var PRNG_BUILTINS = {
	  // TODO: add more prng from C++11 lib
	  'xor128': _xor2.default,
	  'function': _function2.default,
	  'default': _mathRandom2.default
	};

	exports.default = function () {
	  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  var _args$ = args[0],
	      arg0 = _args$ === undefined ? 'default' : _args$,
	      rest = args.slice(1);


	  switch (typeof arg0 === 'undefined' ? 'undefined' : _typeof(arg0)) {
	    case 'object':
	      if (arg0 instanceof _rng2.default) {
	        return arg0;
	      }
	      break;

	    case 'function':
	      return new _function2.default(arg0);

	    case 'string':
	      var PRNG = PRNG_BUILTINS[arg0];
	      if (PRNG) {
	        return new (Function.prototype.bind.apply(PRNG, [null].concat(_toConsumableArray(rest))))();
	      }
	      break;
	  }

	  throw new Error('invalid RNG "' + arg0 + '"');
	};

	});

	unwrapExports(rngFactory);

	var uniform$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (random, min, max) {
	  if (max === undefined) {
	    max = min === undefined ? 1 : min;
	    min = 0;
	  }

	  (0, _owLite2.default)(min, _owLite2.default.number);
	  (0, _owLite2.default)(max, _owLite2.default.number);

	  return function () {
	    return random.next() * (max - min) + min;
	  };
	};

	});

	unwrapExports(uniform$1);

	var uniformInt = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (random, min, max) {
	  if (max === undefined) {
	    max = min === undefined ? 1 : min;
	    min = 0;
	  }

	  (0, _owLite2.default)(min, _owLite2.default.number.integer);
	  (0, _owLite2.default)(max, _owLite2.default.number.integer);

	  return function () {
	    return random.next() * (max - min + 1) + min | 0;
	  };
	};

	});

	unwrapExports(uniformInt);

	var uniformBoolean = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (random) {
	  return function () {
	    return random.next() >= 0.5;
	  };
	};

	});

	unwrapExports(uniformBoolean);

	var normal$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (random) {
	  var mu = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  var sigma = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

	  (0, _owLite2.default)(mu, _owLite2.default.number);
	  (0, _owLite2.default)(sigma, _owLite2.default.number);

	  return function () {
	    var x = void 0,
	        y = void 0,
	        r = void 0;

	    do {
	      x = random.next() * 2 - 1;
	      y = random.next() * 2 - 1;
	      r = x * x + y * y;
	    } while (!r || r > 1);

	    return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
	  };
	};

	});

	unwrapExports(normal$1);

	var logNormal$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (random) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }

	  var normal = random.normal.apply(random, args);

	  return function () {
	    return Math.exp(normal());
	  };
	};

	});

	unwrapExports(logNormal$1);

	var bernoulli = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (random) {
	  var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

	  (0, _owLite2.default)(p, _owLite2.default.number.greaterThan(0).lessThan(1));

	  return function () {
	    return random.next() + p | 0;
	  };
	};

	});

	unwrapExports(bernoulli);

	var binomial = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (random) {
	  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;

	  (0, _owLite2.default)(n, _owLite2.default.number.positive.integer);
	  (0, _owLite2.default)(p, _owLite2.default.number.greaterThanOrEqual(0).lessThanOrEqual(1));

	  return function () {
	    var i = 0;
	    var x = 0;

	    while (i++ < n) {
	      x += random.next() < p;
	    }

	    return x;
	  };
	};

	});

	unwrapExports(binomial);

	var geometric = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (random) {
	  var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

	  (0, _owLite2.default)(p, _owLite2.default.number.greaterThan(0).lessThanOrEqual(1));
	  var invLogP = 1.0 / Math.log(1.0 - p);

	  return function () {
	    return 1 + Math.log(random.next()) * invLogP | 0;
	  };
	};

	});

	unwrapExports(geometric);

	var poisson = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var logFactorialTable = [0.0, 0.0, 0.69314718055994529, 1.7917594692280550, 3.1780538303479458, 4.7874917427820458, 6.5792512120101012, 8.5251613610654147, 10.604602902745251, 12.801827480081469];

	var logFactorial = function logFactorial(k) {
	  return logFactorialTable[k];
	};

	var logSqrt2PI = 0.91893853320467267;

	exports.default = function (random) {
	  var lambda = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	  (0, _owLite2.default)(lambda, _owLite2.default.number.positive);

	  if (lambda < 10) {
	    // inversion method
	    var expMean = Math.exp(-lambda);

	    return function () {
	      var p = expMean;
	      var x = 0;
	      var u = random.next();

	      while (u > p) {
	        u = u - p;
	        p = lambda * p / ++x;
	      }

	      return x;
	    };
	  } else {
	    // generative method
	    var smu = Math.sqrt(lambda);
	    var b = 0.931 + 2.53 * smu;
	    var a = -0.059 + 0.02483 * b;
	    var invAlpha = 1.1239 + 1.1328 / (b - 3.4);
	    var vR = 0.9277 - 3.6224 / (b - 2);

	    return function () {
	      while (true) {
	        var u = void 0;
	        var v = random.next();

	        if (v <= 0.86 * vR) {
	          u = v / vR - 0.43;
	          return Math.floor((2 * a / (0.5 - Math.abs(u)) + b) * u + lambda + 0.445);
	        }

	        if (v >= vR) {
	          u = random.next() - 0.5;
	        } else {
	          u = v / vR - 0.93;
	          u = (u < 0 ? -0.5 : 0.5) - u;
	          v = random.next() * vR;
	        }

	        var us = 0.5 - Math.abs(u);
	        if (us < 0.013 && v > us) {
	          continue;
	        }

	        var k = Math.floor((2 * a / us + b) * u + lambda + 0.445) | 0;
	        v = v * invAlpha / (a / (us * us) + b);

	        if (k >= 10) {
	          var t = (k + 0.5) * Math.log(lambda / k) - lambda - logSqrt2PI + k - (1 / 12.0 - (1 / 360.0 - 1 / (1260.0 * k * k)) / (k * k)) / k;

	          if (Math.log(v * smu) <= t) {
	            return k;
	          }
	        } else if (k >= 0) {
	          if (Math.log(v) <= k * Math.log(lambda) - lambda - logFactorial(k)) {
	            return k;
	          }
	        }
	      }
	    };
	  }
	};

	});

	unwrapExports(poisson);

	var exponential$2 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (random) {
	  var lambda = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	  (0, _owLite2.default)(lambda, _owLite2.default.number.positive);

	  return function () {
	    return -Math.log(1 - random.next()) / lambda;
	  };
	};

	});

	unwrapExports(exponential$2);

	var irwinHall$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (random, n) {
	  (0, _owLite2.default)(n, _owLite2.default.number.integer.greaterThanOrEqual(0));

	  return function () {
	    var sum = 0;
	    for (var i = 0; i < n; ++i) {
	      sum += random.next();
	    }

	    return sum;
	  };
	};

	});

	unwrapExports(irwinHall$1);

	var bates$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (random, n) {
	  (0, _owLite2.default)(n, _owLite2.default.number.integer.positive);
	  var irwinHall = random.irwinHall(n);

	  return function () {
	    return irwinHall() / n;
	  };
	};

	});

	unwrapExports(bates$1);

	var pareto = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});



	var _owLite2 = _interopRequireDefault(owLite);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (random, alpha) {
	  (0, _owLite2.default)(alpha, _owLite2.default.number.greaterThanOrEqual(0));
	  var invAlpha = 1.0 / alpha;

	  return function () {
	    return 1.0 / Math.pow(1.0 - random.next(), invAlpha);
	  };
	};

	});

	unwrapExports(pareto);

	var random = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



	var _owLite2 = _interopRequireDefault(owLite);



	var _rng3 = _interopRequireDefault(rng);



	var _rngFactory2 = _interopRequireDefault(rngFactory);



	var _uniform3 = _interopRequireDefault(uniform$1);



	var _uniformInt3 = _interopRequireDefault(uniformInt);



	var _uniformBoolean3 = _interopRequireDefault(uniformBoolean);



	var _normal3 = _interopRequireDefault(normal$1);



	var _logNormal3 = _interopRequireDefault(logNormal$1);



	var _bernoulli3 = _interopRequireDefault(bernoulli);



	var _binomial3 = _interopRequireDefault(binomial);



	var _geometric3 = _interopRequireDefault(geometric);



	var _poisson3 = _interopRequireDefault(poisson);



	var _exponential3 = _interopRequireDefault(exponential$2);



	var _irwinHall3 = _interopRequireDefault(irwinHall$1);



	var _bates3 = _interopRequireDefault(bates$1);



	var _pareto3 = _interopRequireDefault(pareto);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Seedable random number generator supporting many common distributions.
	 *
	 * Defaults to Math.random as its underlying pseudorandom number generator.
	 *
	 * @name Random
	 * @class
	 *
	 * @param {RNG|function} [rng=Math.random] - Underlying pseudorandom number generator.
	 */
	var Random = function () {
	  function Random(rng$$1) {
	    _classCallCheck(this, Random);

	    if (rng$$1) (0, _owLite2.default)(rng$$1, _owLite2.default.object.instanceOf(_rng3.default));

	    this._cache = {};
	    this.use(rng$$1);
	  }

	  /**
	   * @member {RNG} Underlying pseudo-random number generator
	   */


	  _createClass(Random, [{
	    key: 'clone',


	    /**
	     * Creates a new `Random` instance, optionally specifying parameters to
	     * set a new seed.
	     *
	     * @see RNG.clone
	     *
	     * @param {string} [seed] - Optional seed for new RNG.
	     * @param {object} [opts] - Optional config for new RNG options.
	     * @return {Random}
	     */
	    value: function clone() {
	      var _rng;

	      return new Random((_rng = this.rng).clone.apply(_rng, arguments));
	    }

	    /**
	     * Sets the underlying pseudorandom number generator used via
	     * either an instance of `seedrandom`, a custom instance of RNG
	     * (for PRNG plugins), or a string specifying the PRNG to use
	     * along with an optional `seed` and `opts` to initialize the
	     * RNG.
	     *
	     * @example
	     * const random = require('random')
	     *
	     * random.use('xor128', 'foobar')
	     * // or
	     * random.use(seedrandom('kittens'))
	     * // or
	     * random.use(Math.random)
	     *
	     * @param {...*} args
	     */

	  }, {
	    key: 'use',
	    value: function use() {
	      this._rng = _rngFactory2.default.apply(undefined, arguments);
	    }

	    /**
	     * Patches `Math.random` with this Random instance's PRNG.
	     */

	  }, {
	    key: 'patch',
	    value: function patch() {
	      if (this._patch) {
	        throw new Error('Math.random already patched');
	      }

	      this._patch = Math.random;
	      Math.random = this.uniform();
	    }

	    /**
	     * Restores a previously patched `Math.random` to its original value.
	     */

	  }, {
	    key: 'unpatch',
	    value: function unpatch() {
	      if (this._patch) {
	        Math.random = this._patch;
	        delete this._patch;
	      }
	    }

	    // --------------------------------------------------------------------------
	    // Uniform utility functions
	    // --------------------------------------------------------------------------

	    /**
	     * Convenience wrapper around `this.rng.next()`
	     *
	     * Returns a floating point number in [0, 1).
	     *
	     * @return {number}
	     */

	  }, {
	    key: 'next',
	    value: function next() {
	      return this._rng.next();
	    }

	    /**
	     * Samples a uniform random floating point number, optionally specifying
	     * lower and upper bounds.
	     *
	     * Convence wrapper around `random.uniform()`
	     *
	     * @param {number} [min=0] - Lower bound (float, inclusive)
	     * @param {number} [max=1] - Upper bound (float, exclusive)
	     * @return {number}
	     */

	  }, {
	    key: 'float',
	    value: function float(min, max) {
	      return this.uniform(min, max)();
	    }

	    /**
	     * Samples a uniform random integer, optionally specifying lower and upper
	     * bounds.
	     *
	     * Convence wrapper around `random.uniformInt()`
	     *
	     * @param {number} [min=0] - Lower bound (integer, inclusive)
	     * @param {number} [max=1] - Upper bound (integer, inclusive)
	     * @return {number}
	     */

	  }, {
	    key: 'int',
	    value: function int(min, max) {
	      return this.uniformInt(min, max)();
	    }

	    /**
	     * Samples a uniform random integer, optionally specifying lower and upper
	     * bounds.
	     *
	     * Convence wrapper around `random.uniformInt()`
	     *
	     * @alias `random.int`
	     *
	     * @param {number} [min=0] - Lower bound (integer, inclusive)
	     * @param {number} [max=1] - Upper bound (integer, inclusive)
	     * @return {number}
	     */

	  }, {
	    key: 'integer',
	    value: function integer(min, max) {
	      return this.uniformInt(min, max)();
	    }

	    /**
	     * Samples a uniform random boolean value.
	     *
	     * Convence wrapper around `random.uniformBoolean()`
	     *
	     * @alias `random.boolean`
	     *
	     * @return {boolean}
	     */

	  }, {
	    key: 'bool',
	    value: function bool() {
	      return this.uniformBoolean()();
	    }

	    /**
	     * Samples a uniform random boolean value.
	     *
	     * Convence wrapper around `random.uniformBoolean()`
	     *
	     * @return {boolean}
	     */

	  }, {
	    key: 'boolean',
	    value: function boolean() {
	      return this.uniformBoolean()();
	    }

	    // --------------------------------------------------------------------------
	    // Uniform distributions
	    // --------------------------------------------------------------------------

	    /**
	     * Generates a [Continuous uniform distribution](https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)).
	     *
	     * @param {number} [min=0] - Lower bound (float, inclusive)
	     * @param {number} [max=1] - Upper bound (float, exclusive)
	     * @return {function}
	     */

	  }, {
	    key: 'uniform',
	    value: function uniform(min, max) {
	      return this._memoize('uniform', _uniform3.default, min, max);
	    }

	    /**
	     * Generates a [Discrete uniform distribution](https://en.wikipedia.org/wiki/Discrete_uniform_distribution).
	     *
	     * @param {number} [min=0] - Lower bound (integer, inclusive)
	     * @param {number} [max=1] - Upper bound (integer, inclusive)
	     * @return {function}
	     */

	  }, {
	    key: 'uniformInt',
	    value: function uniformInt$$1(min, max) {
	      return this._memoize('uniformInt', _uniformInt3.default, min, max);
	    }

	    /**
	     * Generates a [Discrete uniform distribution](https://en.wikipedia.org/wiki/Discrete_uniform_distribution),
	     * with two possible outcomes, `true` or `false.
	     *
	     * This method is analogous to flipping a coin.
	     *
	     * @return {function}
	     */

	  }, {
	    key: 'uniformBoolean',
	    value: function uniformBoolean$$1() {
	      return this._memoize('uniformBoolean', _uniformBoolean3.default);
	    }

	    // --------------------------------------------------------------------------
	    // Normal distributions
	    // --------------------------------------------------------------------------

	    /**
	     * Generates a [Normal distribution](https://en.wikipedia.org/wiki/Normal_distribution).
	     *
	     * @param {number} [mu=0] - Mean
	     * @param {number} [sigma=1] - Standard deviation
	     * @return {function}
	     */

	  }, {
	    key: 'normal',
	    value: function normal(mu, sigma) {
	      return (0, _normal3.default)(this, mu, sigma);
	    }

	    /**
	     * Generates a [Log-normal distribution](https://en.wikipedia.org/wiki/Log-normal_distribution).
	     *
	     * @param {number} [mu=0] - Mean of underlying normal distribution
	     * @param {number} [sigma=1] - Standard deviation of underlying normal distribution
	     * @return {function}
	     */

	  }, {
	    key: 'logNormal',
	    value: function logNormal(mu, sigma) {
	      return (0, _logNormal3.default)(this, mu, sigma);
	    }

	    // --------------------------------------------------------------------------
	    // Bernoulli distributions
	    // --------------------------------------------------------------------------

	    /**
	     * Generates a [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution).
	     *
	     * @param {number} [p=0.5] - Success probability of each trial.
	     * @return {function}
	     */

	  }, {
	    key: 'bernoulli',
	    value: function bernoulli$$1(p) {
	      return (0, _bernoulli3.default)(this, p);
	    }

	    /**
	     * Generates a [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution).
	     *
	     * @param {number} [n=1] - Number of trials.
	     * @param {number} [p=0.5] - Success probability of each trial.
	     * @return {function}
	     */

	  }, {
	    key: 'binomial',
	    value: function binomial$$1(n, p) {
	      return (0, _binomial3.default)(this, n, p);
	    }

	    /**
	     * Generates a [Geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution).
	     *
	     * @param {number} [p=0.5] - Success probability of each trial.
	     * @return {function}
	     */

	  }, {
	    key: 'geometric',
	    value: function geometric$$1(p) {
	      return (0, _geometric3.default)(this, p);
	    }

	    // --------------------------------------------------------------------------
	    // Poisson distributions
	    // --------------------------------------------------------------------------

	    /**
	     * Generates a [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution).
	     *
	     * @param {number} [lambda=1] - Mean (lambda > 0)
	     * @return {function}
	     */

	  }, {
	    key: 'poisson',
	    value: function poisson$$1(lambda) {
	      return (0, _poisson3.default)(this, lambda);
	    }

	    /**
	     * Generates an [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution).
	     *
	     * @param {number} [lambda=1] - Inverse mean (lambda > 0)
	     * @return {function}
	     */

	  }, {
	    key: 'exponential',
	    value: function exponential(lambda) {
	      return (0, _exponential3.default)(this, lambda);
	    }

	    // --------------------------------------------------------------------------
	    // Misc distributions
	    // --------------------------------------------------------------------------

	    /**
	     * Generates an [Irwin Hall distribution](https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution).
	     *
	     * @param {number} n - Number of uniform samples to sum (n >= 0)
	     * @return {function}
	     */

	  }, {
	    key: 'irwinHall',
	    value: function irwinHall(n) {
	      return (0, _irwinHall3.default)(this, n);
	    }

	    /**
	     * Generates a [Bates distribution](https://en.wikipedia.org/wiki/Bates_distribution).
	     *
	     * @param {number} n - Number of uniform samples to average (n >= 1)
	     * @return {function}
	     */

	  }, {
	    key: 'bates',
	    value: function bates(n) {
	      return (0, _bates3.default)(this, n);
	    }

	    /**
	     * Generates a [Pareto distribution](https://en.wikipedia.org/wiki/Pareto_distribution).
	     *
	     * @param {number} alpha - Alpha
	     * @return {function}
	     */

	  }, {
	    key: 'pareto',
	    value: function pareto$$1(alpha) {
	      return (0, _pareto3.default)(this, alpha);
	    }

	    // --------------------------------------------------------------------------
	    // Internal
	    // --------------------------------------------------------------------------

	    /**
	     * Memoizes distributions to ensure they're only created when necessary.
	     *
	     * Returns a thunk which that returns independent, identically distributed
	     * samples from the specified distribution.
	     *
	     * @private
	     *
	     * @param {string} label - Name of distribution
	     * @param {function} getter - Function which generates a new distribution
	     * @param {...*} args - Distribution-specific arguments
	     *
	     * @return {function}
	     */

	  }, {
	    key: '_memoize',
	    value: function _memoize(label, getter) {
	      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	        args[_key - 2] = arguments[_key];
	      }

	      var key = '' + args.join(';');
	      var value = this._cache[label];

	      if (value === undefined || value.key !== key) {
	        value = { key: key, distribution: getter.apply(undefined, [this].concat(args)) };
	        this._cache[label] = value;
	      }

	      return value.distribution;
	    }
	  }, {
	    key: 'rng',
	    get: function get() {
	      return this._rng;
	    }
	  }]);

	  return Random;
	}();

	// defaults to Math.random as its RNG


	exports.default = new Random();

	});

	unwrapExports(random);

	var random$2 = random.default;

	var Gaussian = function () {
	  function Gaussian(mean, cov) {
	    classCallCheck(this, Gaussian);

	    // TODO: Consider saving the dimension
	    if (mean instanceof Matrix && cov instanceof Matrix) {
	      this.mean = mean;
	      this.cov = cov;
	    } else {
	      this.mean = new Matrix([mean]).transpose();
	      this.cov = new Matrix(cov);
	    }
	  }

	  createClass(Gaussian, [{
	    key: 'at',
	    value: function at(x) {
	      var diff = new Matrix([x]).transpose().sub(this.mean);
	      var n = diff.transpose().mmul(inverse$$1(this.cov)).mmul(diff).mul(-0.5).exp();
	      var d = Math.sqrt(Math.pow(2 * Math.PI, this.mean.rows) * this.cov.det());
	      return n * (1 / d);
	    }

	    // idx is the first row of b

	  }, {
	    key: 'marginalize',
	    value: function marginalize(idx) {
	      // FIXME: Rewrite with Array.slice() for speed
	      var aMean = sliceMat(this.mean, 0, 0, idx, 1);
	      var bMean = sliceMat(this.mean, idx, 0, this.mean.rows, 1);
	      var aCov = sliceMat(this.cov, 0, 0, idx, idx);
	      var bCov = sliceMat(this.cov, idx, idx, this.mean.rows, this.mean.rows);
	      return [new Gaussian(aMean, aCov), new Gaussian(bMean, bCov)];
	    }

	    // Also refer to: https://stats.stackexchange.com/questions/232959/simulating-the-posterior-of-a-gaussian-process
	    // FIXME: Currently only works with \mu_e = 0

	  }, {
	    key: 'condition',
	    value: function condition(X) {
	      var idx = X.length;
	      var x0 = new Matrix([X]).transpose();
	      var Exx = sliceMat(this.cov, 0, 0, idx, idx);
	      var Exy = sliceMat(this.cov, 0, idx, idx, this.mean.rows);
	      var Eyx = Exy.transpose();
	      var Eyy = sliceMat(this.cov, idx, idx, this.mean.rows, this.mean.rows);

	      // Compute new zero
	      var Lxx = new CholeskyDecomposition$$1(Exx).lowerTriangularMatrix;
	      var mLy = solve$$1(Lxx, x0);
	      var Lk = solve$$1(Lxx, Exy);
	      var condMean = Lk.transpose().mmul(mLy); // Hack

	      // FIXME: Make this more performant (use cholesky and slove instead of inverse)
	      var condCov = Eyy.sub(Eyx.mmul(inverse$$1(Exx)).mmul(Exy));
	      return new Gaussian(condMean, condCov);
	    }
	  }, {
	    key: 'sample',
	    value: function sample() {
	      var z = Matrix.zeros(this.mean.rows, 1);
	      var normal = random$2.normal();
	      for (var i = 0; i < this.mean.rows; ++i) {
	        z.set(i, 0, normal());
	      }var samples = Matrix.add(this.mean, this.cov.mmul(z));
	      return samples;
	    }
	  }, {
	    key: 'getMean',
	    value: function getMean() {
	      return this.mean.transpose()[0];
	    }
	  }, {
	    key: 'getSd',
	    value: function getSd() {
	      return this.cov.diag().map(function (s2) {
	        return Math.sqrt(s2);
	      });
	    }
	  }]);
	  return Gaussian;
	}();

	// ranges from [i1,i2) & [j1,j2)
	function sliceMat(mat, i1, j1, i2, j2) {
	  var result = new Matrix(i2 - i1, j2 - j1);
	  for (var i = i1; i < i2; ++i) {
	    for (var j = j1; j < j2; ++j) {
	      result.set(i - i1, j - j1, mat.get(i, j));
	    }
	  }return result;
	}

	function rbf() {
	  var sigma = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	  var l = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	  var ss2 = 2 * l * l;
	  return function (x1, x2) {
	    var sqdist = Math.pow(x1 - x2, 2);
	    return sigma * sigma * Math.exp(-sqdist / ss2);
	  };
	}

	function periodic() {
	  var sigma = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	  var l = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.4;
	  var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;

	  var l2 = l * l;
	  return function (x1, x2) {
	    var dist = Math.abs(x1 - x2, 2);
	    var sin2 = Math.pow(Math.sin(Math.PI * dist / p), 2);
	    return sigma * sigma * Math.exp(-(2 * sin2) / l2);
	  };
	}

	function linear$4() {
	  var sigma = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	  var sigmaB = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	  return function (x1, x2) {
	    return sigmaB + sigma * sigma * (x1 - c) * (x2 - c);
	  };
	}

	function combineKernels(kernels) {
	  return function (x1, x2) {
	    var results = kernels.map(function (k) {
	      return k.apply(null, [x1, x2]);
	    });
	    return results.reduce(function (acc, x) {
	      return acc * x;
	    }, 1);
	  };
	}

	function covMatrix(v, kernel) {
	  var dim = v.length;
	  var kernelMatrix = new Matrix(dim, dim);
	  for (var i = 0; i < dim; ++i) {
	    for (var j = i; j < dim; ++j) {
	      kernelMatrix[i][j] = kernelMatrix[j][i] = kernel(v[i], v[j]);
	    }
	  }
	  return kernelMatrix;
	}

	// xtrain and ytrain can be omitted to obtain the prior distribution
	function gaussianProcess(kernel, xtest, xtrain, ytrain) {
	  if (xtrain == undefined && ytrain == undefined) xtrain = [];
	  var xs = xtrain.concat(xtest);
	  var cov = covMatrix(xs, kernel);
	  var eps = Matrix.eye(xs.length).mul(1e-6);
	  cov.add(eps);
	  var mean = Matrix.zeros(xs.length, 1); // TODO: Currently assumes zero mean
	  var gp = new Gaussian(mean, cov);
	  return xs.length == xtest.length ? gp : gp.condition(ytrain);
	}

	/* src/scripts/components/Teaser.html generated by Svelte v2.9.1 */

	function mean$1(_ref) {
		var context = _ref.context;
		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1]);
		});
	}

	function sdPlus(_ref2) {
		var context = _ref2.context;
		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1] + 2 * d[2]);
		});
	}

	function sdMinus(_ref3) {
		var context = _ref3.context;
		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1] - 2 * d[2]);
		});
	}

	function sdArea(_ref4) {
		var context = _ref4.context;
		return area$3().x(function (d) {
			return context.u(d[0]);
		}).y0(function (d) {
			return context.v(d[1] - 2 * d[2]);
		}).y1(function (d) {
			return context.v(d[1] + 2 * d[2]);
		});
	}

	function curve(_ref5) {
		var context = _ref5.context,
		    trainingPoints = _ref5.trainingPoints;

		var N = 75;

		var _context$xDomain = context.xDomain(),
		    _context$xDomain2 = slicedToArray(_context$xDomain, 2),
		    xmin = _context$xDomain2[0],
		    xmax = _context$xDomain2[1];

		var step$$1 = (xmax - xmin) / N;
		var xs = sequence(xmin, xmax + step$$1, step$$1);

		// prepare training data
		var activePoints = trainingPoints.filter(function (p) {
			return p.active;
		});
		var xsTrain = activePoints.map(function (p) {
			return p.x;
		});
		var ysTrain = activePoints.map(function (p) {
			return p.y;
		});

		var process = gaussianProcess(rbf(), xs, xsTrain, ysTrain);
		//const ys = process.sample().reduce((a, b) => a.concat(b));
		var ys = process.getMean();
		var sd = process.getSd();

		return zip(xs, ys, sd);
	}

	function data() {
		return {
			trainingPoints: [{ x: -4.5, y: -4, active: true }, { x: -2, y: -7, active: false }, { x: -1, y: -1, active: false }, { x: 1, y: 4, active: false }, { x: 3, y: 7, active: true }],
			context: new Context(700, 400, [-5, 5], [-10, 10]),
			firstClick: true
		};
	}
	function toV(context, y) {
		return context.v(y);
	}
	function toU(context, x) {
		return context.u(x);
	}
	var methods = {
		toggle: function toggle(idx) {
			var _get = this.get(),
			    trainingPoints = _get.trainingPoints;

			var _get2 = this.get(),
			    firstClick = _get2.firstClick;

			trainingPoints[idx].active = !trainingPoints[idx].active;
			firstClick = false;
			this.set({ trainingPoints: trainingPoints, firstClick: firstClick });
		}
	};

	function oncreate() {
		var _get3 = this.get(),
		    curve = _get3.curve,
		    mean$$1 = _get3.mean,
		    sdPlus = _get3.sdPlus,
		    sdMinus = _get3.sdMinus,
		    sdArea = _get3.sdArea;

		var svg$$1 = select(this.refs.graph);
		svg$$1.append('path').data([curve]).attr('class', 'sdArea').attr('stroke', 'none').attr('fill', 'rgba(253,224,221,0.6').attr('d', sdArea);

		svg$$1.append('path').data([curve]).attr('class', 'curve').attr('fill', 'none').attr('stroke', '#c51b8a').attr('stroke-width', '2px').attr('d', mean$$1);

		svg$$1.append('path').data([curve]).attr('class', 'sdPlus').attr('fill', 'none').attr('stroke', '#fa9fb5').attr('stroke-width', '1px').attr('d', sdPlus);

		svg$$1.append('path').data([curve]).attr('class', 'sdMinus').attr('fill', 'none').attr('stroke', '#fa9fb5').attr('stroke-width', '1px').attr('d', sdMinus);
	}
	function onstate(_ref6) {
		var _changed = _ref6._changed,
		    current = _ref6.current,
		    _previous = _ref6._previous;

		var svg$$1 = select(this.refs.graph).transition();
		svg$$1.select('.sdArea').duration(750).attr('d', current.sdArea(current.curve));
		svg$$1.select('.curve').duration(750).attr('d', current.mean(current.curve));
		svg$$1.select('.sdPlus').duration(750).attr('d', current.sdPlus(current.curve));
		svg$$1.select('.sdMinus').duration(750).attr('d', current.sdMinus(current.curve));
	}
	function add_css() {
		var style = createElement("style");
		style.id = 'svelte-11ebxmd-style';
		style.textContent = ".svelte-ref-zero.svelte-11ebxmd{stroke:rgba(0,0,0,0.2);stroke-width:1px}.sdLine.svelte-11ebxmd{fill:none;stroke:rgba(0,0,0,0.2);stroke-width:2px;stroke-dasharray:4}.line.svelte-11ebxmd{fill:none;stroke:#c51b8a;stroke-width:2px}.inactive.svelte-11ebxmd{fill:transparent;stroke:rgba(0,0,0,0.4);stroke-dasharray:2;stroke-width:2px}.active.svelte-11ebxmd{fill:transparent;stroke:rgba(0,0,0,0.4);stroke-width:2px}";
		appendNode(style, document.head);
	}

	function create_main_fragment(component, ctx) {
		var svg$$1, g, text$$1, text_1, text_y_value, line$$1, line_y__value, line_x__value, line_y__value_1, g_1, text_2, tspan, text_3, text_4, tspan_1, text_5, tspan_2, text_6, tspan_3, text_7, text_8, text_9, tspan_4, text_10, text_11, tspan_5, text_12, tspan_6, tspan_7, text_13, text_14, svg_width_value, svg_height_value;

		var each_value = ctx.trainingPoints;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		var if_block = ctx.firstClick && create_if_block_1(component, ctx);

		return {
			c: function c() {
				svg$$1 = createSvgElement("svg");
				g = createSvgElement("g");
				text$$1 = createSvgElement("text");
				text_1 = createText("y = 0");
				line$$1 = createSvgElement("line");
				g_1 = createSvgElement("g");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_2 = createSvgElement("text");
				tspan = createSvgElement("tspan");
				text_3 = createText("Regression");
				text_4 = createText(" is used to find a function ");
				tspan_1 = createSvgElement("tspan");
				text_5 = createText("(line)");
				tspan_2 = createSvgElement("tspan");
				text_6 = createText("that represents a set of data points as closely");
				tspan_3 = createSvgElement("tspan");
				text_7 = createText("as possible");
				text_8 = createSvgElement("text");
				text_9 = createText("A ");
				tspan_4 = createSvgElement("tspan");
				text_10 = createText("Gaussian process");
				text_11 = createText(" is a probabilistic\n    ");
				tspan_5 = createSvgElement("tspan");
				text_12 = createText("method that gives a confidence");
				tspan_6 = createSvgElement("tspan");
				tspan_7 = createSvgElement("tspan");
				text_13 = createText("(shaded)");
				text_14 = createText(" for the predicted function");
				if (if_block) if_block.c();
				setAttribute(text$$1, "x", "5");
				setAttribute(text$$1, "y", text_y_value = toV(ctx.context, 0) - 5);
				setAttribute(text$$1, "class", "annotation");
				setAttribute(line$$1, "x1", "0");
				setAttribute(line$$1, "y1", line_y__value = toV(ctx.context, 0));
				setAttribute(line$$1, "x2", line_x__value = ctx.context.width);
				setAttribute(line$$1, "y2", line_y__value_1 = toV(ctx.context, 0));
				setAttribute(line$$1, "class", "svelte-11ebxmd svelte-ref-zero");
				setAttribute(tspan, "font-weight", "bold");
				setAttribute(tspan_1, "fill", "#c51b8a");
				setAttribute(tspan_2, "x", "5");
				setAttribute(tspan_2, "dy", "1.5em");
				setAttribute(tspan_3, "x", "5");
				setAttribute(tspan_3, "dy", "1.5em");
				setAttribute(text_2, "x", "5");
				setAttribute(text_2, "y", "10");
				setAttribute(text_2, "class", "annotation");
				setAttribute(tspan_4, "font-weight", "bold");
				setAttribute(tspan_5, "x", "450");
				setAttribute(tspan_5, "dy", "1.5em");
				setAttribute(tspan_7, "fill", "#fa9fb5");
				setAttribute(tspan_6, "x", "450");
				setAttribute(tspan_6, "dy", "1.5em");
				setAttribute(text_8, "x", "450");
				setAttribute(text_8, "y", "300");
				setAttribute(text_8, "class", "annotation");
				setAttribute(svg$$1, "width", svg_width_value = ctx.context.width);
				setAttribute(svg$$1, "height", svg_height_value = ctx.context.height);
			},
			m: function m(target, anchor) {
				insertNode(svg$$1, target, anchor);
				appendNode(g, svg$$1);
				appendNode(text$$1, g);
				appendNode(text_1, text$$1);
				appendNode(line$$1, g);
				component.refs.zero = line$$1;
				component.refs.graph = g;
				appendNode(g_1, svg$$1);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(g_1, null);
				}

				appendNode(text_2, svg$$1);
				appendNode(tspan, text_2);
				appendNode(text_3, tspan);
				appendNode(text_4, text_2);
				appendNode(tspan_1, text_2);
				appendNode(text_5, tspan_1);
				appendNode(tspan_2, text_2);
				appendNode(text_6, tspan_2);
				appendNode(tspan_3, text_2);
				appendNode(text_7, tspan_3);
				appendNode(text_8, svg$$1);
				appendNode(text_9, text_8);
				appendNode(tspan_4, text_8);
				appendNode(text_10, tspan_4);
				appendNode(text_11, text_8);
				appendNode(tspan_5, text_8);
				appendNode(text_12, tspan_5);
				appendNode(tspan_6, text_8);
				appendNode(tspan_7, tspan_6);
				appendNode(text_13, tspan_7);
				appendNode(text_14, tspan_6);
				if (if_block) if_block.m(svg$$1, null);
				component.refs.svgArea = svg$$1;
			},
			p: function p(changed, ctx) {
				if (changed.context && text_y_value !== (text_y_value = toV(ctx.context, 0) - 5)) {
					setAttribute(text$$1, "y", text_y_value);
				}

				if (changed.context && line_y__value !== (line_y__value = toV(ctx.context, 0))) {
					setAttribute(line$$1, "y1", line_y__value);
				}

				if (changed.context && line_x__value !== (line_x__value = ctx.context.width)) {
					setAttribute(line$$1, "x2", line_x__value);
				}

				if (changed.context && line_y__value_1 !== (line_y__value_1 = toV(ctx.context, 0))) {
					setAttribute(line$$1, "y2", line_y__value_1);
				}

				if (changed.trainingPoints || changed.context) {
					each_value = ctx.trainingPoints;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(g_1, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (ctx.firstClick) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1(component, ctx);
						if_block.c();
						if_block.m(svg$$1, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.context && svg_width_value !== (svg_width_value = ctx.context.width)) {
					setAttribute(svg$$1, "width", svg_width_value);
				}

				if (changed.context && svg_height_value !== (svg_height_value = ctx.context.height)) {
					setAttribute(svg$$1, "height", svg_height_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(svg$$1);
				}

				if (component.refs.zero === line$$1) component.refs.zero = null;
				if (component.refs.graph === g) component.refs.graph = null;

				destroyEach(each_blocks, detach);

				if (if_block) if_block.d();
				if (component.refs.svgArea === svg$$1) component.refs.svgArea = null;
			}
		};
	}

	// (7:4) {#each trainingPoints as pt, idx}
	function create_each_block(component, ctx) {
		var circle$$1, circle_class_value, circle_cx_value, circle_cy_value;

		var if_block = ctx.pt.active && create_if_block(component, ctx);

		return {
			c: function c() {
				if (if_block) if_block.c();
				circle$$1 = createSvgElement("circle");
				circle$$1._svelte = { component: component, ctx: ctx };

				addListener(circle$$1, "click", click_handler);
				setAttribute(circle$$1, "class", circle_class_value = "trainingPoint " + (ctx.pt.active ? 'active' : 'inactive') + " svelte-11ebxmd");
				setAttribute(circle$$1, "cx", circle_cx_value = toU(ctx.context, ctx.pt.x));
				setAttribute(circle$$1, "cy", circle_cy_value = toV(ctx.context, ctx.pt.y));
				setAttribute(circle$$1, "r", "6");
			},
			m: function m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insertNode(circle$$1, target, anchor);
			},
			p: function p(changed, ctx) {
				if (ctx.pt.active) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block(component, ctx);
						if_block.c();
						if_block.m(circle$$1.parentNode, circle$$1);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				circle$$1._svelte.ctx = ctx;
				if (changed.trainingPoints && circle_class_value !== (circle_class_value = "trainingPoint " + (ctx.pt.active ? 'active' : 'inactive') + " svelte-11ebxmd")) {
					setAttribute(circle$$1, "class", circle_class_value);
				}

				if ((changed.context || changed.trainingPoints) && circle_cx_value !== (circle_cx_value = toU(ctx.context, ctx.pt.x))) {
					setAttribute(circle$$1, "cx", circle_cx_value);
				}

				if ((changed.context || changed.trainingPoints) && circle_cy_value !== (circle_cy_value = toV(ctx.context, ctx.pt.y))) {
					setAttribute(circle$$1, "cy", circle_cy_value);
				}
			},
			d: function d(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(circle$$1);
				}

				removeListener(circle$$1, "click", click_handler);
			}
		};
	}

	// (8:6) {#if pt.active}
	function create_if_block(component, ctx) {
		var circle$$1, circle_cx_value, circle_cy_value;

		return {
			c: function c() {
				circle$$1 = createSvgElement("circle");
				setAttribute(circle$$1, "cx", circle_cx_value = toU(ctx.context, ctx.pt.x));
				setAttribute(circle$$1, "cy", circle_cy_value = toV(ctx.context, ctx.pt.y));
				setAttribute(circle$$1, "r", "3");
				setAttribute(circle$$1, "fill", "rgba(0,0,0,0.6)");
			},
			m: function m(target, anchor) {
				insertNode(circle$$1, target, anchor);
			},
			p: function p(changed, ctx) {
				if ((changed.context || changed.trainingPoints) && circle_cx_value !== (circle_cx_value = toU(ctx.context, ctx.pt.x))) {
					setAttribute(circle$$1, "cx", circle_cx_value);
				}

				if ((changed.context || changed.trainingPoints) && circle_cy_value !== (circle_cy_value = toV(ctx.context, ctx.pt.y))) {
					setAttribute(circle$$1, "cy", circle_cy_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(circle$$1);
				}
			}
		};
	}

	// (24:2) {#if firstClick}
	function create_if_block_1(component, ctx) {
		var text$$1, tspan, text_1, text_x_value, text_y_value;

		return {
			c: function c() {
				text$$1 = createSvgElement("text");
				tspan = createSvgElement("tspan");
				text_1 = createText("(click to enable)");
				setAttribute(tspan, "fill", "rgb(245, 181, 62)");
				setAttribute(tspan, "font-style", "italic");
				setAttribute(text$$1, "x", text_x_value = toU(ctx.context, ctx.trainingPoints[1].x) - 50);
				setAttribute(text$$1, "y", text_y_value = toV(ctx.context, ctx.trainingPoints[1].y) + 23);
				setAttribute(text$$1, "class", "annotation");
			},
			m: function m(target, anchor) {
				insertNode(text$$1, target, anchor);
				appendNode(tspan, text$$1);
				appendNode(text_1, tspan);
			},
			p: function p(changed, ctx) {
				if ((changed.context || changed.trainingPoints) && text_x_value !== (text_x_value = toU(ctx.context, ctx.trainingPoints[1].x) - 50)) {
					setAttribute(text$$1, "x", text_x_value);
				}

				if ((changed.context || changed.trainingPoints) && text_y_value !== (text_y_value = toV(ctx.context, ctx.trainingPoints[1].y) + 23)) {
					setAttribute(text$$1, "y", text_y_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(text$$1);
				}
			}
		};
	}

	function get_each_context(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.pt = list[i];
		child_ctx.each_value = list;
		child_ctx.idx = i;
		return child_ctx;
	}

	function click_handler(event$$1) {
		var _svelte = this._svelte,
		    component = _svelte.component,
		    ctx = _svelte.ctx;


		component.toggle(ctx.idx);
	}

	function Teaser(options) {
		var _this = this;

		init(this, options);
		this.refs = {};
		this._state = assign(data(), options.data);
		this._recompute({ context: 1, trainingPoints: 1 }, this._state);
		this._intro = true;

		this._handlers.state = [onstate];

		if (!document.getElementById("svelte-11ebxmd-style")) add_css();

		if (!options.root) {
			this._oncreate = [];
		}

		this._fragment = create_main_fragment(this, this._state);

		this.root._oncreate.push(function () {
			onstate.call(_this, { changed: assignTrue({}, _this._state), current: _this._state });
			oncreate.call(_this);
			_this.fire("update", { changed: assignTrue({}, _this._state), current: _this._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			callAll(this._oncreate);
		}
	}

	assign(Teaser.prototype, proto);
	assign(Teaser.prototype, methods);

	Teaser.prototype._recompute = function _recompute(changed, state) {
		if (changed.context) {
			if (this._differs(state.mean, state.mean = mean$1(state))) changed.mean = true;
			if (this._differs(state.sdPlus, state.sdPlus = sdPlus(state))) changed.sdPlus = true;
			if (this._differs(state.sdMinus, state.sdMinus = sdMinus(state))) changed.sdMinus = true;
			if (this._differs(state.sdArea, state.sdArea = sdArea(state))) changed.sdArea = true;
		}

		if (changed.context || changed.trainingPoints) {
			if (this._differs(state.curve, state.curve = curve(state))) changed.curve = true;
		}
	};

	/* src/scripts/components/GaussianContours.html generated by Svelte v2.9.1 */

	var colorScale = sequential(RdPu).domain([0, 0.2]);
	var intervals = sequence(0.1, 6, 0.2);

	function ellipses(_ref) {
		var gaussian = _ref.gaussian,
		    context = _ref.context;

		// Taken from: https://math.stackexchange.com/q/395698
		var b = gaussian.cov.get(0, 1);
		var c = gaussian.cov.get(1, 0);
		if (b === 0 && c == 0) {
			return 0;
		}
		var a = gaussian.cov.get(0, 0);
		var d = gaussian.cov.get(1, 1);

		var trace = a + d;
		var det = a * d - c * b;

		// Compute the eigenvalues (radii)
		var L1 = trace / 2 + Math.sqrt(trace * trace / 4 - det);
		var L2 = trace / 2 - Math.sqrt(trace * trace / 4 - det);

		// Choose the largest eigenvalue
		var v = L1 >= L2 ? [L1 - det, c] : [L2 - det, c];
		var angle = -Math.atan(v[1] / v[0]) * 180 / Math.PI;

		return intervals.map(function (i) {
			var rx = Math.sqrt(i * L1);
			var ry = Math.sqrt(i * L2);
			var color$$1 = gaussian.at([rx, ry]);
			return {
				cx: context.u(gaussian.mean.get(0, 0)),
				cy: context.v(gaussian.mean.get(1, 0)),
				rx: context.u(rx) - context.u(0),
				ry: context.v(-ry) - context.v(0),
				color: colorScale(color$$1),
				rotation: angle
			};
		}).reverse();
	}

	function data$1() {
		return {
			context: new Context(300, 300, [-2, 2], [-2, 2]),
			gaussian: new Gaussian([0, 0], [[1, 0.7], [0.7, 2]])
		};
	}
	function create_main_fragment$1(component, ctx) {
		var svg$$1;

		var each_value = ctx.ellipses;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(component, get_each_context$1(ctx, each_value, i));
		}

		return {
			c: function c() {
				svg$$1 = createSvgElement("svg");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
			},
			m: function m(target, anchor) {
				insertNode(svg$$1, target, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(svg$$1, null);
				}
			},
			p: function p(changed, ctx) {
				if (changed.ellipses) {
					each_value = ctx.ellipses;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(svg$$1, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(svg$$1);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (2:2) {#each ellipses as e}
	function create_each_block$1(component, ctx) {
		var ellipse, ellipse_cx_value, ellipse_cy_value, ellipse_rx_value, ellipse_ry_value, ellipse_fill_value, ellipse_transform_value;

		return {
			c: function c() {
				ellipse = createSvgElement("ellipse");
				setAttribute(ellipse, "cx", ellipse_cx_value = ctx.e.cx);
				setAttribute(ellipse, "cy", ellipse_cy_value = ctx.e.cy);
				setAttribute(ellipse, "rx", ellipse_rx_value = ctx.e.rx);
				setAttribute(ellipse, "ry", ellipse_ry_value = ctx.e.ry);
				setAttribute(ellipse, "fill", ellipse_fill_value = ctx.e.color);
				setAttribute(ellipse, "transform", ellipse_transform_value = "rotate(" + ctx.e.rotation + " " + ctx.e.cx + " " + ctx.e.cy + ")");
			},
			m: function m(target, anchor) {
				insertNode(ellipse, target, anchor);
			},
			p: function p(changed, ctx) {
				if (changed.ellipses && ellipse_cx_value !== (ellipse_cx_value = ctx.e.cx)) {
					setAttribute(ellipse, "cx", ellipse_cx_value);
				}

				if (changed.ellipses && ellipse_cy_value !== (ellipse_cy_value = ctx.e.cy)) {
					setAttribute(ellipse, "cy", ellipse_cy_value);
				}

				if (changed.ellipses && ellipse_rx_value !== (ellipse_rx_value = ctx.e.rx)) {
					setAttribute(ellipse, "rx", ellipse_rx_value);
				}

				if (changed.ellipses && ellipse_ry_value !== (ellipse_ry_value = ctx.e.ry)) {
					setAttribute(ellipse, "ry", ellipse_ry_value);
				}

				if (changed.ellipses && ellipse_fill_value !== (ellipse_fill_value = ctx.e.color)) {
					setAttribute(ellipse, "fill", ellipse_fill_value);
				}

				if (changed.ellipses && ellipse_transform_value !== (ellipse_transform_value = "rotate(" + ctx.e.rotation + " " + ctx.e.cx + " " + ctx.e.cy + ")")) {
					setAttribute(ellipse, "transform", ellipse_transform_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(ellipse);
				}
			}
		};
	}

	function get_each_context$1(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.e = list[i];
		child_ctx.each_value = list;
		child_ctx.e_index = i;
		return child_ctx;
	}

	function GaussianContours(options) {
		init(this, options);
		this._state = assign(data$1(), options.data);
		this._recompute({ gaussian: 1, context: 1 }, this._state);
		this._intro = true;

		this._fragment = create_main_fragment$1(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(GaussianContours.prototype, proto);

	GaussianContours.prototype._recompute = function _recompute(changed, state) {
		if (changed.gaussian || changed.context) {
			if (this._differs(state.ellipses, state.ellipses = ellipses(state))) changed.ellipses = true;
		}
	};

	function clamp(num, min, max) {
	  return Math.min(Math.max(num, min), max);
	}

	/* src/scripts/components/InteractiveGaussian.html generated by Svelte v2.9.1 */

	function meanPos(_ref) {
		var context = _ref.context,
		    mean$$1 = _ref.mean;

		return [context.u(mean$$1[0]), context.v(mean$$1[1])];
	}

	function sigma1Pos(_ref2) {
		var context = _ref2.context,
		    mean$$1 = _ref2.mean,
		    sigma1 = _ref2.sigma1;

		return [context.u(sigma1 + mean$$1[0]), context.v(mean$$1[1])];
	}

	function sigma2Pos(_ref3) {
		var context = _ref3.context,
		    mean$$1 = _ref3.mean,
		    sigma2 = _ref3.sigma2;

		return [context.u(mean$$1[0]), context.v(sigma2 + mean$$1[1])];
	}

	function covPos(_ref4) {
		var context = _ref4.context,
		    mean$$1 = _ref4.mean,
		    cov = _ref4.cov;

		return [context.u(mean$$1[0]), context.v(mean$$1[1] - cov)];
	}

	function gaussian(_ref5) {
		var mean$$1 = _ref5.mean,
		    sigma1 = _ref5.sigma1,
		    sigma2 = _ref5.sigma2,
		    cov = _ref5.cov;

		return new Gaussian([mean$$1[0], mean$$1[1]], [[sigma1, cov], [cov, sigma2]]);
	}

	function data$2() {
		return {
			limits: {
				sigma1: { from: 0.6, to: 1.8 },
				sigma2: { from: 0.6, to: 1.8 },
				cov: { from: -0.8, to: 0.8 }
			},
			mean: [0, 0],
			sigma1: 1,
			sigma2: 1,
			cov: 0.9,
			context: new Context(300, 300, [-2, 2], [-2, 2])
		};
	}
	function oncreate$1() {
		var _this = this;

		// TODO: Limit movement
		var _get = this.get(),
		    context = _get.context,
		    limits = _get.limits;

		select(this.refs.sigma1).call(drag().on('drag', function () {
			var _get2 = _this.get(),
			    sigma1 = _get2.sigma1;

			sigma1 = clamp(context.x(event.x), limits.sigma1.from, limits.sigma1.to);
			_this.set({ sigma1: sigma1 });
		}));

		select(this.refs.sigma2).call(drag().on('drag', function () {
			var _get3 = _this.get(),
			    sigma2 = _get3.sigma2;

			sigma2 = clamp(context.y(event.y), limits.sigma2.from, limits.sigma2.to);
			_this.set({ sigma2: sigma2 });
		}));

		select(this.refs.cov).call(drag().on('drag', function () {
			var _get4 = _this.get(),
			    cov = _get4.cov;
			// TODO: Make more intuitive


			cov = clamp(-context.y(event.y), limits.cov.from, limits.cov.to);
			_this.set({ cov: cov });
		}));
	}
	function add_css$1() {
		var style = createElement("style");
		style.id = 'svelte-1ukdf7z-style';
		style.textContent = ".handle.svelte-1ukdf7z{fill:rgba(0,0,0,0.2)}.handle.svelte-1ukdf7z:hover{stroke:gray;stroke-width:2px}.link.svelte-1ukdf7z{stroke:rgba(0,0,0,0.2);stroke-width:2px}";
		appendNode(style, document.head);
	}

	function create_main_fragment$2(component, ctx) {
		var svg$$1, line$$1, line_x__value, line_y__value, line_x__value_1, line_y__value_1, line_1, line_1_x__value, line_1_y__value, line_1_x__value_1, line_1_y__value_1, line_2, line_2_x__value, line_2_y__value, line_2_x__value_1, line_2_y__value_1, circle$$1, circle_cx_value, circle_cy_value, circle_1, circle_1_cx_value, circle_1_cy_value, circle_2, circle_2_cx_value, circle_2_cy_value, svg_width_value, svg_height_value;

		var gaussiancontours_initial_data = {
			width: ctx.context.width,
			height: ctx.context.height,
			context: ctx.context,
			gaussian: ctx.gaussian
		};
		var gaussiancontours = new GaussianContours({
			root: component.root,
			store: component.store,
			data: gaussiancontours_initial_data
		});

		return {
			c: function c() {
				svg$$1 = createSvgElement("svg");
				gaussiancontours._fragment.c();
				line$$1 = createSvgElement("line");
				line_1 = createSvgElement("line");
				line_2 = createSvgElement("line");
				circle$$1 = createSvgElement("circle");
				circle_1 = createSvgElement("circle");
				circle_2 = createSvgElement("circle");
				setAttribute(line$$1, "class", "link svelte-1ukdf7z");
				setAttribute(line$$1, "x1", line_x__value = ctx.covPos[0]);
				setAttribute(line$$1, "y1", line_y__value = ctx.covPos[1]);
				setAttribute(line$$1, "x2", line_x__value_1 = ctx.meanPos[0]);
				setAttribute(line$$1, "y2", line_y__value_1 = ctx.meanPos[1]);
				setAttribute(line_1, "class", "link svelte-1ukdf7z");
				setAttribute(line_1, "x1", line_1_x__value = ctx.sigma1Pos[0]);
				setAttribute(line_1, "y1", line_1_y__value = ctx.sigma1Pos[1]);
				setAttribute(line_1, "x2", line_1_x__value_1 = ctx.meanPos[0]);
				setAttribute(line_1, "y2", line_1_y__value_1 = ctx.meanPos[1]);
				setAttribute(line_2, "class", "link svelte-1ukdf7z");
				setAttribute(line_2, "x1", line_2_x__value = ctx.sigma2Pos[0]);
				setAttribute(line_2, "y1", line_2_y__value = ctx.sigma2Pos[1]);
				setAttribute(line_2, "x2", line_2_x__value_1 = ctx.meanPos[0]);
				setAttribute(line_2, "y2", line_2_y__value_1 = ctx.meanPos[1]);
				setAttribute(circle$$1, "class", "handle svelte-1ukdf7z");
				setAttribute(circle$$1, "cx", circle_cx_value = ctx.sigma1Pos[0]);
				setAttribute(circle$$1, "cy", circle_cy_value = ctx.sigma1Pos[1]);
				setAttribute(circle$$1, "r", "4");
				setAttribute(circle_1, "class", "handle svelte-1ukdf7z");
				setAttribute(circle_1, "cx", circle_1_cx_value = ctx.sigma2Pos[0]);
				setAttribute(circle_1, "cy", circle_1_cy_value = ctx.sigma2Pos[1]);
				setAttribute(circle_1, "r", "4");
				setAttribute(circle_2, "class", "handle svelte-1ukdf7z");
				setAttribute(circle_2, "cx", circle_2_cx_value = ctx.covPos[0]);
				setAttribute(circle_2, "cy", circle_2_cy_value = ctx.covPos[1]);
				setAttribute(circle_2, "r", "4");
				setAttribute(svg$$1, "width", svg_width_value = ctx.context.width);
				setAttribute(svg$$1, "height", svg_height_value = ctx.context.height);
			},
			m: function m(target, anchor) {
				insertNode(svg$$1, target, anchor);
				gaussiancontours._mount(svg$$1, null);
				appendNode(line$$1, svg$$1);
				appendNode(line_1, svg$$1);
				appendNode(line_2, svg$$1);
				appendNode(circle$$1, svg$$1);
				component.refs.sigma1 = circle$$1;
				appendNode(circle_1, svg$$1);
				component.refs.sigma2 = circle_1;
				appendNode(circle_2, svg$$1);
				component.refs.cov = circle_2;
			},
			p: function p(changed, ctx) {
				var gaussiancontours_changes = {};
				if (changed.context) gaussiancontours_changes.width = ctx.context.width;
				if (changed.context) gaussiancontours_changes.height = ctx.context.height;
				if (changed.context) gaussiancontours_changes.context = ctx.context;
				if (changed.gaussian) gaussiancontours_changes.gaussian = ctx.gaussian;
				gaussiancontours._set(gaussiancontours_changes);

				if (changed.covPos && line_x__value !== (line_x__value = ctx.covPos[0])) {
					setAttribute(line$$1, "x1", line_x__value);
				}

				if (changed.covPos && line_y__value !== (line_y__value = ctx.covPos[1])) {
					setAttribute(line$$1, "y1", line_y__value);
				}

				if (changed.meanPos && line_x__value_1 !== (line_x__value_1 = ctx.meanPos[0])) {
					setAttribute(line$$1, "x2", line_x__value_1);
				}

				if (changed.meanPos && line_y__value_1 !== (line_y__value_1 = ctx.meanPos[1])) {
					setAttribute(line$$1, "y2", line_y__value_1);
				}

				if (changed.sigma1Pos && line_1_x__value !== (line_1_x__value = ctx.sigma1Pos[0])) {
					setAttribute(line_1, "x1", line_1_x__value);
				}

				if (changed.sigma1Pos && line_1_y__value !== (line_1_y__value = ctx.sigma1Pos[1])) {
					setAttribute(line_1, "y1", line_1_y__value);
				}

				if (changed.meanPos && line_1_x__value_1 !== (line_1_x__value_1 = ctx.meanPos[0])) {
					setAttribute(line_1, "x2", line_1_x__value_1);
				}

				if (changed.meanPos && line_1_y__value_1 !== (line_1_y__value_1 = ctx.meanPos[1])) {
					setAttribute(line_1, "y2", line_1_y__value_1);
				}

				if (changed.sigma2Pos && line_2_x__value !== (line_2_x__value = ctx.sigma2Pos[0])) {
					setAttribute(line_2, "x1", line_2_x__value);
				}

				if (changed.sigma2Pos && line_2_y__value !== (line_2_y__value = ctx.sigma2Pos[1])) {
					setAttribute(line_2, "y1", line_2_y__value);
				}

				if (changed.meanPos && line_2_x__value_1 !== (line_2_x__value_1 = ctx.meanPos[0])) {
					setAttribute(line_2, "x2", line_2_x__value_1);
				}

				if (changed.meanPos && line_2_y__value_1 !== (line_2_y__value_1 = ctx.meanPos[1])) {
					setAttribute(line_2, "y2", line_2_y__value_1);
				}

				if (changed.sigma1Pos && circle_cx_value !== (circle_cx_value = ctx.sigma1Pos[0])) {
					setAttribute(circle$$1, "cx", circle_cx_value);
				}

				if (changed.sigma1Pos && circle_cy_value !== (circle_cy_value = ctx.sigma1Pos[1])) {
					setAttribute(circle$$1, "cy", circle_cy_value);
				}

				if (changed.sigma2Pos && circle_1_cx_value !== (circle_1_cx_value = ctx.sigma2Pos[0])) {
					setAttribute(circle_1, "cx", circle_1_cx_value);
				}

				if (changed.sigma2Pos && circle_1_cy_value !== (circle_1_cy_value = ctx.sigma2Pos[1])) {
					setAttribute(circle_1, "cy", circle_1_cy_value);
				}

				if (changed.covPos && circle_2_cx_value !== (circle_2_cx_value = ctx.covPos[0])) {
					setAttribute(circle_2, "cx", circle_2_cx_value);
				}

				if (changed.covPos && circle_2_cy_value !== (circle_2_cy_value = ctx.covPos[1])) {
					setAttribute(circle_2, "cy", circle_2_cy_value);
				}

				if (changed.context && svg_width_value !== (svg_width_value = ctx.context.width)) {
					setAttribute(svg$$1, "width", svg_width_value);
				}

				if (changed.context && svg_height_value !== (svg_height_value = ctx.context.height)) {
					setAttribute(svg$$1, "height", svg_height_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(svg$$1);
				}

				gaussiancontours.destroy();
				if (component.refs.sigma1 === circle$$1) component.refs.sigma1 = null;
				if (component.refs.sigma2 === circle_1) component.refs.sigma2 = null;
				if (component.refs.cov === circle_2) component.refs.cov = null;
			}
		};
	}

	function InteractiveGaussian(options) {
		var _this2 = this;

		init(this, options);
		this.refs = {};
		this._state = assign(data$2(), options.data);
		this._recompute({ context: 1, mean: 1, sigma1: 1, sigma2: 1, cov: 1 }, this._state);
		this._intro = true;

		if (!document.getElementById("svelte-1ukdf7z-style")) add_css$1();

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$2(this, this._state);

		this.root._oncreate.push(function () {
			oncreate$1.call(_this2);
			_this2.fire("update", { changed: assignTrue({}, _this2._state), current: _this2._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(InteractiveGaussian.prototype, proto);

	InteractiveGaussian.prototype._recompute = function _recompute(changed, state) {
		if (changed.context || changed.mean) {
			if (this._differs(state.meanPos, state.meanPos = meanPos(state))) changed.meanPos = true;
		}

		if (changed.context || changed.mean || changed.sigma1) {
			if (this._differs(state.sigma1Pos, state.sigma1Pos = sigma1Pos(state))) changed.sigma1Pos = true;
		}

		if (changed.context || changed.mean || changed.sigma2) {
			if (this._differs(state.sigma2Pos, state.sigma2Pos = sigma2Pos(state))) changed.sigma2Pos = true;
		}

		if (changed.context || changed.mean || changed.cov) {
			if (this._differs(state.covPos, state.covPos = covPos(state))) changed.covPos = true;
		}

		if (changed.mean || changed.sigma1 || changed.sigma2 || changed.cov) {
			if (this._differs(state.gaussian, state.gaussian = gaussian(state))) changed.gaussian = true;
		}
	};

	/* src/scripts/components/CovMat2x2.html generated by Svelte v2.9.1 */

	function data$3() {
		return {
			sigma1: 1,
			sigma2: 1,
			corr: 0.5
		};
	}
	function add_css$2() {
		var style = createElement("style");
		style.id = 'svelte-134p43-style';
		style.textContent = ".entry.svelte-134p43{font-size:14px;fill:rgba(0,0,0,0.8);text-anchor:middle;alignment-baseline:center}.entryBox.svelte-134p43{fill:hsl(200, 20%, 97%);stroke-width:1;stroke:rgba(0,0,0,0.2)}";
		appendNode(style, document.head);
	}

	function create_main_fragment$3(component, ctx) {
		var svg$$1, g, rect, text$$1, text_1, g_1, rect_1, text_2, text_3, g_2, rect_2, text_4, text_5, g_3, rect_3, text_6, text_7;

		return {
			c: function c() {
				svg$$1 = createSvgElement("svg");
				g = createSvgElement("g");
				rect = createSvgElement("rect");
				text$$1 = createSvgElement("text");
				text_1 = createText(ctx.sigma1);
				g_1 = createSvgElement("g");
				rect_1 = createSvgElement("rect");
				text_2 = createSvgElement("text");
				text_3 = createText(ctx.corr);
				g_2 = createSvgElement("g");
				rect_2 = createSvgElement("rect");
				text_4 = createSvgElement("text");
				text_5 = createText(ctx.corr);
				g_3 = createSvgElement("g");
				rect_3 = createSvgElement("rect");
				text_6 = createSvgElement("text");
				text_7 = createText(ctx.sigma2);
				setAttribute(rect, "x", "0");
				setAttribute(rect, "y", "0");
				setAttribute(rect, "width", "50");
				setAttribute(rect, "height", "35");
				setAttribute(rect, "rx", "5");
				setAttribute(rect, "ry", "5");
				setAttribute(rect, "class", "entryBox svelte-134p43");
				setAttribute(text$$1, "x", "25");
				setAttribute(text$$1, "y", "23");
				setAttribute(text$$1, "class", "entry svelte-134p43");
				setAttribute(g, "transform", "translate(1,1)");
				setAttribute(rect_1, "x", "0");
				setAttribute(rect_1, "y", "0");
				setAttribute(rect_1, "width", "50");
				setAttribute(rect_1, "height", "35");
				setAttribute(rect_1, "rx", "5");
				setAttribute(rect_1, "ry", "5");
				setAttribute(rect_1, "class", "entryBox svelte-134p43");
				setAttribute(text_2, "x", "25");
				setAttribute(text_2, "y", "23");
				setAttribute(text_2, "class", "entry svelte-134p43");
				setAttribute(g_1, "transform", "translate(61,1)");
				setAttribute(rect_2, "x", "0");
				setAttribute(rect_2, "y", "0");
				setAttribute(rect_2, "width", "50");
				setAttribute(rect_2, "height", "35");
				setAttribute(rect_2, "rx", "5");
				setAttribute(rect_2, "ry", "5");
				setAttribute(rect_2, "class", "entryBox svelte-134p43");
				setAttribute(text_4, "x", "25");
				setAttribute(text_4, "y", "23");
				setAttribute(text_4, "class", "entry svelte-134p43");
				setAttribute(g_2, "transform", "translate(1,46)");
				setAttribute(rect_3, "x", "0");
				setAttribute(rect_3, "y", "0");
				setAttribute(rect_3, "width", "50");
				setAttribute(rect_3, "height", "35");
				setAttribute(rect_3, "rx", "5");
				setAttribute(rect_3, "ry", "5");
				setAttribute(rect_3, "class", "entryBox svelte-134p43");
				setAttribute(text_6, "x", "25");
				setAttribute(text_6, "y", "23");
				setAttribute(text_6, "class", "entry svelte-134p43");
				setAttribute(g_3, "transform", "translate(61,46)");
				setAttribute(svg$$1, "height", "82");
				setAttribute(svg$$1, "width", "112");
			},
			m: function m(target, anchor) {
				insertNode(svg$$1, target, anchor);
				appendNode(g, svg$$1);
				appendNode(rect, g);
				appendNode(text$$1, g);
				appendNode(text_1, text$$1);
				appendNode(g_1, svg$$1);
				appendNode(rect_1, g_1);
				appendNode(text_2, g_1);
				appendNode(text_3, text_2);
				appendNode(g_2, svg$$1);
				appendNode(rect_2, g_2);
				appendNode(text_4, g_2);
				appendNode(text_5, text_4);
				appendNode(g_3, svg$$1);
				appendNode(rect_3, g_3);
				appendNode(text_6, g_3);
				appendNode(text_7, text_6);
			},
			p: function p(changed, ctx) {
				if (changed.sigma1) {
					text_1.data = ctx.sigma1;
				}

				if (changed.corr) {
					text_3.data = ctx.corr;
					text_5.data = ctx.corr;
				}

				if (changed.sigma2) {
					text_7.data = ctx.sigma2;
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(svg$$1);
				}
			}
		};
	}

	function CovMat2x2(options) {
		init(this, options);
		this._state = assign(data$3(), options.data);
		this._intro = true;

		if (!document.getElementById("svelte-134p43-style")) add_css$2();

		this._fragment = create_main_fragment$3(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(CovMat2x2.prototype, proto);

	/* src/scripts/components/ColorScale.html generated by Svelte v2.9.1 */

	var staticId = 0;

	function colorValues(_ref) {
		var colorScale = _ref.colorScale;

		var domain = colorScale.domain();
		var n = 11;
		var step$$1 = (domain[1] - domain[0]) / n;
		return sequence(domain[0], domain[1] + step$$1, step$$1).map(function (v, i) {
			return { offset: i / n * 100, color: colorScale(v) };
		});
	}

	function data$4() {
		staticId = staticId + 1;
		return {
			colorScale: sequential(Greys),
			size: 150,
			margin: { top: 5, right: 12, bottom: 5, left: 18 },
			id: staticId
		};
	}
	function onstate$1(_ref2) {
		var _changed = _ref2._changed,
		    current = _ref2.current,
		    _previous = _ref2._previous;

		var height = current.size - current.margin.top - current.margin.bottom;
		// FIXME: Handle non-linear case
		var tickScale = linear$3().domain(current.colorScale.domain()).range([height, 0]);

		var axisGen = axisRight(tickScale).tickFormat(format('.2f')).ticks(5);
		select(this.refs.colorBar).call(axisGen);
	}
	function create_main_fragment$4(component, ctx) {
		var svg$$1, defs, linearGradient, linearGradient_id_value, g, rect, rect_x_value, rect_height_value, rect_fill_value, g_1, g_transform_value;

		var each_value = ctx.colorValues;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$2(component, get_each_context$2(ctx, each_value, i));
		}

		return {
			c: function c() {
				svg$$1 = createSvgElement("svg");
				defs = createSvgElement("defs");
				linearGradient = createSvgElement("linearGradient");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				g = createSvgElement("g");
				rect = createSvgElement("rect");
				g_1 = createSvgElement("g");
				setAttribute(linearGradient, "id", linearGradient_id_value = "grad-" + ctx.id);
				setAttribute(linearGradient, "x1", "0%");
				setAttribute(linearGradient, "y1", "100%");
				setAttribute(linearGradient, "x2", "0%");
				setAttribute(linearGradient, "y2", "0%");
				setAttribute(rect, "x", rect_x_value = "-" + ctx.margin.left);
				setAttribute(rect, "y", "0");
				setAttribute(rect, "width", "12");
				setAttribute(rect, "height", rect_height_value = ctx.size - ctx.margin.top - ctx.margin.bottom);
				setAttribute(rect, "fill", rect_fill_value = "url('#grad-" + ctx.id + "')");
				setAttribute(g_1, "class", "axis");
				setAttribute(g, "transform", g_transform_value = "translate(" + ctx.margin.left + "," + ctx.margin.top + ")");
				setAttribute(svg$$1, "width", "50");
				setAttribute(svg$$1, "height", ctx.size);
			},
			m: function m(target, anchor) {
				insertNode(svg$$1, target, anchor);
				appendNode(defs, svg$$1);
				appendNode(linearGradient, defs);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(linearGradient, null);
				}

				appendNode(g, svg$$1);
				appendNode(rect, g);
				appendNode(g_1, g);
				component.refs.colorBar = g_1;
			},
			p: function p(changed, ctx) {
				if (changed.colorValues) {
					each_value = ctx.colorValues;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context$2(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$2(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(linearGradient, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (changed.id && linearGradient_id_value !== (linearGradient_id_value = "grad-" + ctx.id)) {
					setAttribute(linearGradient, "id", linearGradient_id_value);
				}

				if (changed.margin && rect_x_value !== (rect_x_value = "-" + ctx.margin.left)) {
					setAttribute(rect, "x", rect_x_value);
				}

				if ((changed.size || changed.margin) && rect_height_value !== (rect_height_value = ctx.size - ctx.margin.top - ctx.margin.bottom)) {
					setAttribute(rect, "height", rect_height_value);
				}

				if (changed.id && rect_fill_value !== (rect_fill_value = "url('#grad-" + ctx.id + "')")) {
					setAttribute(rect, "fill", rect_fill_value);
				}

				if (changed.margin && g_transform_value !== (g_transform_value = "translate(" + ctx.margin.left + "," + ctx.margin.top + ")")) {
					setAttribute(g, "transform", g_transform_value);
				}

				if (changed.size) {
					setAttribute(svg$$1, "height", ctx.size);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(svg$$1);
				}

				destroyEach(each_blocks, detach);

				if (component.refs.colorBar === g_1) component.refs.colorBar = null;
			}
		};
	}

	// (4:6) {#each colorValues as v}
	function create_each_block$2(component, ctx) {
		var stop, stop_offset_value;

		return {
			c: function c() {
				stop = createSvgElement("stop");
				setAttribute(stop, "offset", stop_offset_value = "" + ctx.v.offset + "%");
				setStyle(stop, "stop-color", ctx.v.color);
				setStyle(stop, "stop-opacity", "1");
			},
			m: function m(target, anchor) {
				insertNode(stop, target, anchor);
			},
			p: function p(changed, ctx) {
				if (changed.colorValues && stop_offset_value !== (stop_offset_value = "" + ctx.v.offset + "%")) {
					setAttribute(stop, "offset", stop_offset_value);
				}

				if (changed.colorValues) {
					setStyle(stop, "stop-color", ctx.v.color);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(stop);
				}
			}
		};
	}

	function get_each_context$2(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.v = list[i];
		child_ctx.each_value = list;
		child_ctx.v_index = i;
		return child_ctx;
	}

	function ColorScale(options) {
		var _this = this;

		init(this, options);
		this.refs = {};
		this._state = assign(data$4(), options.data);
		this._recompute({ colorScale: 1 }, this._state);
		this._intro = true;

		this._handlers.state = [onstate$1];

		if (!options.root) {
			this._oncreate = [];
		}

		this._fragment = create_main_fragment$4(this, this._state);

		this.root._oncreate.push(function () {
			onstate$1.call(_this, { changed: assignTrue({}, _this._state), current: _this._state });
			_this.fire("update", { changed: assignTrue({}, _this._state), current: _this._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			callAll(this._oncreate);
		}
	}

	assign(ColorScale.prototype, proto);

	ColorScale.prototype._recompute = function _recompute(changed, state) {
		if (changed.colorScale) {
			if (this._differs(state.colorValues, state.colorValues = colorValues(state))) changed.colorValues = true;
		}
	};

	/* src/scripts/components/Multivariate.html generated by Svelte v2.9.1 */

	function data$5() {
		return {
			scale: sequential(RdPu).domain([0, 0.2]),
			context: new Context(200, 200, [-2, 2], [-2, 2]),
			gaussian: new Gaussian([0, 0], [[1, 0.7], [0.7, 1]])
		};
	}
	function twoDecimals(x) {
		return Math.round(x * 100) / 100;
	}
	function oncreate$2() {
		var _this = this;

		this.refs.gauss.on('update', function (_ref) {
			var _changed = _ref._changed,
			    current = _ref.current,
			    _previous = _ref._previous;

			_this.set({ gaussian: current.gaussian });
		});
	}
	function add_css$3() {
		var style = createElement("style");
		style.id = 'svelte-kktbpc-style';
		style.textContent = ".gauss-grid.svelte-kktbpc{display:inline-grid;grid-template-columns:auto auto auto;text-align:center}.grid-item.svelte-kktbpc{margin:5px}.plot.svelte-kktbpc{float:left}";
		appendNode(style, document.head);
	}

	function create_main_fragment$5(component, ctx) {
		var div, div_1, svg$$1, svg_width_value, svg_height_value, text_1, div_2, svg_1, g, text_2, tspan, text_3, g_1, text_4, text_5, tspan_1, text_6, tspan_2, text_7, tspan_3, text_8, tspan_4, text_9, tspan_5, text_10, tspan_6, text_11, tspan_7, text_12;

		var interactivegaussian_initial_data = {
			sigma1: ctx.gaussian.cov.get(0, 0),
			sigma2: ctx.gaussian.cov.get(1, 1),
			cov: ctx.gaussian.cov.get(0, 1),
			context: ctx.context
		};
		var interactivegaussian = new InteractiveGaussian({
			root: component.root,
			store: component.store,
			data: interactivegaussian_initial_data
		});

		component.refs.gauss = interactivegaussian;

		var colorscale_initial_data = { colorScale: ctx.scale };
		var colorscale = new ColorScale({
			root: component.root,
			store: component.store,
			data: colorscale_initial_data
		});

		var covmat2x2_initial_data = {
			sigma1: twoDecimals(ctx.gaussian.cov.get(0, 0)),
			sigma2: twoDecimals(ctx.gaussian.cov.get(1, 1)),
			corr: twoDecimals(ctx.gaussian.cov.get(0, 1))
		};
		var covmat2x2 = new CovMat2x2({
			root: component.root,
			store: component.store,
			data: covmat2x2_initial_data
		});

		return {
			c: function c() {
				div = createElement("div");
				div_1 = createElement("div");
				svg$$1 = createSvgElement("svg");
				interactivegaussian._fragment.c();
				text_1 = createText("\n    ");
				div_2 = createElement("div");
				svg_1 = createSvgElement("svg");
				g = createSvgElement("g");
				colorscale._fragment.c();
				text_2 = createSvgElement("text");
				tspan = createSvgElement("tspan");
				text_3 = createText("Covariance matrix (Σ)");
				g_1 = createSvgElement("g");
				covmat2x2._fragment.c();
				text_4 = createSvgElement("text");
				text_5 = createText("By dragging the handles you \n        ");
				tspan_1 = createSvgElement("tspan");
				text_6 = createText("can adjust the variance along");
				tspan_2 = createSvgElement("tspan");
				text_7 = createText("each dimension, as well as the");
				tspan_3 = createSvgElement("tspan");
				text_8 = createText("correlation between the two");
				tspan_4 = createSvgElement("tspan");
				text_9 = createText("random variables. ");
				tspan_5 = createSvgElement("tspan");
				text_10 = createText("Violet");
				tspan_6 = createSvgElement("tspan");
				text_11 = createText("values show a high probability");
				tspan_7 = createSvgElement("tspan");
				text_12 = createText("inside the distribution.");
				setAttribute(svg$$1, "width", svg_width_value = ctx.context.width);
				setAttribute(svg$$1, "height", svg_height_value = ctx.context.height);
				setAttribute(svg$$1, "class", "plot svelte-kktbpc");
				div_1.className = "grid-item svelte-kktbpc";
				setAttribute(g, "transform", "translate(0,20)");
				setAttribute(tspan, "font-weight", "bold");
				setAttribute(text_2, "x", "70");
				setAttribute(text_2, "y", "40");
				setAttribute(text_2, "class", "annotation");
				setAttribute(g_1, "transform", "translate(82,50)");
				setAttribute(tspan_1, "x", "230");
				setAttribute(tspan_1, "dy", "1.5em");
				setAttribute(tspan_2, "x", "230");
				setAttribute(tspan_2, "dy", "1.5em");
				setAttribute(tspan_3, "x", "230");
				setAttribute(tspan_3, "dy", "1.5em");
				setAttribute(tspan_5, "fill", "rgb(73, 0, 106)");
				setAttribute(tspan_5, "font-style", "italic");
				setAttribute(tspan_4, "x", "230");
				setAttribute(tspan_4, "dy", "1.5em");
				setAttribute(tspan_6, "x", "230");
				setAttribute(tspan_6, "dy", "1.5em");
				setAttribute(tspan_7, "x", "230");
				setAttribute(tspan_7, "dy", "1.5em");
				setAttribute(text_4, "x", "230");
				setAttribute(text_4, "y", "30");
				setAttribute(text_4, "class", "annotation");
				setAttribute(svg_1, "width", "450");
				setAttribute(svg_1, "height", "200");
				div_2.className = "grid-item svelte-kktbpc";
				div.className = "gauss-grid svelte-kktbpc";
			},
			m: function m(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(div_1, div);
				appendNode(svg$$1, div_1);
				interactivegaussian._mount(svg$$1, null);
				appendNode(text_1, div);
				appendNode(div_2, div);
				appendNode(svg_1, div_2);
				appendNode(g, svg_1);
				colorscale._mount(g, null);
				appendNode(text_2, svg_1);
				appendNode(tspan, text_2);
				appendNode(text_3, tspan);
				appendNode(g_1, svg_1);
				covmat2x2._mount(g_1, null);
				appendNode(text_4, svg_1);
				appendNode(text_5, text_4);
				appendNode(tspan_1, text_4);
				appendNode(text_6, tspan_1);
				appendNode(tspan_2, text_4);
				appendNode(text_7, tspan_2);
				appendNode(tspan_3, text_4);
				appendNode(text_8, tspan_3);
				appendNode(tspan_4, text_4);
				appendNode(text_9, tspan_4);
				appendNode(tspan_5, tspan_4);
				appendNode(text_10, tspan_5);
				appendNode(tspan_6, text_4);
				appendNode(text_11, tspan_6);
				appendNode(tspan_7, text_4);
				appendNode(text_12, tspan_7);
			},
			p: function p(changed, ctx) {
				var interactivegaussian_changes = {};
				if (changed.gaussian) interactivegaussian_changes.sigma1 = ctx.gaussian.cov.get(0, 0);
				if (changed.gaussian) interactivegaussian_changes.sigma2 = ctx.gaussian.cov.get(1, 1);
				if (changed.gaussian) interactivegaussian_changes.cov = ctx.gaussian.cov.get(0, 1);
				if (changed.context) interactivegaussian_changes.context = ctx.context;
				interactivegaussian._set(interactivegaussian_changes);

				if (changed.context && svg_width_value !== (svg_width_value = ctx.context.width)) {
					setAttribute(svg$$1, "width", svg_width_value);
				}

				if (changed.context && svg_height_value !== (svg_height_value = ctx.context.height)) {
					setAttribute(svg$$1, "height", svg_height_value);
				}

				var colorscale_changes = {};
				if (changed.scale) colorscale_changes.colorScale = ctx.scale;
				colorscale._set(colorscale_changes);

				var covmat2x2_changes = {};
				if (changed.gaussian) covmat2x2_changes.sigma1 = twoDecimals(ctx.gaussian.cov.get(0, 0));
				if (changed.gaussian) covmat2x2_changes.sigma2 = twoDecimals(ctx.gaussian.cov.get(1, 1));
				if (changed.gaussian) covmat2x2_changes.corr = twoDecimals(ctx.gaussian.cov.get(0, 1));
				covmat2x2._set(covmat2x2_changes);
			},
			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				interactivegaussian.destroy();
				if (component.refs.gauss === interactivegaussian) component.refs.gauss = null;
				colorscale.destroy();
				covmat2x2.destroy();
			}
		};
	}

	function Multivariate(options) {
		var _this2 = this;

		init(this, options);
		this.refs = {};
		this._state = assign(data$5(), options.data);
		this._intro = true;

		if (!document.getElementById("svelte-kktbpc-style")) add_css$3();

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$5(this, this._state);

		this.root._oncreate.push(function () {
			oncreate$2.call(_this2);
			_this2.fire("update", { changed: assignTrue({}, _this2._state), current: _this2._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(Multivariate.prototype, proto);

	/* src/scripts/components/MarginalizationConditioning.html generated by Svelte v2.9.1 */

	var STEP = 0.1;

	function condPos(_ref) {
		var context = _ref.context,
		    cond = _ref.cond;

		return [context.u(cond), 50];
	}

	function conditionedGauss(_ref2) {
		var gaussian = _ref2.gaussian,
		    cond = _ref2.cond;

		return gaussian.condition([cond]);
	}

	function conditionedPath(_ref3) {
		var context = _ref3.context,
		    gaussian = _ref3.gaussian,
		    cond = _ref3.cond,
		    sideWidth = _ref3.sideWidth;

		var x = linear$3().domain(context.xDomain()).range([context.height, 0]);
		var y = linear$3().domain([0.8, 0]).range([sideWidth, 0]);

		var g = gaussian.condition([cond]);
		var ys = sequence(context.yDomain()[0], context.yDomain()[1] + STEP, STEP);
		var xs = ys.map(function (x) {
			return g.at([x]);
		});
		var pts = zip(ys, xs);
		var path$$1 = line().x(function (d) {
			return y(d[1]);
		}).y(function (d) {
			return x(d[0]);
		})(pts);
		return path$$1;
	}

	function marginalizedGauss(_ref4) {
		var gaussian = _ref4.gaussian;

		return gaussian.marginalize(1)[1];
	}

	function marginalizedPath(_ref5) {
		var context = _ref5.context,
		    gaussian = _ref5.gaussian,
		    sideWidth = _ref5.sideWidth;

		var x = linear$3().domain(context.xDomain()).range([0, context.height]);
		var y = linear$3().domain([0, 0.5]).range([sideWidth, 0]);

		var g = gaussian.marginalize(1)[1];
		var ys = sequence(context.yDomain()[0], context.yDomain()[1] + STEP, STEP);
		var xs = ys.map(function (x) {
			return g.at([x]);
		});
		var pts = zip(ys, xs);
		var path$$1 = line().x(function (d) {
			return y(d[1]);
		}).y(function (d) {
			return x(d[0]);
		})(pts);
		return path$$1;
	}

	function data$6() {
		return {
			limits: {
				sigma1: { from: 0.8, to: 1.8 },
				sigma2: { from: 0.8, to: 1.8 },
				cov: { from: -0.8, to: 0.8 }
			},
			context: new Context(250, 250, [-4, 4], [-4, 4]),
			cond: 1.2, // value for conditioning
			gaussian: new Gaussian([0, 0], [[1, 0.8], [0.8, 1.4]]),
			sideWidth: 200
		};
	}
	function twoDecimals$1(x) {
		return Math.round(x * 100) / 100;
	}
	function toV$1(context, y) {
		return context.v(y);
	}
	function oncreate$3() {
		var _this = this;

		this.refs.gauss.on('state', function (_ref6) {
			var _changed = _ref6._changed,
			    current = _ref6.current,
			    _previous = _ref6._previous;

			_this.set({ gaussian: current.gaussian });
		});

		var _get = this.get(),
		    context = _get.context;

		select(this.refs.handle).call(drag().on('drag', function () {
			var padding = 10;
			var upperLimit = context.width - padding;
			var lowerLimit = padding;

			var _get2 = _this.get(),
			    cond = _get2.cond;

			cond = context.x(clamp(event.x, lowerLimit, upperLimit));
			_this.set({ cond: cond });
		}));
	}
	function add_css$4() {
		var style = createElement("style");
		style.id = 'svelte-yvfo7n-style';
		style.textContent = ".gauss-grid.svelte-yvfo7n{display:inline-grid;grid-template-columns:auto auto auto;text-align:center}.grid-item.svelte-yvfo7n{margin:0.3em}.line.svelte-yvfo7n{fill:none;stroke:#c51b8a;stroke-width:2px}.curve.svelte-yvfo7n{fill:none;stroke:rgba(0,0,0,0.6);stroke-width:2px}.handle.svelte-yvfo7n{fill:#c51b8a}.ss.svelte-yvfo7n{baseline-shift:sub;font-size:11px}";
		appendNode(style, document.head);
	}

	function create_main_fragment$6(component, ctx) {
		var div,
		    div_1,
		    text_2,
		    div_2,
		    text_3,
		    div_3,
		    h4_1,
		    text_4,
		    text_5_value = twoDecimals$1(ctx.cond),
		    text_5,
		    text_6,
		    text_8,
		    div_4,
		    svg$$1,
		    path$$1,
		    text_9,
		    text_10,
		    tspan,
		    text_11,
		    text_12,
		    text_13_value = twoDecimals$1(ctx.marginalizedGauss.mean.get(0, 0)),
		    text_13,
		    text_9_x_value,
		    text_9_y_value,
		    text_14,
		    text_15,
		    tspan_1,
		    text_16,
		    text_17,
		    text_18_value = twoDecimals$1(ctx.marginalizedGauss.cov.get(0, 0)),
		    text_18,
		    text_14_y_value,
		    svg_height_value,
		    text_20,
		    div_5,
		    svg_1,
		    line$$1,
		    line_x__value,
		    line_x__value_1,
		    line_y__value,
		    circle$$1,
		    circle_cx_value,
		    circle_cy_value,
		    text_21,
		    text_22,
		    text_23_value = twoDecimals$1(ctx.cond),
		    text_23,
		    text_21_x_value,
		    text_21_y_value,
		    svg_1_width_value,
		    svg_1_height_value,
		    text_25,
		    div_6,
		    svg_2,
		    path_1,
		    text_26,
		    text_27,
		    tspan_2,
		    text_28,
		    text_29,
		    text_30_value = twoDecimals$1(ctx.conditionedGauss.mean.get(0, 0)),
		    text_30,
		    text_26_y_value,
		    text_31,
		    text_32,
		    tspan_3,
		    text_33,
		    text_34,
		    text_35_value = twoDecimals$1(ctx.marginalizedGauss.cov.get(0, 0)),
		    text_35,
		    text_31_y_value,
		    svg_2_height_value;

		var interactivegaussian_initial_data = {
			context: ctx.context,
			sigma1: ctx.gaussian.cov.get(0, 0),
			sigma2: ctx.gaussian.cov.get(1, 1),
			cov: ctx.gaussian.cov.get(0, 1),
			limits: ctx.limits
		};
		var interactivegaussian = new InteractiveGaussian({
			root: component.root,
			store: component.store,
			data: interactivegaussian_initial_data
		});

		component.refs.gauss = interactivegaussian;

		return {
			c: function c() {
				div = createElement("div");
				div_1 = createElement("div");
				div_1.innerHTML = "<h4>Marginalization (Y)</h4>";
				text_2 = createText("\n  ");
				div_2 = createElement("div");
				text_3 = createText("\n  ");
				div_3 = createElement("div");
				h4_1 = createElement("h4");
				text_4 = createText("Conditioning (X = ");
				text_5 = createText(text_5_value);
				text_6 = createText(")");
				text_8 = createText("\n  ");
				div_4 = createElement("div");
				svg$$1 = createSvgElement("svg");
				path$$1 = createSvgElement("path");
				text_9 = createSvgElement("text");
				text_10 = createText("μ");
				tspan = createSvgElement("tspan");
				text_11 = createText("Y");
				text_12 = createText(" = ");
				text_13 = createText(text_13_value);
				text_14 = createSvgElement("text");
				text_15 = createText("σ");
				tspan_1 = createSvgElement("tspan");
				text_16 = createText("Y");
				text_17 = createText(" = ");
				text_18 = createText(text_18_value);
				text_20 = createText("\n  ");
				div_5 = createElement("div");
				svg_1 = createSvgElement("svg");
				interactivegaussian._fragment.c();
				line$$1 = createSvgElement("line");
				circle$$1 = createSvgElement("circle");
				text_21 = createSvgElement("text");
				text_22 = createText("X = ");
				text_23 = createText(text_23_value);
				text_25 = createText("\n  ");
				div_6 = createElement("div");
				svg_2 = createSvgElement("svg");
				path_1 = createSvgElement("path");
				text_26 = createSvgElement("text");
				text_27 = createText("μ");
				tspan_2 = createSvgElement("tspan");
				text_28 = createText("Y|X");
				text_29 = createText(" = ");
				text_30 = createText(text_30_value);
				text_31 = createSvgElement("text");
				text_32 = createText("σ");
				tspan_3 = createSvgElement("tspan");
				text_33 = createText("Y|X");
				text_34 = createText(" = ");
				text_35 = createText(text_35_value);
				div_1.className = "grid-item svelte-yvfo7n";
				div_2.className = "grid-item svelte-yvfo7n";
				div_3.className = "grid-item svelte-yvfo7n";
				setAttribute(path$$1, "d", ctx.marginalizedPath);
				setAttribute(path$$1, "class", "curve svelte-yvfo7n");
				setAttribute(tspan, "class", "ss svelte-yvfo7n");
				setAttribute(text_9, "x", text_9_x_value = ctx.sideWidth - 42);
				setAttribute(text_9, "y", text_9_y_value = toV$1(ctx.context, ctx.marginalizedGauss.mean.get(0, 0)));
				setAttribute(text_9, "class", "annotation");
				setAttribute(tspan_1, "class", "ss svelte-yvfo7n");
				setAttribute(text_14, "x", "5");
				setAttribute(text_14, "y", text_14_y_value = ctx.context.height - 10);
				setAttribute(text_14, "class", "annotation");
				setAttribute(svg$$1, "width", ctx.sideWidth);
				setAttribute(svg$$1, "height", svg_height_value = ctx.context.height);
				setAttribute(svg$$1, "class", "plot");
				div_4.className = "grid-item svelte-yvfo7n";
				setAttribute(line$$1, "class", "line svelte-yvfo7n");
				setAttribute(line$$1, "x1", line_x__value = ctx.condPos[0]);
				setAttribute(line$$1, "y1", "0");
				setAttribute(line$$1, "x2", line_x__value_1 = ctx.condPos[0]);
				setAttribute(line$$1, "y2", line_y__value = ctx.context.height);
				setAttribute(circle$$1, "class", "handle svelte-yvfo7n");
				setAttribute(circle$$1, "cx", circle_cx_value = ctx.condPos[0]);
				setAttribute(circle$$1, "cy", circle_cy_value = ctx.condPos[1]);
				setAttribute(circle$$1, "r", "4");
				setAttribute(text_21, "x", text_21_x_value = ctx.condPos[0] + 5);
				setAttribute(text_21, "y", text_21_y_value = ctx.condPos[1]);
				setAttribute(text_21, "class", "annotation handle svelte-yvfo7n");
				setAttribute(svg_1, "width", svg_1_width_value = ctx.context.width);
				setAttribute(svg_1, "height", svg_1_height_value = ctx.context.height);
				setAttribute(svg_1, "class", "plot");
				div_5.className = "grid-item svelte-yvfo7n";
				setAttribute(path_1, "d", ctx.conditionedPath);
				setAttribute(path_1, "class", "line svelte-yvfo7n");
				setAttribute(tspan_2, "class", "ss svelte-yvfo7n");
				setAttribute(text_26, "x", "5");
				setAttribute(text_26, "y", text_26_y_value = toV$1(ctx.context, ctx.conditionedGauss.mean.get(0, 0)));
				setAttribute(text_26, "class", "annotation");
				setAttribute(tspan_3, "class", "ss svelte-yvfo7n");
				setAttribute(text_31, "x", "5");
				setAttribute(text_31, "y", text_31_y_value = ctx.context.height - 10);
				setAttribute(text_31, "class", "annotation");
				setAttribute(svg_2, "width", ctx.sideWidth);
				setAttribute(svg_2, "height", svg_2_height_value = ctx.context.height);
				setAttribute(svg_2, "class", "plot");
				div_6.className = "grid-item svelte-yvfo7n";
				div.className = "gauss-grid svelte-yvfo7n";
			},
			m: function m(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(div_1, div);
				appendNode(text_2, div);
				appendNode(div_2, div);
				appendNode(text_3, div);
				appendNode(div_3, div);
				appendNode(h4_1, div_3);
				appendNode(text_4, h4_1);
				appendNode(text_5, h4_1);
				appendNode(text_6, h4_1);
				appendNode(text_8, div);
				appendNode(div_4, div);
				appendNode(svg$$1, div_4);
				appendNode(path$$1, svg$$1);
				appendNode(text_9, svg$$1);
				appendNode(text_10, text_9);
				appendNode(tspan, text_9);
				appendNode(text_11, tspan);
				appendNode(text_12, text_9);
				appendNode(text_13, text_9);
				appendNode(text_14, svg$$1);
				appendNode(text_15, text_14);
				appendNode(tspan_1, text_14);
				appendNode(text_16, tspan_1);
				appendNode(text_17, text_14);
				appendNode(text_18, text_14);
				appendNode(text_20, div);
				appendNode(div_5, div);
				appendNode(svg_1, div_5);
				interactivegaussian._mount(svg_1, null);
				appendNode(line$$1, svg_1);
				appendNode(circle$$1, svg_1);
				component.refs.handle = circle$$1;
				appendNode(text_21, svg_1);
				appendNode(text_22, text_21);
				appendNode(text_23, text_21);
				appendNode(text_25, div);
				appendNode(div_6, div);
				appendNode(svg_2, div_6);
				appendNode(path_1, svg_2);
				appendNode(text_26, svg_2);
				appendNode(text_27, text_26);
				appendNode(tspan_2, text_26);
				appendNode(text_28, tspan_2);
				appendNode(text_29, text_26);
				appendNode(text_30, text_26);
				appendNode(text_31, svg_2);
				appendNode(text_32, text_31);
				appendNode(tspan_3, text_31);
				appendNode(text_33, tspan_3);
				appendNode(text_34, text_31);
				appendNode(text_35, text_31);
			},
			p: function p(changed, ctx) {
				if (changed.cond && text_5_value !== (text_5_value = twoDecimals$1(ctx.cond))) {
					text_5.data = text_5_value;
				}

				if (changed.marginalizedPath) {
					setAttribute(path$$1, "d", ctx.marginalizedPath);
				}

				if (changed.marginalizedGauss && text_13_value !== (text_13_value = twoDecimals$1(ctx.marginalizedGauss.mean.get(0, 0)))) {
					text_13.data = text_13_value;
				}

				if (changed.sideWidth && text_9_x_value !== (text_9_x_value = ctx.sideWidth - 42)) {
					setAttribute(text_9, "x", text_9_x_value);
				}

				if ((changed.context || changed.marginalizedGauss) && text_9_y_value !== (text_9_y_value = toV$1(ctx.context, ctx.marginalizedGauss.mean.get(0, 0)))) {
					setAttribute(text_9, "y", text_9_y_value);
				}

				if (changed.marginalizedGauss && text_18_value !== (text_18_value = twoDecimals$1(ctx.marginalizedGauss.cov.get(0, 0)))) {
					text_18.data = text_18_value;
				}

				if (changed.context && text_14_y_value !== (text_14_y_value = ctx.context.height - 10)) {
					setAttribute(text_14, "y", text_14_y_value);
				}

				if (changed.sideWidth) {
					setAttribute(svg$$1, "width", ctx.sideWidth);
				}

				if (changed.context && svg_height_value !== (svg_height_value = ctx.context.height)) {
					setAttribute(svg$$1, "height", svg_height_value);
				}

				var interactivegaussian_changes = {};
				if (changed.context) interactivegaussian_changes.context = ctx.context;
				if (changed.gaussian) interactivegaussian_changes.sigma1 = ctx.gaussian.cov.get(0, 0);
				if (changed.gaussian) interactivegaussian_changes.sigma2 = ctx.gaussian.cov.get(1, 1);
				if (changed.gaussian) interactivegaussian_changes.cov = ctx.gaussian.cov.get(0, 1);
				if (changed.limits) interactivegaussian_changes.limits = ctx.limits;
				interactivegaussian._set(interactivegaussian_changes);

				if (changed.condPos && line_x__value !== (line_x__value = ctx.condPos[0])) {
					setAttribute(line$$1, "x1", line_x__value);
				}

				if (changed.condPos && line_x__value_1 !== (line_x__value_1 = ctx.condPos[0])) {
					setAttribute(line$$1, "x2", line_x__value_1);
				}

				if (changed.context && line_y__value !== (line_y__value = ctx.context.height)) {
					setAttribute(line$$1, "y2", line_y__value);
				}

				if (changed.condPos && circle_cx_value !== (circle_cx_value = ctx.condPos[0])) {
					setAttribute(circle$$1, "cx", circle_cx_value);
				}

				if (changed.condPos && circle_cy_value !== (circle_cy_value = ctx.condPos[1])) {
					setAttribute(circle$$1, "cy", circle_cy_value);
				}

				if (changed.cond && text_23_value !== (text_23_value = twoDecimals$1(ctx.cond))) {
					text_23.data = text_23_value;
				}

				if (changed.condPos && text_21_x_value !== (text_21_x_value = ctx.condPos[0] + 5)) {
					setAttribute(text_21, "x", text_21_x_value);
				}

				if (changed.condPos && text_21_y_value !== (text_21_y_value = ctx.condPos[1])) {
					setAttribute(text_21, "y", text_21_y_value);
				}

				if (changed.context && svg_1_width_value !== (svg_1_width_value = ctx.context.width)) {
					setAttribute(svg_1, "width", svg_1_width_value);
				}

				if (changed.context && svg_1_height_value !== (svg_1_height_value = ctx.context.height)) {
					setAttribute(svg_1, "height", svg_1_height_value);
				}

				if (changed.conditionedPath) {
					setAttribute(path_1, "d", ctx.conditionedPath);
				}

				if (changed.conditionedGauss && text_30_value !== (text_30_value = twoDecimals$1(ctx.conditionedGauss.mean.get(0, 0)))) {
					text_30.data = text_30_value;
				}

				if ((changed.context || changed.conditionedGauss) && text_26_y_value !== (text_26_y_value = toV$1(ctx.context, ctx.conditionedGauss.mean.get(0, 0)))) {
					setAttribute(text_26, "y", text_26_y_value);
				}

				if (changed.marginalizedGauss && text_35_value !== (text_35_value = twoDecimals$1(ctx.marginalizedGauss.cov.get(0, 0)))) {
					text_35.data = text_35_value;
				}

				if (changed.context && text_31_y_value !== (text_31_y_value = ctx.context.height - 10)) {
					setAttribute(text_31, "y", text_31_y_value);
				}

				if (changed.sideWidth) {
					setAttribute(svg_2, "width", ctx.sideWidth);
				}

				if (changed.context && svg_2_height_value !== (svg_2_height_value = ctx.context.height)) {
					setAttribute(svg_2, "height", svg_2_height_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				interactivegaussian.destroy();
				if (component.refs.gauss === interactivegaussian) component.refs.gauss = null;
				if (component.refs.handle === circle$$1) component.refs.handle = null;
			}
		};
	}

	function MarginalizationConditioning(options) {
		var _this2 = this;

		init(this, options);
		this.refs = {};
		this._state = assign(data$6(), options.data);
		this._recompute({ context: 1, cond: 1, gaussian: 1, sideWidth: 1 }, this._state);
		this._intro = true;

		if (!document.getElementById("svelte-yvfo7n-style")) add_css$4();

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$6(this, this._state);

		this.root._oncreate.push(function () {
			oncreate$3.call(_this2);
			_this2.fire("update", { changed: assignTrue({}, _this2._state), current: _this2._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(MarginalizationConditioning.prototype, proto);

	MarginalizationConditioning.prototype._recompute = function _recompute(changed, state) {
		if (changed.context || changed.cond) {
			if (this._differs(state.condPos, state.condPos = condPos(state))) changed.condPos = true;
		}

		if (changed.gaussian || changed.cond) {
			if (this._differs(state.conditionedGauss, state.conditionedGauss = conditionedGauss(state))) changed.conditionedGauss = true;
		}

		if (changed.context || changed.gaussian || changed.cond || changed.sideWidth) {
			if (this._differs(state.conditionedPath, state.conditionedPath = conditionedPath(state))) changed.conditionedPath = true;
		}

		if (changed.gaussian) {
			if (this._differs(state.marginalizedGauss, state.marginalizedGauss = marginalizedGauss(state))) changed.marginalizedGauss = true;
		}

		if (changed.context || changed.gaussian || changed.sideWidth) {
			if (this._differs(state.marginalizedPath, state.marginalizedPath = marginalizedPath(state))) changed.marginalizedPath = true;
		}
	};

	/* src/scripts/components/KernelCovMat.html generated by Svelte v2.9.1 */

	//  import * as cp from '../components/covarianceMatrix';

	function axisScale(_ref) {
	  var colorScale = _ref.colorScale;

	  return linear$3().domain(colorScale.domain()).range([0, 1]);
	}

	function grid(_ref2) {
	  var n = _ref2.n;

	  return new Array(n * n);
	}

	function data$7() {
	  return {
	    name: 'RBF',
	    kernel: rbf,
	    params: [{
	      name: 'Sigma',
	      value: 1,
	      min: 0,
	      max: 1
	    }, {
	      name: 'Length',
	      value: 1,
	      min: 0,
	      max: 2
	    }],
	    interaction: false,
	    slider: true,
	    covMatrix: [],
	    n: 25,
	    width: 150,
	    height: 150,
	    hoveredRow: -1,
	    hoveredRowIdx: -1,
	    colorsRow: [],
	    showText: false,
	    offset: 0,
	    gridSize: 6,
	    invertColor: true,
	    xs: [],
	    external: false,
	    shouldResample: true,
	    colorScale: sequential(GnBu).domain([1, 0]),
	    gridNode: -1

	  };
	}
	var methods$1 = {
	  updateSlider: function updateSlider(value, name, ref) {
	    this.set({ shouldResample: true });
	    this.root.resample();
	    this.root.set({
	      currentSelectedParameter: value,
	      currentSelectedKernel: name,
	      currentSelectedRef: ref,
	      shadows: []
	    });
	  },
	  getValue: function getValue(value) {
	    var _get = this.get(),
	        params = _get.params;

	    if (value > params.max) {
	      return params.max;
	    } else if (value < params.min) {
	      return params.min;
	    }
	    return value;
	  },
	  hoverGrid: function hoverGrid(currData, parent) {
	    var _get2 = this.get(),
	        gridSize = _get2.gridSize,
	        offset = _get2.offset;

	    var diag = 0;
	    if (currData.column == currData.row) {
	      diag = currData.column;
	    } else if (currData.column > currData.row) {
	      diag = Math.min(currData.column, currData.row);
	    } else if (currData.column < currData.row) {
	      diag = Math.max(currData.column, currData.row);
	    }

	    var selectedRect = parent.selectAll('.covSelectedRect');

	    selectedRect.attr('x', offset + diag * (gridSize + offset)).attr('y', offset + diag * (gridSize + offset));

	    parent.selectAll('.covSelectedRectRow').attr('x', function (d, i) {
	      return offset + i * (gridSize + offset);
	    }).attr('y', offset + diag * (gridSize + offset));
	  },
	  returnColor: function returnColor(value, invert) {
	    var result = void 0;

	    var _get3 = this.get(),
	        colorScale = _get3.colorScale,
	        axisScale = _get3.axisScale;

	    if (invert) {
	      result = colorScale(axisScale.invert(value));
	    } else {
	      result = colorScale(axisScale(value));
	    }
	    return result;
	  },
	  updateCovMat: function updateCovMat() {
	    var currentObject = this;

	    var _currentObject$get = currentObject.get(),
	        showText = _currentObject$get.showText,
	        covMatrix$$1 = _currentObject$get.covMatrix,
	        grid = _currentObject$get.grid,
	        gridNode = _currentObject$get.gridNode;

	    var svg$$1 = select(this.refs.covMat);

	    var covarianceMat = covMatrix$$1;

	    //create Vis
	    var count = 0;
	    for (var i = 0; i < covarianceMat.length; i++) {
	      var row = covarianceMat[i];
	      for (var j = 0; j < row.length; j++) {
	        grid[count] = { row: i, column: j, cov: covarianceMat[i][j] };
	        count++;
	      }
	    }

	    //// Matrix Rect
	    //Data Join
	    var gridD3 = gridNode.data(grid);

	    gridD3.exit().remove();

	    gridD3.style('fill', function (d) {
	      return currentObject.returnColor(d.cov);
	    });

	    this.set({ gridNode: gridNode });

	    if (showText === 1) {
	      //// Matrix Text
	      //Data Join
	      svg$$1.selectAll('text').data(grid).text(function (d) {
	        return Math.round(d.cov * 10) / 10;
	      });
	    }
	  },
	  externalCov: function externalCov(covMat) {
	    this.set({ covMatrix: covMat });
	    this.updateCovMat();
	  },
	  internalCov: function internalCov() {
	    var _get4 = this.get(),
	        n = _get4.n,
	        params = _get4.params,
	        kernel = _get4.kernel;

	    var _get5 = this.get(),
	        xs = _get5.xs;

	    var xmin = -5;
	    var xmax = 5;

	    xs = sequence(0, n).map(linear$3().domain([0, n]).range([xmin, xmax]));
	    var paramValues = params.map(function (p) {
	      return p.value;
	    });
	    var fn = kernel.apply(null, paramValues);
	    var covMat = covMatrix(xs, fn);
	    this.set({ covMatrix: covMat, xs: xs });
	    this.updateCovMat();
	  }
	};

	function oncreate$4() {
	  var _get6 = this.get(),
	      params = _get6.params,
	      kernel = _get6.kernel,
	      n = _get6.n;

	  var currentObject = this;

	  var _get7 = this.get(),
	      xs = _get7.xs;

	  var xmin = -5;
	  var xmax = 5;

	  xs = sequence(0, n).map(linear$3().domain([0, n]).range([xmin, xmax]));
	  var paramValues = params.map(function (p) {
	    return p.value;
	  });
	  var fn = kernel.apply(null, paramValues);
	  var covMat = covMatrix(xs, fn);

	  var _currentObject$get2 = currentObject.get(),
	      gridSize = _currentObject$get2.gridSize,
	      offset = _currentObject$get2.offset,
	      width = _currentObject$get2.width,
	      height = _currentObject$get2.height,
	      interaction = _currentObject$get2.interaction,
	      showText = _currentObject$get2.showText,
	      grid = _currentObject$get2.grid;

	  var _currentObject$get3 = currentObject.get(),
	      hoveredRow = _currentObject$get3.hoveredRow,
	      hoveredRowIdx = _currentObject$get3.hoveredRowIdx,
	      gridNode = _currentObject$get3.gridNode;

	  var svg$$1 = select(this.refs.covMat).attr('width', width + offset).attr('height', height + offset);

	  var covarianceMat = covMat;

	  //create Vis
	  var count = 0;
	  for (var i = 0; i < covarianceMat.length; i++) {
	    var row = covarianceMat[i];
	    for (var j = 0; j < row.length; j++) {
	      grid[count] = { row: i, column: j, cov: covarianceMat[i][j] };
	      count++;
	    }
	  }

	  //// Matrix Rect
	  //Data Join
	  gridNode = svg$$1.selectAll('.covRect');

	  var gridD3 = gridNode.data(grid);

	  //Exit
	  gridD3.exit().remove();

	  //Enter
	  gridD3.enter().append('rect').attr('class', 'covRect').attr('width', gridSize).attr('height', gridSize).attr('x', function (d) {
	    return offset + d.column * (gridSize + offset);
	  }).attr('y', function (d) {
	    return offset + d.row * (gridSize + offset);
	  }).style('fill', function (d) {
	    var newColor = currentObject.returnColor(d.cov);
	    return newColor;
	  });

	  //Update
	  gridD3.style('fill', function (d) {
	    return currentObject.returnColor(d.cov);
	  });

	  gridNode = svg$$1.selectAll('.covRect');

	  this.set({ gridNode: gridNode });

	  if (showText === 1) {
	    //// Matrix Text
	    //Data Join
	    var gridText = svg$$1.selectAll('text').data(grid);

	    //Exit
	    gridText.exit().remove();

	    //Enter
	    gridText.enter().append('text').attr('class', 'covText').style('font-size', Math.min(2 * gridSize / 3, 2 * gridSize / 3 - 8) + 'px').attr('x', function (d) {
	      return d.column * (gridSize + offset) + gridSize / 2;
	    }).attr('y', function (d) {
	      return d.row * (gridSize + offset) + gridSize / 2;
	    }).style('dominant-baseline', 'central').style('alignment-baseline', 'central').style('text-anchor', 'middle').text(function (d) {
	      return Math.round(d.cov * 10) / 10;
	    });
	    //update
	    gridText.text(function (d) {
	      return Math.round(d.cov * 10) / 10;
	    });
	  }
	  if (interaction) {
	    svg$$1.append('rect').classed('covSelectedRect', true).attr('width', gridSize + offset).attr('height', gridSize + offset).style('stroke-width', 1 + 'px').style('stroke-opacity', '1').style('stroke', 'black').style('opacity', 0).style('fill', 'none');

	    svg$$1.selectAll('covSelectedRectRow').data(Array.from(Array(n).keys())).enter().append('rect').classed('covSelectedRectRow', true).attr('width', gridSize + offset).attr('height', gridSize + offset).style('stroke-width', 1 + 'px').style('stroke-opacity', '0.5').style('stroke', 'black').style('opacity', 0).style('fill', 'none');

	    svg$$1.selectAll('.covRect').on('mouseover', function (d) {
	      var parent = select(select(this).node().parentNode.parentNode);
	      parent.selectAll('.covSelectedRect').style('opacity', 1);
	      parent.selectAll('.covSelectedRectRow').style('opacity', 1);
	      currentObject.hoverGrid(d, parent);
	      hoveredRow = d;
	      var colorsRow = svg$$1.selectAll('.covRect').filter(function (h) {
	        if (h.row === d.row) {
	          hoveredRowIdx = h.row;
	        }
	        return h.row === d.row;
	      });
	      var result2 = colorsRow.data();
	      currentObject.set({
	        colorsRow: result2,
	        hoveredRow: hoveredRow,
	        hoveredRowIdx: hoveredRowIdx,
	        shouldResample: false
	      });
	    });
	    svg$$1.on('mouseleave', function (d) {
	      var parent = select(select(this).node().parentNode.parentNode);
	      parent.selectAll('.covSelectedRect').style('opacity', 0);
	      parent.selectAll('.covSelectedRectRow').style('opacity', 0);
	      currentObject.set({ colorsRow: [], hoveredRow: -1, hoveredRowIdx: -1, shouldResample: false });
	    });
	  }
	}
	function onupdate(_ref3) {
	  var changed = _ref3.changed,
	      current = _ref3.current,
	      previous = _ref3.previous;

	  var _get8 = this.get(),
	      n = _get8.n,
	      params = _get8.params,
	      kernel = _get8.kernel,
	      external = _get8.external;

	  if (!external) {
	    var _get9 = this.get(),
	        xs = _get9.xs;

	    var xmin = -5;
	    var xmax = 5;

	    xs = sequence(0, n).map(linear$3().domain([0, n]).range([xmin, xmax]));
	    var paramValues = params.map(function (p) {
	      return p.value;
	    });
	    var fn = kernel.apply(null, paramValues);
	    var covMat = covMatrix(xs, fn);
	    this.set({ covMatrix: covMat, xs: xs, shouldResample: false });
	    this.updateCovMat();
	  }
	}
	function add_css$5() {
	  var style = createElement("style");
	  style.id = 'svelte-vt7mch-style';
	  style.textContent = "input.svelte-vt7mch{font-size:12px}.svelte-ref-covMat.svelte-vt7mch{background:none}.entry.svelte-vt7mch{max-width:40px;border:0px solid;background-color:transparent}.labelSlider.svelte-vt7mch{text-align:right;max-width:80px;border:0px solid;background-color:transparent}";
	  appendNode(style, document.head);
	}

	function create_main_fragment$7(component, ctx) {
	  var div, svg$$1, text_1, if_block_anchor;

	  var if_block = ctx.slider && create_if_block$1(component, ctx);

	  return {
	    c: function c() {
	      div = createElement("div");
	      svg$$1 = createSvgElement("svg");
	      text_1 = createText("\n");
	      if (if_block) if_block.c();
	      if_block_anchor = createComment();
	      setAttribute(svg$$1, "class", "plot svelte-vt7mch svelte-ref-covMat");
	      setAttribute(svg$$1, "xmlns:bind", "http://www.w3.org/1999/xhtml");
	    },
	    m: function m(target, anchor) {
	      insertNode(div, target, anchor);
	      appendNode(svg$$1, div);
	      component.refs.covMat = svg$$1;
	      insertNode(text_1, target, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insertNode(if_block_anchor, target, anchor);
	    },
	    p: function p(changed, ctx) {
	      if (ctx.slider) {
	        if (if_block) {
	          if_block.p(changed, ctx);
	        } else {
	          if_block = create_if_block$1(component, ctx);
	          if_block.c();
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }
	    },
	    d: function d(detach) {
	      if (detach) {
	        detachNode(div);
	      }

	      if (component.refs.covMat === svg$$1) component.refs.covMat = null;
	      if (detach) {
	        detachNode(text_1);
	      }

	      if (if_block) if_block.d(detach);
	      if (detach) {
	        detachNode(if_block_anchor);
	      }
	    }
	  };
	}

	// (5:0) {#each params as p}
	function create_each_block$3(component, ctx) {
	  var div,
	      p,
	      input,
	      input_updating = false,
	      text$$1,
	      input_1,
	      input_1_updating = false,
	      input_1_min_value,
	      input_1_max_value,
	      text_1,
	      input_2,
	      input_2_min_value,
	      input_2_max_value;

	  function input_input_handler() {
	    input_updating = true;
	    ctx.each_value[ctx.p_index].name = input.value;
	    component.set({ params: ctx.params });
	    input_updating = false;
	  }

	  function input_1_input_handler() {
	    input_1_updating = true;
	    ctx.each_value[ctx.p_index].value = input_1.value;
	    component.set({ params: ctx.params });
	    input_1_updating = false;
	  }

	  function input_2_change_input_handler() {
	    ctx.each_value[ctx.p_index].value = toNumber(input_2.value);
	    component.set({ params: ctx.params });
	  }

	  return {
	    c: function c() {
	      div = createElement("div");
	      p = createElement("p");
	      input = createElement("input");
	      text$$1 = createText(" = ");
	      input_1 = createElement("input");
	      text_1 = createText("\n  ");
	      input_2 = createElement("input");
	      addListener(input, "input", input_input_handler);
	      input.disabled = true;
	      input.className = "labelSlider svelte-vt7mch";
	      addListener(input_1, "input", input_1_input_handler);
	      input_1.disabled = true;
	      input_1.className = "entry svelte-vt7mch";
	      input_1.min = input_1_min_value = ctx.p.min;
	      input_1.max = input_1_max_value = ctx.p.max;
	      p.className = "label";

	      input_2._svelte = { component: component, ctx: ctx };

	      addListener(input_2, "change", input_2_change_input_handler);
	      addListener(input_2, "input", input_2_change_input_handler);
	      addListener(input_2, "change", change_handler);
	      setAttribute(input_2, "type", "range");
	      input_2.min = input_2_min_value = ctx.p.min;
	      input_2.max = input_2_max_value = ctx.p.max;
	      input_2.step = "0.01";
	      input_2.className = "svelte-vt7mch";
	    },
	    m: function m(target, anchor) {
	      insertNode(div, target, anchor);
	      appendNode(p, div);
	      appendNode(input, p);

	      input.value = ctx.p.name;

	      appendNode(text$$1, p);
	      appendNode(input_1, p);

	      input_1.value = ctx.p.value;

	      appendNode(text_1, div);
	      appendNode(input_2, div);

	      input_2.value = ctx.p.value;
	    },
	    p: function p(changed, _ctx) {
	      ctx = _ctx;
	      if (!input_updating) input.value = ctx.p.name;
	      if (!input_1_updating) input_1.value = ctx.p.value;
	      if (changed.params && input_1_min_value !== (input_1_min_value = ctx.p.min)) {
	        input_1.min = input_1_min_value;
	      }

	      if (changed.params && input_1_max_value !== (input_1_max_value = ctx.p.max)) {
	        input_1.max = input_1_max_value;
	      }

	      input_2._svelte.ctx = ctx;
	      input_2.value = ctx.p.value;
	      if (changed.params && input_2_min_value !== (input_2_min_value = ctx.p.min)) {
	        input_2.min = input_2_min_value;
	      }

	      if (changed.params && input_2_max_value !== (input_2_max_value = ctx.p.max)) {
	        input_2.max = input_2_max_value;
	      }
	    },
	    d: function d(detach) {
	      if (detach) {
	        detachNode(div);
	      }

	      removeListener(input, "input", input_input_handler);
	      removeListener(input_1, "input", input_1_input_handler);
	      removeListener(input_2, "change", input_2_change_input_handler);
	      removeListener(input_2, "input", input_2_change_input_handler);
	      removeListener(input_2, "change", change_handler);
	    }
	  };
	}

	// (4:0) {#if slider}
	function create_if_block$1(component, ctx) {
	  var each_anchor;

	  var each_value = ctx.params;

	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$3(component, get_each_context$3(ctx, each_value, i));
	  }

	  return {
	    c: function c() {
	      for (var i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }

	      each_anchor = createComment();
	    },
	    m: function m(target, anchor) {
	      for (var i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].m(target, anchor);
	      }

	      insertNode(each_anchor, target, anchor);
	    },
	    p: function p(changed, ctx) {
	      if (changed.params || changed.name) {
	        each_value = ctx.params;

	        for (var i = 0; i < each_value.length; i += 1) {
	          var child_ctx = get_each_context$3(ctx, each_value, i);

	          if (each_blocks[i]) {
	            each_blocks[i].p(changed, child_ctx);
	          } else {
	            each_blocks[i] = create_each_block$3(component, child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(each_anchor.parentNode, each_anchor);
	          }
	        }

	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }
	    },
	    d: function d(detach) {
	      destroyEach(each_blocks, detach);

	      if (detach) {
	        detachNode(each_anchor);
	      }
	    }
	  };
	}

	function get_each_context$3(ctx, list, i) {
	  var child_ctx = Object.create(ctx);
	  child_ctx.p = list[i];
	  child_ctx.each_value = list;
	  child_ctx.p_index = i;
	  return child_ctx;
	}

	function change_handler(event$$1) {
	  var _svelte = this._svelte,
	      component = _svelte.component,
	      ctx = _svelte.ctx;


	  component.updateSlider(ctx.p, ctx.name, this);
	}

	function KernelCovMat(options) {
	  var _this = this;

	  init(this, options);
	  this.refs = {};
	  this._state = assign(data$7(), options.data);
	  this._recompute({ colorScale: 1, n: 1 }, this._state);
	  this._intro = true;
	  this._handlers.update = [onupdate];

	  if (!document.getElementById("svelte-vt7mch-style")) add_css$5();

	  if (!options.root) {
	    this._oncreate = [];
	  }

	  this._fragment = create_main_fragment$7(this, this._state);

	  this.root._oncreate.push(function () {
	    oncreate$4.call(_this);
	    _this.fire("update", { changed: assignTrue({}, _this._state), current: _this._state });
	  });

	  if (options.target) {
	    this._fragment.c();
	    this._mount(options.target, options.anchor);

	    callAll(this._oncreate);
	  }
	}

	assign(KernelCovMat.prototype, proto);
	assign(KernelCovMat.prototype, methods$1);

	KernelCovMat.prototype._recompute = function _recompute(changed, state) {
	  if (changed.colorScale) {
	    if (this._differs(state.axisScale, state.axisScale = axisScale(state))) changed.axisScale = true;
	  }

	  if (changed.n) {
	    if (this._differs(state.grid, state.grid = grid(state))) changed.grid = true;
	  }
	};

	/* src/scripts/components/MultipleKernels.html generated by Svelte v2.9.1 */

	var rbf$1 = {
		kernel: rbf,
		name: 'RBF Kernel',
		equation: '\\sigma^2 \\exp \\left( - \\frac{||t-t\'||^2}{2 l^2} \\right)',
		params: [{
			name: 'Variance σ',
			description: 'the average distance away from the function\'s mean.',
			value: 0.8,
			min: 0,
			max: 1
		}, {
			name: 'Length l',
			description: 'the reach of influence on neighbors.',
			value: 0.8,
			min: 0.01,
			max: 2
		}]
	};

	var periodic$1 = {
		kernel: periodic,
		name: 'Periodic',
		equation: '\\sigma^2 \\exp \\left( - \\frac{2 \\sin^2(\\pi |t-t\'| / p)}{l^2} \\right)',
		params: [{
			name: 'Variance σ',
			description: 'the average distance away from the function\'s mean.',
			value: 0.8,
			min: 0,
			max: 1
		}, {
			name: 'Length l',
			description: 'the reach of influence on neighbors.',
			value: 0.8,
			min: 0.01,
			max: 2
		}, {
			name: 'Periodicity p',
			description: 'the distance between repetitions.',
			value: 0.5,
			min: 0,
			max: Math.PI
		}]
	};

	var linear$5 = {
		kernel: linear$4,
		name: 'Linear',
		equation: '\\sigma_b^2 + \\sigma^2 (t - c)(t\' - c)',
		params: [{
			name: 'Variance σ',
			description: 'the average distance away from the function\'s mean.',
			value: 0.3,
			min: 0,
			max: 1
		}, {
			name: 'Variance σ_b',
			description: 'the certainty around C.',
			value: 0.8,
			min: 0,
			max: 1
		}, {
			name: 'Offset c',
			description: 'the intersection point of all functions.',
			value: 0,
			min: -2,
			max: 2
		}]
	};

	function connectedline(_ref) {
		var context = _ref.context;

		return line().curve(stepBefore).x(function (d) {
			return d[0];
		}).y(function (d) {
			return d[1];
		});
	}

	function data$8() {
		return {
			kernels: [rbf$1, periodic$1, linear$5],
			scale: sequential(GnBu),
			currentSelectedParameter: { description: '...', name: '...' },
			currentSelectedKernel: '',
			currentSelectedRef: ''
		};
	}
	var methods$2 = {
		resample: function resample() {}
	};

	function oncreate$5() {
		var svg$$1 = select(this.refs.annotations);

		//Enter
		svg$$1.append('path').classed('lineConnector', true).attr('stroke', 'rgba(0, 0, 0, 0.2)').attr('fill', 'transparent').style('stroke-width', '2px').style('stroke-dasharray', 4);

		select(this.refs.description).style('opacity', 0);
	}
	function onupdate$1(_ref2) {
		var _changed = _ref2._changed,
		    current = _ref2.current,
		    _previous = _ref2._previous;

		var svg$$1 = select(this.refs.annotations);

		var _get = this.get(),
		    currentSelectedRef = _get.currentSelectedRef;

		if (currentSelectedRef != '') {
			var labelRect = currentSelectedRef.getBoundingClientRect();
			var positionX1 = labelRect.left - this.refs.annotations.getBoundingClientRect().left + labelRect.width / 2;
			var positionY1 = labelRect.top - this.refs.annotations.getBoundingClientRect().top - labelRect.height;
			svg$$1.select('.lineConnector').attr('d', function (d) {
				return current.connectedline([[positionX1, positionY1 - 5], [positionX1, positionY1 - 20], [30, positionY1 - 20], [30, 15], [40, 15]]);
			});
			select(this.refs.description).style('opacity', 1);
		}
	}
	function add_css$6() {
		var style = createElement("style");
		style.id = 'svelte-znq9s9-style';
		style.textContent = ".svelte-ref-annotations.svelte-znq9s9{position:absolute;pointer-events:none;margin:1em;right:-200px;bottom:5px;overflow:visible}.svelte-ref-padder.svelte-znq9s9{padding-top:108px\n    }.kernel-grid.svelte-znq9s9{display:inline-grid;grid-template-columns:auto auto auto auto}.grid-item.svelte-znq9s9{margin:0.5em}.equation.svelte-znq9s9{padding-bottom:1em;height:36px}";
		appendNode(style, document.head);
	}

	function create_main_fragment$8(component, ctx) {
		var div,
		    text$$1,
		    div_1,
		    div_2,
		    text_3,
		    svg$$1,
		    text_4,
		    tspan,
		    text_5,
		    tspan_1,
		    text_6,
		    text_7,
		    tspan_2,
		    text_8,
		    tspan_3,
		    text_9_value = ctx.currentSelectedParameter.name,
		    text_9,
		    text_10,
		    tspan_4,
		    text_11_value = ctx.currentSelectedParameter.description,
		    text_11;

		var each_value = ctx.kernels;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$4(component, get_each_context$4(ctx, each_value, i));
		}

		var colorscale_initial_data = { colorScale: ctx.scale };
		var colorscale = new ColorScale({
			root: component.root,
			store: component.store,
			data: colorscale_initial_data
		});

		return {
			c: function c() {
				div = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text$$1 = createText("\n  ");
				div_1 = createElement("div");
				div_2 = createElement("div");
				colorscale._fragment.c();
				text_3 = createText("\n");
				svg$$1 = createSvgElement("svg");
				text_4 = createSvgElement("text");
				tspan = createSvgElement("tspan");
				text_5 = createText("For the\n      ");
				tspan_1 = createSvgElement("tspan");
				text_6 = createText(ctx.currentSelectedKernel);
				text_7 = createText("\n      kernel");
				tspan_2 = createSvgElement("tspan");
				text_8 = createText("the parameter\n      ");
				tspan_3 = createSvgElement("tspan");
				text_9 = createText(text_9_value);
				text_10 = createText("\n      determines");
				tspan_4 = createSvgElement("tspan");
				text_11 = createText(text_11_value);
				div_2.className = "svelte-znq9s9 svelte-ref-padder";
				div_1.className = "grid-item svelte-znq9s9";
				div.className = "kernel-grid svelte-znq9s9";
				setAttribute(tspan_1, "font-weight", "bold");
				setAttribute(tspan, "x", "50");
				setAttribute(tspan, "dy", "1.5em");
				setAttribute(tspan_3, "font-weight", "bold");
				setAttribute(tspan_2, "x", "50");
				setAttribute(tspan_2, "dy", "1.5em");
				setAttribute(tspan_4, "x", "50");
				setAttribute(tspan_4, "dy", "1.5em");
				setAttribute(text_4, "class", "annotation");
				setAttribute(svg$$1, "width", "300");
				setAttribute(svg$$1, "height", "150");
				setAttribute(svg$$1, "class", "svelte-znq9s9 svelte-ref-annotations");
			},
			m: function m(target, anchor) {
				insertNode(div, target, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div, null);
				}

				appendNode(text$$1, div);
				appendNode(div_1, div);
				appendNode(div_2, div_1);
				colorscale._mount(div_2, null);
				component.refs.padder = div_2;
				component.refs.gridMultipleKernel = div;
				insertNode(text_3, target, anchor);
				insertNode(svg$$1, target, anchor);
				appendNode(text_4, svg$$1);
				appendNode(tspan, text_4);
				appendNode(text_5, tspan);
				appendNode(tspan_1, tspan);
				appendNode(text_6, tspan_1);
				appendNode(text_7, tspan);
				appendNode(tspan_2, text_4);
				appendNode(text_8, tspan_2);
				appendNode(tspan_3, tspan_2);
				appendNode(text_9, tspan_3);
				appendNode(text_10, tspan_2);
				appendNode(tspan_4, text_4);
				appendNode(text_11, tspan_4);
				component.refs.description = text_4;
				component.refs.annotations = svg$$1;
			},
			p: function p(changed, ctx) {
				if (changed.kernels) {
					each_value = ctx.kernels;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context$4(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$4(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, text$$1);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				var colorscale_changes = {};
				if (changed.scale) colorscale_changes.colorScale = ctx.scale;
				colorscale._set(colorscale_changes);

				if (changed.currentSelectedKernel) {
					text_6.data = ctx.currentSelectedKernel;
				}

				if (changed.currentSelectedParameter && text_9_value !== (text_9_value = ctx.currentSelectedParameter.name)) {
					text_9.data = text_9_value;
				}

				if (changed.currentSelectedParameter && text_11_value !== (text_11_value = ctx.currentSelectedParameter.description)) {
					text_11.data = text_11_value;
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				destroyEach(each_blocks, detach);

				colorscale.destroy();
				if (component.refs.padder === div_2) component.refs.padder = null;
				if (component.refs.gridMultipleKernel === div) component.refs.gridMultipleKernel = null;
				if (detach) {
					detachNode(text_3);
					detachNode(svg$$1);
				}

				if (component.refs.description === text_4) component.refs.description = null;
				if (component.refs.annotations === svg$$1) component.refs.annotations = null;
			}
		};
	}

	// (2:0) {#each kernels as k}
	function create_each_block$4(component, ctx) {
		var div,
		    div_1,
		    h4,
		    text_value = ctx.k.name,
		    text$$1,
		    text_1,
		    div_2,
		    d_math,
		    text_2_value = ctx.k.equation,
		    text_2,
		    text_3,
		    div_3;

		var kernelcovmat_initial_data = {
			kernel: ctx.k.kernel,
			params: ctx.k.params,
			name: ctx.k.name
		};
		var kernelcovmat = new KernelCovMat({
			root: component.root,
			store: component.store,
			data: kernelcovmat_initial_data
		});

		return {
			c: function c() {
				div = createElement("div");
				div_1 = createElement("div");
				h4 = createElement("h4");
				text$$1 = createText(text_value);
				text_1 = createText("\n    ");
				div_2 = createElement("div");
				d_math = createElement("d-math");
				text_2 = createText(text_2_value);
				text_3 = createText("\n    ");
				div_3 = createElement("div");
				kernelcovmat._fragment.c();
				div_2.className = "equation svelte-znq9s9";
				div.className = "grid-item svelte-znq9s9";
			},
			m: function m(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(div_1, div);
				appendNode(h4, div_1);
				appendNode(text$$1, h4);
				appendNode(text_1, div);
				appendNode(div_2, div);
				appendNode(d_math, div_2);
				appendNode(text_2, d_math);
				appendNode(text_3, div);
				appendNode(div_3, div);
				kernelcovmat._mount(div_3, null);
			},
			p: function p(changed, ctx) {
				if (changed.kernels && text_value !== (text_value = ctx.k.name)) {
					text$$1.data = text_value;
				}

				if (changed.kernels && text_2_value !== (text_2_value = ctx.k.equation)) {
					text_2.data = text_2_value;
				}

				var kernelcovmat_changes = {};
				if (changed.kernels) kernelcovmat_changes.kernel = ctx.k.kernel;
				if (changed.kernels) kernelcovmat_changes.params = ctx.k.params;
				if (changed.kernels) kernelcovmat_changes.name = ctx.k.name;
				kernelcovmat._set(kernelcovmat_changes);
			},
			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				kernelcovmat.destroy();
			}
		};
	}

	function get_each_context$4(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.k = list[i];
		child_ctx.each_value = list;
		child_ctx.k_index = i;
		return child_ctx;
	}

	function MultipleKernels(options) {
		var _this = this;

		init(this, options);
		this.refs = {};
		this._state = assign(data$8(), options.data);
		this._recompute({ context: 1 }, this._state);
		this._intro = true;
		this._handlers.update = [onupdate$1];

		if (!document.getElementById("svelte-znq9s9-style")) add_css$6();

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$8(this, this._state);

		this.root._oncreate.push(function () {
			oncreate$5.call(_this);
			_this.fire("update", { changed: assignTrue({}, _this._state), current: _this._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(MultipleKernels.prototype, proto);
	assign(MultipleKernels.prototype, methods$2);

	MultipleKernels.prototype._recompute = function _recompute(changed, state) {
		if (changed.context) {
			if (this._differs(state.connectedline, state.connectedline = connectedline(state))) changed.connectedline = true;
		}
	};

	/* src/scripts/components/PriorFigure.html generated by Svelte v2.9.1 */

	var color$1 = sequential(RdPu).domain([-1, 10]);

	function data$9() {
		return {
			bs: 8,
			xs: sequence(0, 10)
		};
	}
	function idxColor(idx) {
		return color$1(idx);
	}
	function add_css$7() {
		var style = createElement("style");
		style.id = 'svelte-1gfbgft-style';
		style.textContent = ".dashed.svelte-1gfbgft{stroke:rgba(0,0,0,0.4);stroke-dasharray:4}";
		appendNode(style, document.head);
	}

	function create_main_fragment$9(component, ctx) {
		var svg$$1, g, rect, text$$1, text_1, tspan, text_2, tspan_1, tspan_2, text_3, text_4, tspan_3, text_5, text_6, tspan_4, text_7, text_8, tspan_5, text_9, g_1, text_10, tspan_6, text_11, g_2, line$$1, line_x__value, line_y__value, line_x__value_1, line_y__value_1, line_1, line_1_y__value, line_1_x__value, line_1_y__value_1, line_1_x__value_1, g_3, text_12, text_13, tspan_7, text_14, text_15, tspan_8, text_16, text_17, text_18, text_19, rect_1, rect_2, text_20, text_21, tspan_9, text_22, tspan_10, text_23, tspan_11, text_24, g_4, rect_3, text_25, text_26, tspan_12, text_27, tspan_13, text_28, tspan_14, text_29;

		var each_value = ctx.xs;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$5(component, get_each_context$5(ctx, each_value, i));
		}

		var each_value_1 = ctx.xs;

		var each_1_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_1_blocks[i] = create_each_block_1(component, get_each_1_context(ctx, each_value_1, i));
		}

		var each_value_2 = ctx.xs;

		var each_2_blocks = [];

		for (var i = 0; i < each_value_2.length; i += 1) {
			each_2_blocks[i] = create_each_block_2(component, get_each_2_context(ctx, each_value_2, i));
		}

		return {
			c: function c() {
				svg$$1 = createSvgElement("svg");
				g = createSvgElement("g");
				rect = createSvgElement("rect");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text$$1 = createSvgElement("text");
				text_1 = createText("We are interested in predicting the\n    ");
				tspan = createSvgElement("tspan");
				text_2 = createText("function values for 10 different");
				tspan_1 = createSvgElement("tspan");
				tspan_2 = createSvgElement("tspan");
				text_3 = createText("x");
				text_4 = createText(" values from [");
				tspan_3 = createSvgElement("tspan");
				text_5 = createText("■");
				text_6 = createText(",");
				tspan_4 = createSvgElement("tspan");
				text_7 = createText("■");
				text_8 = createText("] without");
				tspan_5 = createSvgElement("tspan");
				text_9 = createText("knowing about training points.");
				g_1 = createSvgElement("g");
				text_10 = createSvgElement("text");
				tspan_6 = createSvgElement("tspan");
				text_11 = createText("Covariance matrix");
				g_2 = createSvgElement("g");
				line$$1 = createSvgElement("line");
				line_1 = createSvgElement("line");
				g_3 = createSvgElement("g");
				text_12 = createSvgElement("text");
				text_13 = createText("= k(");
				tspan_7 = createSvgElement("tspan");
				text_14 = createText("■");
				text_15 = createText(",");
				tspan_8 = createSvgElement("tspan");
				text_16 = createText("■");
				text_17 = createText(")");
				text_18 = createSvgElement("text");
				text_19 = createText("10x10");
				rect_1 = createSvgElement("rect");

				for (var i = 0; i < each_1_blocks.length; i += 1) {
					each_1_blocks[i].c();
				}

				rect_2 = createSvgElement("rect");
				text_20 = createSvgElement("text");
				text_21 = createText("The covariance matrix is\n    ");
				tspan_9 = createSvgElement("tspan");
				text_22 = createText("created by pairwise evaluation");
				tspan_10 = createSvgElement("tspan");
				text_23 = createText("of the kernel function resulting");
				tspan_11 = createSvgElement("tspan");
				text_24 = createText("in a 10-dimensional distribution.");
				g_4 = createSvgElement("g");
				rect_3 = createSvgElement("rect");

				for (var i = 0; i < each_2_blocks.length; i += 1) {
					each_2_blocks[i].c();
				}

				text_25 = createSvgElement("text");
				text_26 = createText("Sampling from this distribution\n    ");
				tspan_12 = createSvgElement("tspan");
				text_27 = createText("results in a 10-dimensional vector");
				tspan_13 = createSvgElement("tspan");
				text_28 = createText("where each entry represents");
				tspan_14 = createSvgElement("tspan");
				text_29 = createText("one function value.");
				setAttribute(rect, "x", "0");
				setAttribute(rect, "y", "0");
				setAttribute(rect, "width", "200");
				setAttribute(rect, "height", "150");
				setAttribute(rect, "fill", "rgb(252, 252, 252)");
				setAttribute(rect, "stroke", "rgba(0, 0, 0, 0.1)");
				setAttribute(tspan, "x", "0");
				setAttribute(tspan, "dy", "1.5em");
				setAttribute(tspan_2, "font-style", "italic");
				setAttribute(tspan_3, "fill", idxColor(0));
				setAttribute(tspan_4, "fill", idxColor(9));
				setAttribute(tspan_1, "x", "0");
				setAttribute(tspan_1, "dy", "1.5em");
				setAttribute(tspan_5, "x", "0");
				setAttribute(tspan_5, "dy", "1.5em");
				setAttribute(text$$1, "x", "0");
				setAttribute(text$$1, "y", "195");
				setAttribute(text$$1, "class", "annotation");
				setAttribute(g, "transform", "translate(1,1)");
				setAttribute(tspan_6, "font-weight", "bold");
				setAttribute(text_10, "x", "0");
				setAttribute(text_10, "y", "11");
				setAttribute(text_10, "class", "annotation");
				setAttribute(line$$1, "class", "dashed svelte-1gfbgft");
				setAttribute(line$$1, "x1", line_x__value = 12 * 2 + 12 + ctx.bs / 2);
				setAttribute(line$$1, "y1", line_y__value = ctx.bs / 2);
				setAttribute(line$$1, "x2", line_x__value_1 = 12 * 2 + 12 + ctx.bs / 2);
				setAttribute(line$$1, "y2", line_y__value_1 = 12 * 5 + 12 + ctx.bs / 2);
				setAttribute(line_1, "class", "dashed svelte-1gfbgft");
				setAttribute(line_1, "y1", line_1_y__value = 12 * 5 + 12 + ctx.bs / 2);
				setAttribute(line_1, "x1", line_1_x__value = ctx.bs / 2);
				setAttribute(line_1, "y2", line_1_y__value_1 = 12 * 5 + 12 + ctx.bs / 2);
				setAttribute(line_1, "x2", line_1_x__value_1 = 12 * 2 + 12 + ctx.bs / 2);
				setAttribute(tspan_7, "fill", idxColor(5));
				setAttribute(tspan_8, "fill", idxColor(2));
				setAttribute(text_12, "x", "0");
				setAttribute(text_12, "y", "0");
				setAttribute(text_12, "class", "annotation");
				setAttribute(text_18, "x", "40");
				setAttribute(text_18, "y", "43");
				setAttribute(text_18, "class", "annotation");
				setAttribute(g_3, "transform", "translate(50,80)");
				setAttribute(rect_1, "x", "12");
				setAttribute(rect_1, "y", "12");
				setAttribute(rect_1, "width", "116");
				setAttribute(rect_1, "height", "116");
				setAttribute(rect_1, "stroke", "black");
				setAttribute(rect_1, "fill", "transparent");
				setAttribute(rect_2, "x", 12 * 2 + 12);
				setAttribute(rect_2, "y", 12 * 5 + 12);
				setAttribute(rect_2, "width", ctx.bs);
				setAttribute(rect_2, "height", ctx.bs);
				setAttribute(rect_2, "fill", "grey");
				setAttribute(g_2, "transform", "translate(0,25)");
				setAttribute(tspan_9, "x", "0");
				setAttribute(tspan_9, "dy", "1.5em");
				setAttribute(tspan_10, "x", "0");
				setAttribute(tspan_10, "dy", "1.5em");
				setAttribute(tspan_11, "x", "0");
				setAttribute(tspan_11, "dy", "1.5em");
				setAttribute(text_20, "x", "0");
				setAttribute(text_20, "y", "195");
				setAttribute(text_20, "class", "annotation");
				setAttribute(g_1, "transform", "translate(260,0)");
				setAttribute(rect_3, "x", "0");
				setAttribute(rect_3, "y", "0");
				setAttribute(rect_3, "width", "200");
				setAttribute(rect_3, "height", "150");
				setAttribute(rect_3, "fill", "rgb(252, 252, 252)");
				setAttribute(rect_3, "stroke", "rgba(0, 0, 0, 0.1)");
				setAttribute(tspan_12, "x", "0");
				setAttribute(tspan_12, "dy", "1.5em");
				setAttribute(tspan_13, "x", "0");
				setAttribute(tspan_13, "dy", "1.5em");
				setAttribute(tspan_14, "x", "0");
				setAttribute(tspan_14, "dy", "1.5em");
				setAttribute(text_25, "x", "0");
				setAttribute(text_25, "y", "195");
				setAttribute(text_25, "class", "annotation");
				setAttribute(g_4, "transform", "translate(490,1)");
				setAttribute(svg$$1, "width", "700");
				setAttribute(svg$$1, "height", "280");
			},
			m: function m(target, anchor) {
				insertNode(svg$$1, target, anchor);
				appendNode(g, svg$$1);
				appendNode(rect, g);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(g, null);
				}

				appendNode(text$$1, g);
				appendNode(text_1, text$$1);
				appendNode(tspan, text$$1);
				appendNode(text_2, tspan);
				appendNode(tspan_1, text$$1);
				appendNode(tspan_2, tspan_1);
				appendNode(text_3, tspan_2);
				appendNode(text_4, tspan_1);
				appendNode(tspan_3, tspan_1);
				appendNode(text_5, tspan_3);
				appendNode(text_6, tspan_1);
				appendNode(tspan_4, tspan_1);
				appendNode(text_7, tspan_4);
				appendNode(text_8, tspan_1);
				appendNode(tspan_5, text$$1);
				appendNode(text_9, tspan_5);
				appendNode(g_1, svg$$1);
				appendNode(text_10, g_1);
				appendNode(tspan_6, text_10);
				appendNode(text_11, tspan_6);
				appendNode(g_2, g_1);
				appendNode(line$$1, g_2);
				appendNode(line_1, g_2);
				appendNode(g_3, g_2);
				appendNode(text_12, g_3);
				appendNode(text_13, text_12);
				appendNode(tspan_7, text_12);
				appendNode(text_14, tspan_7);
				appendNode(text_15, text_12);
				appendNode(tspan_8, text_12);
				appendNode(text_16, tspan_8);
				appendNode(text_17, text_12);
				appendNode(text_18, g_3);
				appendNode(text_19, text_18);
				appendNode(rect_1, g_2);

				for (var i = 0; i < each_1_blocks.length; i += 1) {
					each_1_blocks[i].m(g_2, null);
				}

				appendNode(rect_2, g_2);
				appendNode(text_20, g_1);
				appendNode(text_21, text_20);
				appendNode(tspan_9, text_20);
				appendNode(text_22, tspan_9);
				appendNode(tspan_10, text_20);
				appendNode(text_23, tspan_10);
				appendNode(tspan_11, text_20);
				appendNode(text_24, tspan_11);
				appendNode(g_4, svg$$1);
				appendNode(rect_3, g_4);

				for (var i = 0; i < each_2_blocks.length; i += 1) {
					each_2_blocks[i].m(g_4, null);
				}

				appendNode(text_25, g_4);
				appendNode(text_26, text_25);
				appendNode(tspan_12, text_25);
				appendNode(text_27, tspan_12);
				appendNode(tspan_13, text_25);
				appendNode(text_28, tspan_13);
				appendNode(tspan_14, text_25);
				appendNode(text_29, tspan_14);
			},
			p: function p(changed, ctx) {
				if (changed.xs || changed.bs) {
					each_value = ctx.xs;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context$5(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$5(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(g, text$$1);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (changed.bs && line_x__value !== (line_x__value = 12 * 2 + 12 + ctx.bs / 2)) {
					setAttribute(line$$1, "x1", line_x__value);
				}

				if (changed.bs && line_y__value !== (line_y__value = ctx.bs / 2)) {
					setAttribute(line$$1, "y1", line_y__value);
				}

				if (changed.bs && line_x__value_1 !== (line_x__value_1 = 12 * 2 + 12 + ctx.bs / 2)) {
					setAttribute(line$$1, "x2", line_x__value_1);
				}

				if (changed.bs && line_y__value_1 !== (line_y__value_1 = 12 * 5 + 12 + ctx.bs / 2)) {
					setAttribute(line$$1, "y2", line_y__value_1);
				}

				if (changed.bs && line_1_y__value !== (line_1_y__value = 12 * 5 + 12 + ctx.bs / 2)) {
					setAttribute(line_1, "y1", line_1_y__value);
				}

				if (changed.bs && line_1_x__value !== (line_1_x__value = ctx.bs / 2)) {
					setAttribute(line_1, "x1", line_1_x__value);
				}

				if (changed.bs && line_1_y__value_1 !== (line_1_y__value_1 = 12 * 5 + 12 + ctx.bs / 2)) {
					setAttribute(line_1, "y2", line_1_y__value_1);
				}

				if (changed.bs && line_1_x__value_1 !== (line_1_x__value_1 = 12 * 2 + 12 + ctx.bs / 2)) {
					setAttribute(line_1, "x2", line_1_x__value_1);
				}

				if (changed.xs || changed.bs) {
					each_value_1 = ctx.xs;

					for (var i = 0; i < each_value_1.length; i += 1) {
						var _child_ctx = get_each_1_context(ctx, each_value_1, i);

						if (each_1_blocks[i]) {
							each_1_blocks[i].p(changed, _child_ctx);
						} else {
							each_1_blocks[i] = create_each_block_1(component, _child_ctx);
							each_1_blocks[i].c();
							each_1_blocks[i].m(g_2, rect_2);
						}
					}

					for (; i < each_1_blocks.length; i += 1) {
						each_1_blocks[i].d(1);
					}
					each_1_blocks.length = each_value_1.length;
				}

				if (changed.bs) {
					setAttribute(rect_2, "width", ctx.bs);
					setAttribute(rect_2, "height", ctx.bs);
				}

				if (changed.xs || changed.bs || changed.Math) {
					each_value_2 = ctx.xs;

					for (var i = 0; i < each_value_2.length; i += 1) {
						var _child_ctx2 = get_each_2_context(ctx, each_value_2, i);

						if (each_2_blocks[i]) {
							each_2_blocks[i].p(changed, _child_ctx2);
						} else {
							each_2_blocks[i] = create_each_block_2(component, _child_ctx2);
							each_2_blocks[i].c();
							each_2_blocks[i].m(g_4, text_25);
						}
					}

					for (; i < each_2_blocks.length; i += 1) {
						each_2_blocks[i].d(1);
					}
					each_2_blocks.length = each_value_2.length;
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(svg$$1);
				}

				destroyEach(each_blocks, detach);

				destroyEach(each_1_blocks, detach);

				destroyEach(each_2_blocks, detach);
			}
		};
	}

	// (4:4) {#each xs as x}
	function create_each_block$5(component, ctx) {
		var rect, rect_x_value, rect_fill_value;

		var if_block = ctx.x == 5 && create_if_block$2(component, ctx);

		return {
			c: function c() {
				if (if_block) if_block.c();
				rect = createSvgElement("rect");
				setAttribute(rect, "x", rect_x_value = 20 * ctx.x + 6);
				setAttribute(rect, "y", "158");
				setAttribute(rect, "width", ctx.bs);
				setAttribute(rect, "height", ctx.bs);
				setAttribute(rect, "fill", rect_fill_value = idxColor(ctx.x));
			},
			m: function m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insertNode(rect, target, anchor);
			},
			p: function p(changed, ctx) {
				if (ctx.x == 5) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$2(component, ctx);
						if_block.c();
						if_block.m(rect.parentNode, rect);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.xs && rect_x_value !== (rect_x_value = 20 * ctx.x + 6)) {
					setAttribute(rect, "x", rect_x_value);
				}

				if (changed.bs) {
					setAttribute(rect, "width", ctx.bs);
					setAttribute(rect, "height", ctx.bs);
				}

				if (changed.xs && rect_fill_value !== (rect_fill_value = idxColor(ctx.x))) {
					setAttribute(rect, "fill", rect_fill_value);
				}
			},
			d: function d(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(rect);
				}
			}
		};
	}

	// (5:4) {#if x == 5}
	function create_if_block$2(component, ctx) {
		var text$$1, tspan, text_1, text_x_value, line$$1, line_x__value, line_x__value_1;

		return {
			c: function c() {
				text$$1 = createSvgElement("text");
				tspan = createSvgElement("tspan");
				text_1 = createText("f(x) = ?");
				line$$1 = createSvgElement("line");
				setAttribute(tspan, "font-weight", "bold");
				setAttribute(text$$1, "x", text_x_value = 20 * ctx.x + 6);
				setAttribute(text$$1, "y", "90");
				setAttribute(text$$1, "class", "annotation");
				setAttribute(line$$1, "class", "dashed svelte-1gfbgft");
				setAttribute(line$$1, "x1", line_x__value = 20 * ctx.x + ctx.bs / 2 + 6);
				setAttribute(line$$1, "y1", "158");
				setAttribute(line$$1, "x2", line_x__value_1 = 20 * ctx.x + ctx.bs / 2 + 6);
				setAttribute(line$$1, "y2", "95");
				setAttribute(line$$1, "stroke", "grey");
			},
			m: function m(target, anchor) {
				insertNode(text$$1, target, anchor);
				appendNode(tspan, text$$1);
				appendNode(text_1, tspan);
				insertNode(line$$1, target, anchor);
			},
			p: function p(changed, ctx) {
				if (changed.xs && text_x_value !== (text_x_value = 20 * ctx.x + 6)) {
					setAttribute(text$$1, "x", text_x_value);
				}

				if ((changed.xs || changed.bs) && line_x__value !== (line_x__value = 20 * ctx.x + ctx.bs / 2 + 6)) {
					setAttribute(line$$1, "x1", line_x__value);
				}

				if ((changed.xs || changed.bs) && line_x__value_1 !== (line_x__value_1 = 20 * ctx.x + ctx.bs / 2 + 6)) {
					setAttribute(line$$1, "x2", line_x__value_1);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(text$$1);
					detachNode(line$$1);
				}
			}
		};
	}

	// (29:6) {#each xs as x}
	function create_each_block_1(component, ctx) {
		var rect, rect_x_value, rect_fill_value, rect_1, rect_1_y_value, rect_1_fill_value;

		return {
			c: function c() {
				rect = createSvgElement("rect");
				rect_1 = createSvgElement("rect");
				setAttribute(rect, "x", rect_x_value = 12 * ctx.x + 12);
				setAttribute(rect, "y", "0");
				setAttribute(rect, "width", ctx.bs);
				setAttribute(rect, "height", ctx.bs);
				setAttribute(rect, "fill", rect_fill_value = idxColor(ctx.x));
				setAttribute(rect_1, "x", "0");
				setAttribute(rect_1, "y", rect_1_y_value = 12 * ctx.x + 12);
				setAttribute(rect_1, "width", ctx.bs);
				setAttribute(rect_1, "height", ctx.bs);
				setAttribute(rect_1, "fill", rect_1_fill_value = idxColor(ctx.x));
			},
			m: function m(target, anchor) {
				insertNode(rect, target, anchor);
				insertNode(rect_1, target, anchor);
			},
			p: function p(changed, ctx) {
				if (changed.xs && rect_x_value !== (rect_x_value = 12 * ctx.x + 12)) {
					setAttribute(rect, "x", rect_x_value);
				}

				if (changed.bs) {
					setAttribute(rect, "width", ctx.bs);
					setAttribute(rect, "height", ctx.bs);
				}

				if (changed.xs && rect_fill_value !== (rect_fill_value = idxColor(ctx.x))) {
					setAttribute(rect, "fill", rect_fill_value);
				}

				if (changed.xs && rect_1_y_value !== (rect_1_y_value = 12 * ctx.x + 12)) {
					setAttribute(rect_1, "y", rect_1_y_value);
				}

				if (changed.bs) {
					setAttribute(rect_1, "width", ctx.bs);
					setAttribute(rect_1, "height", ctx.bs);
				}

				if (changed.xs && rect_1_fill_value !== (rect_1_fill_value = idxColor(ctx.x))) {
					setAttribute(rect_1, "fill", rect_1_fill_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(rect);
					detachNode(rect_1);
				}
			}
		};
	}

	// (45:4) {#each xs as x}
	function create_each_block_2(component, ctx) {
		var line$$1, line_x__value, line_x__value_1, line_y__value, circle$$1, circle_cx_value, circle_cy_value, circle_r_value, rect, rect_x_value, rect_fill_value;

		return {
			c: function c() {
				line$$1 = createSvgElement("line");
				circle$$1 = createSvgElement("circle");
				rect = createSvgElement("rect");
				setAttribute(line$$1, "class", "dashed svelte-1gfbgft");
				setAttribute(line$$1, "x1", line_x__value = 20 * ctx.x + ctx.bs / 2 + 6);
				setAttribute(line$$1, "y1", "158");
				setAttribute(line$$1, "x2", line_x__value_1 = 20 * ctx.x + ctx.bs / 2 + 6);
				setAttribute(line$$1, "y2", line_y__value = ctx.Math.sin(ctx.x / 2) * 20 + 90);
				setAttribute(line$$1, "stroke", "grey");
				setAttribute(circle$$1, "cx", circle_cx_value = 20 * ctx.x + ctx.bs / 2 + 6);
				setAttribute(circle$$1, "cy", circle_cy_value = ctx.Math.sin(ctx.x / 2) * 20 + 90);
				setAttribute(circle$$1, "r", circle_r_value = ctx.bs / 4);
				setAttribute(circle$$1, "fill", "grey");
				setAttribute(rect, "x", rect_x_value = 20 * ctx.x + 6);
				setAttribute(rect, "y", "158");
				setAttribute(rect, "width", ctx.bs);
				setAttribute(rect, "height", ctx.bs);
				setAttribute(rect, "fill", rect_fill_value = idxColor(ctx.x));
			},
			m: function m(target, anchor) {
				insertNode(line$$1, target, anchor);
				insertNode(circle$$1, target, anchor);
				insertNode(rect, target, anchor);
			},
			p: function p(changed, ctx) {
				if ((changed.xs || changed.bs) && line_x__value !== (line_x__value = 20 * ctx.x + ctx.bs / 2 + 6)) {
					setAttribute(line$$1, "x1", line_x__value);
				}

				if ((changed.xs || changed.bs) && line_x__value_1 !== (line_x__value_1 = 20 * ctx.x + ctx.bs / 2 + 6)) {
					setAttribute(line$$1, "x2", line_x__value_1);
				}

				if ((changed.Math || changed.xs) && line_y__value !== (line_y__value = ctx.Math.sin(ctx.x / 2) * 20 + 90)) {
					setAttribute(line$$1, "y2", line_y__value);
				}

				if ((changed.xs || changed.bs) && circle_cx_value !== (circle_cx_value = 20 * ctx.x + ctx.bs / 2 + 6)) {
					setAttribute(circle$$1, "cx", circle_cx_value);
				}

				if ((changed.Math || changed.xs) && circle_cy_value !== (circle_cy_value = ctx.Math.sin(ctx.x / 2) * 20 + 90)) {
					setAttribute(circle$$1, "cy", circle_cy_value);
				}

				if (changed.bs && circle_r_value !== (circle_r_value = ctx.bs / 4)) {
					setAttribute(circle$$1, "r", circle_r_value);
				}

				if (changed.xs && rect_x_value !== (rect_x_value = 20 * ctx.x + 6)) {
					setAttribute(rect, "x", rect_x_value);
				}

				if (changed.bs) {
					setAttribute(rect, "width", ctx.bs);
					setAttribute(rect, "height", ctx.bs);
				}

				if (changed.xs && rect_fill_value !== (rect_fill_value = idxColor(ctx.x))) {
					setAttribute(rect, "fill", rect_fill_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(line$$1);
					detachNode(circle$$1);
					detachNode(rect);
				}
			}
		};
	}

	function get_each_context$5(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.x = list[i];
		child_ctx.each_value = list;
		child_ctx.x_index = i;
		return child_ctx;
	}

	function get_each_1_context(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.x = list[i];
		child_ctx.each_value_1 = list;
		child_ctx.x_index_1 = i;
		return child_ctx;
	}

	function get_each_2_context(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.x = list[i];
		child_ctx.each_value_2 = list;
		child_ctx.x_index_2 = i;
		return child_ctx;
	}

	function PriorFigure(options) {
		init(this, options);
		this._state = assign(assign({ Math: Math }, data$9()), options.data);
		this._intro = true;

		if (!document.getElementById("svelte-1gfbgft-style")) add_css$7();

		this._fragment = create_main_fragment$9(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(PriorFigure.prototype, proto);

	/* src/scripts/components/PosteriorFigure.html generated by Svelte v2.9.1 */

	var color$2 = sequential(RdPu).domain([-1, 10]);

	function data$a() {
		return {
			bs: 8,
			xs: sequence(0, 10),
			xst: sequence(0, 12)
		};
	}
	function idxColor$1(idx) {
		return color$2(idx);
	}
	function add_css$8() {
		var style = createElement("style");
		style.id = 'svelte-1gfbgft-style';
		style.textContent = ".dashed.svelte-1gfbgft{stroke:rgba(0,0,0,0.4);stroke-dasharray:4}";
		appendNode(style, document.head);
	}

	function create_main_fragment$a(component, ctx) {
		var svg$$1, g, rect, line$$1, line_x__value, line_x__value_1, rect_1, circle$$1, circle_cx_value, circle_r_value, line_1, line_1_x__value, line_1_x__value_1, rect_2, circle_1, circle_1_cx_value, circle_1_r_value, text$$1, text_1, tspan, text_2, text_3, tspan_1, text_4, tspan_2, text_5, g_1, text_6, tspan_3, text_7, g_2, line_2, line_2_x__value, line_2_y__value, line_2_x__value_1, line_2_y__value_1, line_3, line_3_y__value, line_3_x__value, line_3_y__value_1, line_3_x__value_1, g_3, text_8, text_9, tspan_4, text_10, text_11, tspan_5, text_12, text_13, text_14, text_15, rect_3, rect_4, text_16, text_17, tspan_6, text_18, tspan_7, text_19, tspan_8, text_20, g_4, text_21, tspan_9, text_22, g_5, text_23, tspan_10, text_24, image$$1, text_25, text_26, rect_5, text_27, text_28, tspan_11, text_29, text_30, tspan_12, text_31, tspan_13, text_32, tspan_14, text_33, tspan_15, text_34, text_35;

		var each_value = ctx.xs;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$6(component, get_each_context$6(ctx, each_value, i));
		}

		var each_value_1 = ctx.xst;

		var each_1_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_1_blocks[i] = create_each_block_1$1(component, get_each_1_context$1(ctx, each_value_1, i));
		}

		var each_value_2 = ctx.xs;

		var each_2_blocks = [];

		for (var i = 0; i < each_value_2.length; i += 1) {
			each_2_blocks[i] = create_each_block_2$1(component, get_each_2_context$1(ctx, each_value_2, i));
		}

		return {
			c: function c() {
				svg$$1 = createSvgElement("svg");
				g = createSvgElement("g");
				rect = createSvgElement("rect");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				line$$1 = createSvgElement("line");
				rect_1 = createSvgElement("rect");
				circle$$1 = createSvgElement("circle");
				line_1 = createSvgElement("line");
				rect_2 = createSvgElement("rect");
				circle_1 = createSvgElement("circle");
				text$$1 = createSvgElement("text");
				text_1 = createText("Adding training points (");
				tspan = createSvgElement("tspan");
				text_2 = createText("■");
				text_3 = createText(") changes\n    ");
				tspan_1 = createSvgElement("tspan");
				text_4 = createText("the number of dimensions of the");
				tspan_2 = createSvgElement("tspan");
				text_5 = createText("multivariate Guassian distribution.");
				g_1 = createSvgElement("g");
				text_6 = createSvgElement("text");
				tspan_3 = createSvgElement("tspan");
				text_7 = createText("Covariance matrix");
				g_2 = createSvgElement("g");
				line_2 = createSvgElement("line");
				line_3 = createSvgElement("line");
				g_3 = createSvgElement("g");
				text_8 = createSvgElement("text");
				text_9 = createText("= k(");
				tspan_4 = createSvgElement("tspan");
				text_10 = createText("■");
				text_11 = createText(",");
				tspan_5 = createSvgElement("tspan");
				text_12 = createText("■");
				text_13 = createText(")");
				text_14 = createSvgElement("text");
				text_15 = createText("12x12");
				rect_3 = createSvgElement("rect");

				for (var i = 0; i < each_1_blocks.length; i += 1) {
					each_1_blocks[i].c();
				}

				rect_4 = createSvgElement("rect");
				text_16 = createSvgElement("text");
				text_17 = createText("The covariance matrix is\n    ");
				tspan_6 = createSvgElement("tspan");
				text_18 = createText("created by pairwise evaluation");
				tspan_7 = createSvgElement("tspan");
				text_19 = createText("of the kernel function resulting");
				tspan_8 = createSvgElement("tspan");
				text_20 = createText("in a 12-dimensional distribution.");
				g_4 = createSvgElement("g");
				text_21 = createSvgElement("text");
				tspan_9 = createSvgElement("tspan");
				text_22 = createText("Covariance matrix");
				g_5 = createSvgElement("g");
				text_23 = createSvgElement("text");
				tspan_10 = createSvgElement("tspan");
				text_24 = createText("conditioning");
				image$$1 = createSvgElement("image");
				text_25 = createSvgElement("text");
				text_26 = createText("10x10");
				rect_5 = createSvgElement("rect");

				for (var i = 0; i < each_2_blocks.length; i += 1) {
					each_2_blocks[i].c();
				}

				text_27 = createSvgElement("text");
				text_28 = createText("Through ");
				tspan_11 = createSvgElement("tspan");
				text_29 = createText("conditioning");
				text_30 = createText(" we obtain\n    ");
				tspan_12 = createSvgElement("tspan");
				text_31 = createText("the distribution that describes");
				tspan_13 = createSvgElement("tspan");
				text_32 = createText("the prediction of the function");
				tspan_14 = createSvgElement("tspan");
				text_33 = createText("values for the given ");
				tspan_15 = createSvgElement("tspan");
				text_34 = createText("x");
				text_35 = createText(" values.");
				setAttribute(rect, "x", "0");
				setAttribute(rect, "y", "0");
				setAttribute(rect, "width", "200");
				setAttribute(rect, "height", "150");
				setAttribute(rect, "fill", "rgb(252, 252, 252)");
				setAttribute(rect, "stroke", "rgba(0, 0, 0, 0.1)");
				setAttribute(line$$1, "class", "dashed svelte-1gfbgft");
				setAttribute(line$$1, "x1", line_x__value = 20 * 2 + 6 + 10 + ctx.bs / 2);
				setAttribute(line$$1, "y1", "158");
				setAttribute(line$$1, "x2", line_x__value_1 = 20 * 2 + 6 + 10 + ctx.bs / 2);
				setAttribute(line$$1, "y2", "50");
				setAttribute(rect_1, "x", 20 * 2 + 6 + 10);
				setAttribute(rect_1, "y", "158");
				setAttribute(rect_1, "width", ctx.bs);
				setAttribute(rect_1, "height", ctx.bs);
				setAttribute(rect_1, "fill", "rgb(245, 181, 62)");
				setAttribute(circle$$1, "cx", circle_cx_value = 20 * 2 + 6 + 10 + ctx.bs / 2);
				setAttribute(circle$$1, "cy", "50");
				setAttribute(circle$$1, "r", circle_r_value = ctx.bs / 2);
				setAttribute(circle$$1, "fill", "rgb(245, 181, 62)");
				setAttribute(line_1, "class", "dashed svelte-1gfbgft");
				setAttribute(line_1, "x1", line_1_x__value = 20 * 7 + 6 + 10 + ctx.bs / 2);
				setAttribute(line_1, "y1", "158");
				setAttribute(line_1, "x2", line_1_x__value_1 = 20 * 7 + 6 + 10 + ctx.bs / 2);
				setAttribute(line_1, "y2", "40");
				setAttribute(rect_2, "x", 20 * 7 + 6 + 10);
				setAttribute(rect_2, "y", "158");
				setAttribute(rect_2, "width", ctx.bs);
				setAttribute(rect_2, "height", ctx.bs);
				setAttribute(rect_2, "fill", "rgb(245, 181, 62)");
				setAttribute(circle_1, "cx", circle_1_cx_value = 20 * 7 + 6 + 10 + ctx.bs / 2);
				setAttribute(circle_1, "cy", "40");
				setAttribute(circle_1, "r", circle_1_r_value = ctx.bs / 2);
				setAttribute(circle_1, "fill", "rgb(245, 181, 62)");
				setAttribute(tspan, "fill", "rgb(245, 181, 62)");
				setAttribute(tspan_1, "x", "0");
				setAttribute(tspan_1, "dy", "1.5em");
				setAttribute(tspan_2, "x", "0");
				setAttribute(tspan_2, "dy", "1.5em");
				setAttribute(text$$1, "x", "0");
				setAttribute(text$$1, "y", "195");
				setAttribute(text$$1, "class", "annotation");
				setAttribute(g, "transform", "translate(1,1)");
				setAttribute(tspan_3, "font-weight", "bold");
				setAttribute(text_6, "x", "0");
				setAttribute(text_6, "y", "9");
				setAttribute(text_6, "class", "annotation");
				setAttribute(line_2, "class", "dashed svelte-1gfbgft");
				setAttribute(line_2, "x1", line_2_x__value = 12 * 1 + 12 + ctx.bs / 2);
				setAttribute(line_2, "y1", line_2_y__value = ctx.bs / 2);
				setAttribute(line_2, "x2", line_2_x__value_1 = 12 * 1 + 12 + ctx.bs / 2);
				setAttribute(line_2, "y2", line_2_y__value_1 = 12 * 5 + 12 + ctx.bs / 2);
				setAttribute(line_3, "class", "dashed svelte-1gfbgft");
				setAttribute(line_3, "y1", line_3_y__value = 12 * 5 + 12 + ctx.bs / 2);
				setAttribute(line_3, "x1", line_3_x__value = ctx.bs / 2);
				setAttribute(line_3, "y2", line_3_y__value_1 = 12 * 5 + 12 + ctx.bs / 2);
				setAttribute(line_3, "x2", line_3_x__value_1 = 12 * 1 + 12 + ctx.bs / 2);
				setAttribute(tspan_4, "fill", idxColor$1(5 - 2));
				setAttribute(tspan_5, "fill", "rgb(245, 181, 62)");
				setAttribute(text_8, "x", "0");
				setAttribute(text_8, "y", "0");
				setAttribute(text_8, "class", "annotation");
				setAttribute(g_3, "transform", "translate(34,80)");
				setAttribute(text_14, "x", "114");
				setAttribute(text_14, "y", "147");
				setAttribute(text_14, "class", "annotation");
				setAttribute(rect_3, "x", "12");
				setAttribute(rect_3, "y", "12");
				setAttribute(rect_3, "width", "140");
				setAttribute(rect_3, "height", "140");
				setAttribute(rect_3, "stroke", "black");
				setAttribute(rect_3, "fill", "transparent");
				setAttribute(rect_4, "x", 12 * 1 + 12);
				setAttribute(rect_4, "y", 12 * 5 + 12);
				setAttribute(rect_4, "width", ctx.bs);
				setAttribute(rect_4, "height", ctx.bs);
				setAttribute(rect_4, "fill", "grey");
				setAttribute(g_2, "transform", "translate(0,20)");
				setAttribute(tspan_6, "x", "0");
				setAttribute(tspan_6, "dy", "1.5em");
				setAttribute(tspan_7, "x", "0");
				setAttribute(tspan_7, "dy", "1.5em");
				setAttribute(tspan_8, "x", "0");
				setAttribute(tspan_8, "dy", "1.5em");
				setAttribute(text_16, "x", "0");
				setAttribute(text_16, "y", "195");
				setAttribute(text_16, "class", "annotation");
				setAttribute(g_1, "transform", "translate(260,0)");
				setAttribute(tspan_9, "font-weight", "bold");
				setAttribute(text_21, "x", "0");
				setAttribute(text_21, "y", "9");
				setAttribute(text_21, "class", "annotation");
				setAttribute(tspan_10, "fill", "rgb(245, 181, 62)");
				setAttribute(text_23, "x", "30");
				setAttribute(text_23, "y", "42");
				setAttribute(text_23, "class", "annotation");
				setAttribute(image$$1, "x", "20");
				setAttribute(image$$1, "y", "27");
				setAttribute(image$$1, "width", "100");
				setAttribute(image$$1, "height", "100");
				setXlinkAttribute(image$$1, "xlink:href", "images/process.svg");
				setAttribute(text_25, "x", "90");
				setAttribute(text_25, "y", "123");
				setAttribute(text_25, "class", "annotation");
				setAttribute(rect_5, "x", "12");
				setAttribute(rect_5, "y", "12");
				setAttribute(rect_5, "width", "116");
				setAttribute(rect_5, "height", "116");
				setAttribute(rect_5, "stroke", "black");
				setAttribute(rect_5, "fill", "transparent");
				setAttribute(g_5, "transform", "translate(0,20)");
				setAttribute(tspan_11, "font-weight", "bold");
				setAttribute(tspan_12, "x", "0");
				setAttribute(tspan_12, "dy", "1.5em");
				setAttribute(tspan_13, "x", "0");
				setAttribute(tspan_13, "dy", "1.5em");
				setAttribute(tspan_15, "font-style", "italic");
				setAttribute(tspan_14, "x", "0");
				setAttribute(tspan_14, "dy", "1.5em");
				setAttribute(text_27, "x", "0");
				setAttribute(text_27, "y", "195");
				setAttribute(text_27, "class", "annotation");
				setAttribute(g_4, "transform", "translate(490,0)");
				setAttribute(svg$$1, "width", "700");
				setAttribute(svg$$1, "height", "280");
			},
			m: function m(target, anchor) {
				insertNode(svg$$1, target, anchor);
				appendNode(g, svg$$1);
				appendNode(rect, g);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(g, null);
				}

				appendNode(line$$1, g);
				appendNode(rect_1, g);
				appendNode(circle$$1, g);
				appendNode(line_1, g);
				appendNode(rect_2, g);
				appendNode(circle_1, g);
				appendNode(text$$1, g);
				appendNode(text_1, text$$1);
				appendNode(tspan, text$$1);
				appendNode(text_2, tspan);
				appendNode(text_3, text$$1);
				appendNode(tspan_1, text$$1);
				appendNode(text_4, tspan_1);
				appendNode(tspan_2, text$$1);
				appendNode(text_5, tspan_2);
				appendNode(g_1, svg$$1);
				appendNode(text_6, g_1);
				appendNode(tspan_3, text_6);
				appendNode(text_7, tspan_3);
				appendNode(g_2, g_1);
				appendNode(line_2, g_2);
				appendNode(line_3, g_2);
				appendNode(g_3, g_2);
				appendNode(text_8, g_3);
				appendNode(text_9, text_8);
				appendNode(tspan_4, text_8);
				appendNode(text_10, tspan_4);
				appendNode(text_11, text_8);
				appendNode(tspan_5, text_8);
				appendNode(text_12, tspan_5);
				appendNode(text_13, text_8);
				appendNode(text_14, g_2);
				appendNode(text_15, text_14);
				appendNode(rect_3, g_2);

				for (var i = 0; i < each_1_blocks.length; i += 1) {
					each_1_blocks[i].m(g_2, null);
				}

				appendNode(rect_4, g_2);
				appendNode(text_16, g_1);
				appendNode(text_17, text_16);
				appendNode(tspan_6, text_16);
				appendNode(text_18, tspan_6);
				appendNode(tspan_7, text_16);
				appendNode(text_19, tspan_7);
				appendNode(tspan_8, text_16);
				appendNode(text_20, tspan_8);
				appendNode(g_4, svg$$1);
				appendNode(text_21, g_4);
				appendNode(tspan_9, text_21);
				appendNode(text_22, tspan_9);
				appendNode(g_5, g_4);
				appendNode(text_23, g_5);
				appendNode(tspan_10, text_23);
				appendNode(text_24, tspan_10);
				appendNode(image$$1, g_5);
				appendNode(text_25, g_5);
				appendNode(text_26, text_25);
				appendNode(rect_5, g_5);

				for (var i = 0; i < each_2_blocks.length; i += 1) {
					each_2_blocks[i].m(g_5, null);
				}

				appendNode(text_27, g_4);
				appendNode(text_28, text_27);
				appendNode(tspan_11, text_27);
				appendNode(text_29, tspan_11);
				appendNode(text_30, text_27);
				appendNode(tspan_12, text_27);
				appendNode(text_31, tspan_12);
				appendNode(tspan_13, text_27);
				appendNode(text_32, tspan_13);
				appendNode(tspan_14, text_27);
				appendNode(text_33, tspan_14);
				appendNode(tspan_15, tspan_14);
				appendNode(text_34, tspan_15);
				appendNode(text_35, tspan_14);
			},
			p: function p(changed, ctx) {
				if (changed.xs || changed.bs) {
					each_value = ctx.xs;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context$6(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$6(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(g, line$$1);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (changed.bs && line_x__value !== (line_x__value = 20 * 2 + 6 + 10 + ctx.bs / 2)) {
					setAttribute(line$$1, "x1", line_x__value);
				}

				if (changed.bs && line_x__value_1 !== (line_x__value_1 = 20 * 2 + 6 + 10 + ctx.bs / 2)) {
					setAttribute(line$$1, "x2", line_x__value_1);
				}

				if (changed.bs) {
					setAttribute(rect_1, "width", ctx.bs);
					setAttribute(rect_1, "height", ctx.bs);
				}

				if (changed.bs && circle_cx_value !== (circle_cx_value = 20 * 2 + 6 + 10 + ctx.bs / 2)) {
					setAttribute(circle$$1, "cx", circle_cx_value);
				}

				if (changed.bs && circle_r_value !== (circle_r_value = ctx.bs / 2)) {
					setAttribute(circle$$1, "r", circle_r_value);
				}

				if (changed.bs && line_1_x__value !== (line_1_x__value = 20 * 7 + 6 + 10 + ctx.bs / 2)) {
					setAttribute(line_1, "x1", line_1_x__value);
				}

				if (changed.bs && line_1_x__value_1 !== (line_1_x__value_1 = 20 * 7 + 6 + 10 + ctx.bs / 2)) {
					setAttribute(line_1, "x2", line_1_x__value_1);
				}

				if (changed.bs) {
					setAttribute(rect_2, "width", ctx.bs);
					setAttribute(rect_2, "height", ctx.bs);
				}

				if (changed.bs && circle_1_cx_value !== (circle_1_cx_value = 20 * 7 + 6 + 10 + ctx.bs / 2)) {
					setAttribute(circle_1, "cx", circle_1_cx_value);
				}

				if (changed.bs && circle_1_r_value !== (circle_1_r_value = ctx.bs / 2)) {
					setAttribute(circle_1, "r", circle_1_r_value);
				}

				if (changed.bs && line_2_x__value !== (line_2_x__value = 12 * 1 + 12 + ctx.bs / 2)) {
					setAttribute(line_2, "x1", line_2_x__value);
				}

				if (changed.bs && line_2_y__value !== (line_2_y__value = ctx.bs / 2)) {
					setAttribute(line_2, "y1", line_2_y__value);
				}

				if (changed.bs && line_2_x__value_1 !== (line_2_x__value_1 = 12 * 1 + 12 + ctx.bs / 2)) {
					setAttribute(line_2, "x2", line_2_x__value_1);
				}

				if (changed.bs && line_2_y__value_1 !== (line_2_y__value_1 = 12 * 5 + 12 + ctx.bs / 2)) {
					setAttribute(line_2, "y2", line_2_y__value_1);
				}

				if (changed.bs && line_3_y__value !== (line_3_y__value = 12 * 5 + 12 + ctx.bs / 2)) {
					setAttribute(line_3, "y1", line_3_y__value);
				}

				if (changed.bs && line_3_x__value !== (line_3_x__value = ctx.bs / 2)) {
					setAttribute(line_3, "x1", line_3_x__value);
				}

				if (changed.bs && line_3_y__value_1 !== (line_3_y__value_1 = 12 * 5 + 12 + ctx.bs / 2)) {
					setAttribute(line_3, "y2", line_3_y__value_1);
				}

				if (changed.bs && line_3_x__value_1 !== (line_3_x__value_1 = 12 * 1 + 12 + ctx.bs / 2)) {
					setAttribute(line_3, "x2", line_3_x__value_1);
				}

				if (changed.xst || changed.bs) {
					each_value_1 = ctx.xst;

					for (var i = 0; i < each_value_1.length; i += 1) {
						var _child_ctx = get_each_1_context$1(ctx, each_value_1, i);

						if (each_1_blocks[i]) {
							each_1_blocks[i].p(changed, _child_ctx);
						} else {
							each_1_blocks[i] = create_each_block_1$1(component, _child_ctx);
							each_1_blocks[i].c();
							each_1_blocks[i].m(g_2, rect_4);
						}
					}

					for (; i < each_1_blocks.length; i += 1) {
						each_1_blocks[i].d(1);
					}
					each_1_blocks.length = each_value_1.length;
				}

				if (changed.bs) {
					setAttribute(rect_4, "width", ctx.bs);
					setAttribute(rect_4, "height", ctx.bs);
				}

				if (changed.xs || changed.bs) {
					each_value_2 = ctx.xs;

					for (var i = 0; i < each_value_2.length; i += 1) {
						var _child_ctx2 = get_each_2_context$1(ctx, each_value_2, i);

						if (each_2_blocks[i]) {
							each_2_blocks[i].p(changed, _child_ctx2);
						} else {
							each_2_blocks[i] = create_each_block_2$1(component, _child_ctx2);
							each_2_blocks[i].c();
							each_2_blocks[i].m(g_5, null);
						}
					}

					for (; i < each_2_blocks.length; i += 1) {
						each_2_blocks[i].d(1);
					}
					each_2_blocks.length = each_value_2.length;
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(svg$$1);
				}

				destroyEach(each_blocks, detach);

				destroyEach(each_1_blocks, detach);

				destroyEach(each_2_blocks, detach);
			}
		};
	}

	// (4:4) {#each xs as x}
	function create_each_block$6(component, ctx) {
		var rect, rect_x_value, rect_fill_value;

		var if_block = ctx.x == 4 && create_if_block$3(component, ctx);

		return {
			c: function c() {
				if (if_block) if_block.c();
				rect = createSvgElement("rect");
				setAttribute(rect, "x", rect_x_value = 20 * ctx.x + 6);
				setAttribute(rect, "y", "158");
				setAttribute(rect, "width", ctx.bs);
				setAttribute(rect, "height", ctx.bs);
				setAttribute(rect, "fill", rect_fill_value = idxColor$1(ctx.x));
			},
			m: function m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insertNode(rect, target, anchor);
			},
			p: function p(changed, ctx) {
				if (ctx.x == 4) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$3(component, ctx);
						if_block.c();
						if_block.m(rect.parentNode, rect);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.xs && rect_x_value !== (rect_x_value = 20 * ctx.x + 6)) {
					setAttribute(rect, "x", rect_x_value);
				}

				if (changed.bs) {
					setAttribute(rect, "width", ctx.bs);
					setAttribute(rect, "height", ctx.bs);
				}

				if (changed.xs && rect_fill_value !== (rect_fill_value = idxColor$1(ctx.x))) {
					setAttribute(rect, "fill", rect_fill_value);
				}
			},
			d: function d(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(rect);
				}
			}
		};
	}

	// (5:4) {#if x == 4}
	function create_if_block$3(component, ctx) {
		var text$$1, tspan, text_1, text_x_value, line$$1, line_x__value, line_x__value_1;

		return {
			c: function c() {
				text$$1 = createSvgElement("text");
				tspan = createSvgElement("tspan");
				text_1 = createText("f(x) = ?");
				line$$1 = createSvgElement("line");
				setAttribute(tspan, "font-weight", "bold");
				setAttribute(text$$1, "x", text_x_value = 20 * ctx.x + 6);
				setAttribute(text$$1, "y", "90");
				setAttribute(text$$1, "class", "annotation");
				setAttribute(line$$1, "class", "dashed svelte-1gfbgft");
				setAttribute(line$$1, "x1", line_x__value = 20 * ctx.x + ctx.bs / 2 + 6);
				setAttribute(line$$1, "y1", "158");
				setAttribute(line$$1, "x2", line_x__value_1 = 20 * ctx.x + ctx.bs / 2 + 6);
				setAttribute(line$$1, "y2", "95");
				setAttribute(line$$1, "stroke", "grey");
			},
			m: function m(target, anchor) {
				insertNode(text$$1, target, anchor);
				appendNode(tspan, text$$1);
				appendNode(text_1, tspan);
				insertNode(line$$1, target, anchor);
			},
			p: function p(changed, ctx) {
				if (changed.xs && text_x_value !== (text_x_value = 20 * ctx.x + 6)) {
					setAttribute(text$$1, "x", text_x_value);
				}

				if ((changed.xs || changed.bs) && line_x__value !== (line_x__value = 20 * ctx.x + ctx.bs / 2 + 6)) {
					setAttribute(line$$1, "x1", line_x__value);
				}

				if ((changed.xs || changed.bs) && line_x__value_1 !== (line_x__value_1 = 20 * ctx.x + ctx.bs / 2 + 6)) {
					setAttribute(line$$1, "x2", line_x__value_1);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(text$$1);
					detachNode(line$$1);
				}
			}
		};
	}

	// (37:6) {#each xst as x}
	function create_each_block_1$1(component, ctx) {
		var if_block_anchor;

		function select_block_type(ctx) {
			if (ctx.x < 2) return create_if_block_1$1;
			return create_if_block_2;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function c() {
				if_block.c();
				if_block_anchor = createComment();
			},
			m: function m(target, anchor) {
				if_block.m(target, anchor);
				insertNode(if_block_anchor, target, anchor);
			},
			p: function p(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			d: function d(detach) {
				if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (38:6) {#if x < 2}
	function create_if_block_1$1(component, ctx) {
		var rect, rect_x_value, rect_1, rect_1_y_value;

		return {
			c: function c() {
				rect = createSvgElement("rect");
				rect_1 = createSvgElement("rect");
				setAttribute(rect, "x", rect_x_value = 12 * ctx.x + 12);
				setAttribute(rect, "y", "0");
				setAttribute(rect, "width", ctx.bs);
				setAttribute(rect, "height", ctx.bs);
				setAttribute(rect, "fill", "rgb(245, 181, 62)");
				setAttribute(rect_1, "x", "0");
				setAttribute(rect_1, "y", rect_1_y_value = 12 * ctx.x + 12);
				setAttribute(rect_1, "width", ctx.bs);
				setAttribute(rect_1, "height", ctx.bs);
				setAttribute(rect_1, "fill", "rgb(245, 181, 62)");
			},
			m: function m(target, anchor) {
				insertNode(rect, target, anchor);
				insertNode(rect_1, target, anchor);
			},
			p: function p(changed, ctx) {
				if (changed.xst && rect_x_value !== (rect_x_value = 12 * ctx.x + 12)) {
					setAttribute(rect, "x", rect_x_value);
				}

				if (changed.bs) {
					setAttribute(rect, "width", ctx.bs);
					setAttribute(rect, "height", ctx.bs);
				}

				if (changed.xst && rect_1_y_value !== (rect_1_y_value = 12 * ctx.x + 12)) {
					setAttribute(rect_1, "y", rect_1_y_value);
				}

				if (changed.bs) {
					setAttribute(rect_1, "width", ctx.bs);
					setAttribute(rect_1, "height", ctx.bs);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(rect);
					detachNode(rect_1);
				}
			}
		};
	}

	// (41:6) {:else}
	function create_if_block_2(component, ctx) {
		var rect, rect_x_value, rect_fill_value, rect_1, rect_1_y_value, rect_1_fill_value;

		return {
			c: function c() {
				rect = createSvgElement("rect");
				rect_1 = createSvgElement("rect");
				setAttribute(rect, "x", rect_x_value = 12 * ctx.x + 12);
				setAttribute(rect, "y", "0");
				setAttribute(rect, "width", ctx.bs);
				setAttribute(rect, "height", ctx.bs);
				setAttribute(rect, "fill", rect_fill_value = idxColor$1(ctx.x - 2));
				setAttribute(rect_1, "x", "0");
				setAttribute(rect_1, "y", rect_1_y_value = 12 * ctx.x + 12);
				setAttribute(rect_1, "width", ctx.bs);
				setAttribute(rect_1, "height", ctx.bs);
				setAttribute(rect_1, "fill", rect_1_fill_value = idxColor$1(ctx.x - 2));
			},
			m: function m(target, anchor) {
				insertNode(rect, target, anchor);
				insertNode(rect_1, target, anchor);
			},
			p: function p(changed, ctx) {
				if (changed.xst && rect_x_value !== (rect_x_value = 12 * ctx.x + 12)) {
					setAttribute(rect, "x", rect_x_value);
				}

				if (changed.bs) {
					setAttribute(rect, "width", ctx.bs);
					setAttribute(rect, "height", ctx.bs);
				}

				if (changed.xst && rect_fill_value !== (rect_fill_value = idxColor$1(ctx.x - 2))) {
					setAttribute(rect, "fill", rect_fill_value);
				}

				if (changed.xst && rect_1_y_value !== (rect_1_y_value = 12 * ctx.x + 12)) {
					setAttribute(rect_1, "y", rect_1_y_value);
				}

				if (changed.bs) {
					setAttribute(rect_1, "width", ctx.bs);
					setAttribute(rect_1, "height", ctx.bs);
				}

				if (changed.xst && rect_1_fill_value !== (rect_1_fill_value = idxColor$1(ctx.x - 2))) {
					setAttribute(rect_1, "fill", rect_1_fill_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(rect);
					detachNode(rect_1);
				}
			}
		};
	}

	// (63:6) {#each xs as x}
	function create_each_block_2$1(component, ctx) {
		var rect, rect_x_value, rect_fill_value, rect_1, rect_1_y_value, rect_1_fill_value;

		return {
			c: function c() {
				rect = createSvgElement("rect");
				rect_1 = createSvgElement("rect");
				setAttribute(rect, "x", rect_x_value = 12 * ctx.x + 12);
				setAttribute(rect, "y", "0");
				setAttribute(rect, "width", ctx.bs);
				setAttribute(rect, "height", ctx.bs);
				setAttribute(rect, "fill", rect_fill_value = idxColor$1(ctx.x));
				setAttribute(rect_1, "x", "0");
				setAttribute(rect_1, "y", rect_1_y_value = 12 * ctx.x + 12);
				setAttribute(rect_1, "width", ctx.bs);
				setAttribute(rect_1, "height", ctx.bs);
				setAttribute(rect_1, "fill", rect_1_fill_value = idxColor$1(ctx.x));
			},
			m: function m(target, anchor) {
				insertNode(rect, target, anchor);
				insertNode(rect_1, target, anchor);
			},
			p: function p(changed, ctx) {
				if (changed.xs && rect_x_value !== (rect_x_value = 12 * ctx.x + 12)) {
					setAttribute(rect, "x", rect_x_value);
				}

				if (changed.bs) {
					setAttribute(rect, "width", ctx.bs);
					setAttribute(rect, "height", ctx.bs);
				}

				if (changed.xs && rect_fill_value !== (rect_fill_value = idxColor$1(ctx.x))) {
					setAttribute(rect, "fill", rect_fill_value);
				}

				if (changed.xs && rect_1_y_value !== (rect_1_y_value = 12 * ctx.x + 12)) {
					setAttribute(rect_1, "y", rect_1_y_value);
				}

				if (changed.bs) {
					setAttribute(rect_1, "width", ctx.bs);
					setAttribute(rect_1, "height", ctx.bs);
				}

				if (changed.xs && rect_1_fill_value !== (rect_1_fill_value = idxColor$1(ctx.x))) {
					setAttribute(rect_1, "fill", rect_1_fill_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(rect);
					detachNode(rect_1);
				}
			}
		};
	}

	function get_each_context$6(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.x = list[i];
		child_ctx.each_value = list;
		child_ctx.x_index = i;
		return child_ctx;
	}

	function get_each_1_context$1(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.x = list[i];
		child_ctx.each_value_1 = list;
		child_ctx.x_index_1 = i;
		return child_ctx;
	}

	function get_each_2_context$1(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.x = list[i];
		child_ctx.each_value_2 = list;
		child_ctx.x_index_2 = i;
		return child_ctx;
	}

	function PosteriorFigure(options) {
		init(this, options);
		this._state = assign(data$a(), options.data);
		this._intro = true;

		if (!document.getElementById("svelte-1gfbgft-style")) add_css$8();

		this._fragment = create_main_fragment$a(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(PosteriorFigure.prototype, proto);

	/* src/scripts/components/PriorSampling.html generated by Svelte v2.9.1 */

	var rbf$2 = {
		kernel: rbf,
		name: 'RBF Kernel',
		equation: '\\exp \\left( - \\frac{||t-t\'||^2}{2 bl^2} \\right)',
		params: [{
			name: 'Variance σ',
			value: 0.8,
			min: 0,
			max: 1
		}, {
			name: 'Length l',
			description: 'the reach of influence on neighbors.',
			value: 0.8,
			min: 0.01,
			max: 2
		}]
	};

	var periodic$2 = {
		kernel: periodic,
		name: 'Periodic',
		equation: '\\exp \\left( - \\frac{2 \\sin^2(\\pi |t-t\'| / p)}{l^2} \\right)',
		params: [{
			name: 'Variance σ',
			value: 0.9,
			min: 0,
			max: 1
		}, {
			name: 'Length l',
			description: 'the reach of influence on neighbors.',
			value: 0.51,
			min: 0.01,
			max: 2
		}, {
			name: 'Periodicity p',
			description: 'the distance between repetitions.',
			value: 0.31,
			min: 0,
			max: Math.PI
		}]
	};

	var linear$6 = {
		kernel: linear$4,
		name: 'Linear',
		equation: '\\sigma_b^2 + (t - c)(t\' - c)',
		params: [{
			name: 'Variance σ',
			value: 0.15,
			min: 0,
			max: 1
		}, {
			name: 'Variance σ_b',
			description: 'the \'certainty\' around C.',
			value: 0.1,
			min: 0,
			max: 1
		}, {
			name: 'Offset c',
			description: 'the intersection point of all functions.',
			value: 2,
			min: -2,
			max: 2
		}]
	};

	function line$1(_ref) {
		var context = _ref.context;
		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1]);
		});
	}

	function zero$1(_ref2) {
		var context = _ref2.context;

		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1]);
		});
	}

	function sdPlus$1(_ref3) {
		var context = _ref3.context;

		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1] + 2 * d[2]);
		});
	}

	function sdMinus$1(_ref4) {
		var context = _ref4.context;

		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1] - 2 * d[2]);
		});
	}

	function sdArea$1(_ref5) {
		var context = _ref5.context;

		return area$3().x(function (d) {
			return context.u(d[0]);
		}).y0(function (d) {
			return context.v(d[1] - 2 * d[2]);
		}).y1(function (d) {
			return context.v(d[1] + 2 * d[2]);
		});
	}

	function shadowPaths(_ref6) {
		var shadows = _ref6.shadows,
		    line$$1 = _ref6.line;

		return shadows.map(line$$1);
	}

	function data$b() {
		return {
			context: new Context(500, 350, [-5, 5], [-10, 10]),
			curve: [],
			shadows: [],
			active: false,
			countDimensions: 100,
			kernel: rbf$2.kernel,
			name: 'RBF Kernel',
			params: rbf$2.params,
			meanCurve: []
		};
	}
	function toV$2(context, y) {
		return context.v(y);
	}
	var methods$3 = {
		toggleOnOff: function toggleOnOff() {
			var _this = this;

			var _get = this.get(),
			    active$$1 = _get.active;

			if (!active$$1) {
				this.resample();
				this.interval = setInterval(function () {
					_this.resample();
				}, 1000);
			} else {
				clearInterval(this.interval);
			}
			this.set({ active: !active$$1 });
		},
		switchKernel: function switchKernel(k, p) {
			this.set({ kernel: k, params: p, curve: [], shadows: [] });
			this.refs.covMat.set({ kernel: k, params: p });
			this.resample();
		},
		switchRBF: function switchRBF() {
			this.switchKernel(rbf$2.kernel, rbf$2.params);
		},
		switchPeriodic: function switchPeriodic() {
			this.switchKernel(periodic$2.kernel, periodic$2.params);
		},
		switchLinear: function switchLinear() {
			this.switchKernel(linear$6.kernel, linear$6.params);
		},
		resample: function resample() {
			var _get2 = this.get(),
			    context = _get2.context,
			    curve = _get2.curve,
			    shadows = _get2.shadows,
			    countDimensions = _get2.countDimensions,
			    params = _get2.params,
			    kernel = _get2.kernel;

			var maxShadows = 30;
			if (curve.length > 0) {
				if (shadows.length > maxShadows) {
					shadows.shift();
				}
				shadows.push(curve);
			}
			// creates linear spaced values
			var N = countDimensions;

			var _context$xDomain = context.xDomain(),
			    _context$xDomain2 = slicedToArray(_context$xDomain, 2),
			    xmin = _context$xDomain2[0],
			    xmax = _context$xDomain2[1];

			var step$$1 = (xmax - xmin) / (N - 1);
			var xs = sequence(xmin, xmax + step$$1, step$$1);

			var paramValues = params.map(function (p) {
				return p.value;
			});
			var fn = kernel.apply(null, paramValues);

			var process = gaussianProcess(fn, xs);
			var ys = process.sample();
			var sd = process.getSd();
			var ysMean = process.getMean();

			var pts = zip(xs, ys, sd);
			var ptsMean = zip(xs, ysMean, sd);
			this.set({ curve: pts, shadows: shadows, meanCurve: ptsMean });
		}
	};

	function oncreate$6() {
		this.resample();

		var _get3 = this.get(),
		    curve = _get3.curve,
		    line$$1 = _get3.line,
		    meanCurve = _get3.meanCurve,
		    sdArea = _get3.sdArea,
		    zero = _get3.zero,
		    sdPlus = _get3.sdPlus,
		    sdMinus = _get3.sdMinus;

		var svg$$1 = select(this.refs.svgArea);

		svg$$1.append('path').data([meanCurve]).attr('class', 'sdArea').attr('stroke', 'none').attr('fill', 'rgba(0,0,0,0.05)').style('opacity', 0.5).attr('d', sdArea);

		svg$$1.append('path').data([meanCurve]).attr('class', 'zero').attr('fill', 'none').attr('stroke', 'rgba(0,0,0,0.2)').attr('stroke-width', '2px').attr('d', zero);

		svg$$1.append('path').data([meanCurve]).attr('class', 'sdPlus').attr('fill', 'none').attr('stroke', 'rgba(0,0,0,0.2)').attr('stroke-dasharray', '4').attr('stroke-width', '2px').attr('d', sdPlus);

		svg$$1.append('path').data([meanCurve]).attr('class', 'sdMinus').attr('fill', 'none').attr('stroke', 'rgba(0,0,0,0.2)').attr('stroke-dasharray', '4').attr('stroke-width', '2px').attr('d', sdMinus);

		svg$$1.append('path').data([curve]).attr('class', 'curve').attr('fill', 'none').attr('stroke', '#c51b8a').attr('stroke-width', '2px').attr('d', line$$1);
	}
	function ondestroy() {
		clearInterval(this.interval);
	}
	function onupdate$2(_ref7) {
		var _changed = _ref7._changed,
		    current = _ref7.current,
		    _previous = _ref7._previous;

		var svg$$1 = select(this.refs.svgArea).transition();
		svg$$1.select('.curve').duration(750).attr('d', current.line(current.curve));
		svg$$1.select('.zero').transition().duration(750).attr('d', current.zero(current.meanCurve));
		svg$$1.select('.sdArea').transition().duration(750).attr('d', current.sdArea(current.meanCurve));
		svg$$1.select('.sdPlus').transition().duration(750).attr('d', current.sdPlus(current.meanCurve));
		svg$$1.select('.sdMinus').transition().duration(750).attr('d', current.sdMinus(current.meanCurve));
	}
	function add_css$9() {
		var style = createElement("style");
		style.id = 'svelte-1w2ldvj-style';
		style.textContent = ".kernel-grid.svelte-1w2ldvj{display:inline-grid;grid-template-columns:auto auto auto auto}.grid-item.svelte-1w2ldvj{margin:0.5em}.shadowLine.svelte-1w2ldvj{fill:none;stroke:rgba(0,0,0,0.1);stroke-width:2px}";
		appendNode(style, document.head);
	}

	function create_main_fragment$b(component, ctx) {
		var div,
		    input,
		    text$$1,
		    label,
		    text_2,
		    input_1,
		    text_3,
		    label_1,
		    text_5,
		    input_2,
		    text_6,
		    label_2,
		    text_9,
		    div_1,
		    div_2,
		    svg$$1,
		    g,
		    text_10,
		    text_11,
		    text_10_y_value,
		    svg_width_value,
		    svg_height_value,
		    text_13,
		    div_3,
		    kernelcovmat_updating = {};

		function change_handler(event$$1) {
			component.switchRBF();
		}

		function change_handler_1(event$$1) {
			component.switchPeriodic();
		}

		function change_handler_2(event$$1) {
			component.switchLinear();
		}

		var each_value = ctx.shadowPaths;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$7(component, get_each_context$7(ctx, each_value, i));
		}

		function select_block_type(ctx) {
			if (ctx.active) return create_if_block$4;
			return create_if_block_1$2;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		function click_handler(event$$1) {
			component.toggleOnOff();
		}

		var kernelcovmat_initial_data = {
			n: ctx.countDimensions,
			gridSize: 1,
			width: 100,
			height: 100,
			offset: 0
		};
		if (ctx.kernel !== void 0) {
			kernelcovmat_initial_data.kernel = ctx.kernel;
			kernelcovmat_updating.kernel = true;
		}
		if (ctx.params !== void 0) {
			kernelcovmat_initial_data.params = ctx.params;
			kernelcovmat_updating.params = true;
		}
		var kernelcovmat = new KernelCovMat({
			root: component.root,
			store: component.store,
			data: kernelcovmat_initial_data,
			_bind: function _bind(changed, childState) {
				var newState = {};
				if (!kernelcovmat_updating.kernel && changed.kernel) {
					newState.kernel = childState.kernel;
				}

				if (!kernelcovmat_updating.params && changed.params) {
					newState.params = childState.params;
				}
				component._set(newState);
				kernelcovmat_updating = {};
			}
		});

		component.root._beforecreate.push(function () {
			kernelcovmat._bind({ kernel: 1, params: 1 }, kernelcovmat.get());
		});

		component.refs.covMat = kernelcovmat;

		return {
			c: function c() {
				div = createElement("div");
				input = createElement("input");
				text$$1 = createText("\n  ");
				label = createElement("label");
				label.textContent = "RBF";
				text_2 = createText(" \n  ");
				input_1 = createElement("input");
				text_3 = createText("\n  ");
				label_1 = createElement("label");
				label_1.textContent = "Periodic";
				text_5 = createText(" \n  ");
				input_2 = createElement("input");
				text_6 = createText("\n  ");
				label_2 = createElement("label");
				label_2.textContent = "Linear";
				text_9 = createText("\n");
				div_1 = createElement("div");
				div_2 = createElement("div");
				svg$$1 = createSvgElement("svg");
				g = createSvgElement("g");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_10 = createSvgElement("text");
				text_11 = createText("y = 0");
				if_block.c();
				text_13 = createText("\n  ");
				div_3 = createElement("div");
				kernelcovmat._fragment.c();
				addListener(input, "change", change_handler);
				setAttribute(input, "type", "radio");
				input.checked = "checked";
				input.id = "rbf";
				input.name = "kernel";
				input.value = "RBF";
				label.htmlFor = "rbf";
				addListener(input_1, "change", change_handler_1);
				setAttribute(input_1, "type", "radio");
				input_1.id = "periodic";
				input_1.name = "kernel";
				input_1.value = "Periodic";
				label_1.htmlFor = "periodic";
				addListener(input_2, "change", change_handler_2);
				setAttribute(input_2, "type", "radio");
				input_2.id = "linear";
				input_2.name = "kernel";
				input_2.value = "Linear";
				label_2.htmlFor = "linear";
				setAttribute(text_10, "x", "5");
				setAttribute(text_10, "y", text_10_y_value = toV$2(ctx.context, 0) - 5);
				setAttribute(text_10, "class", "annotation");
				setAttribute(svg$$1, "class", "plot");
				setAttribute(svg$$1, "width", svg_width_value = ctx.context.width);
				setAttribute(svg$$1, "height", svg_height_value = ctx.context.height);
				addListener(div_2, "click", click_handler);
				div_2.className = "grid-item svelte-1w2ldvj";
				div_3.className = "grid-item svelte-1w2ldvj";
				div_1.className = "kernel-grid svelte-1w2ldvj";
			},
			m: function m(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(input, div);
				appendNode(text$$1, div);
				appendNode(label, div);
				appendNode(text_2, div);
				appendNode(input_1, div);
				appendNode(text_3, div);
				appendNode(label_1, div);
				appendNode(text_5, div);
				appendNode(input_2, div);
				appendNode(text_6, div);
				appendNode(label_2, div);
				insertNode(text_9, target, anchor);
				insertNode(div_1, target, anchor);
				appendNode(div_2, div_1);
				appendNode(svg$$1, div_2);
				appendNode(g, svg$$1);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(g, null);
				}

				appendNode(text_10, svg$$1);
				appendNode(text_11, text_10);
				if_block.m(svg$$1, null);
				component.refs.svgArea = svg$$1;
				appendNode(text_13, div_1);
				appendNode(div_3, div_1);
				kernelcovmat._mount(div_3, null);
				component.refs.gridMultipleKernel = div_1;
			},
			p: function p(changed, _ctx) {
				ctx = _ctx;
				if (changed.shadowPaths) {
					each_value = ctx.shadowPaths;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context$7(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$7(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(g, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (changed.context && text_10_y_value !== (text_10_y_value = toV$2(ctx.context, 0) - 5)) {
					setAttribute(text_10, "y", text_10_y_value);
				}

				if (current_block_type !== (current_block_type = select_block_type(ctx))) {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(svg$$1, null);
				}

				if (changed.context && svg_width_value !== (svg_width_value = ctx.context.width)) {
					setAttribute(svg$$1, "width", svg_width_value);
				}

				if (changed.context && svg_height_value !== (svg_height_value = ctx.context.height)) {
					setAttribute(svg$$1, "height", svg_height_value);
				}

				var kernelcovmat_changes = {};
				if (changed.countDimensions) kernelcovmat_changes.n = ctx.countDimensions;
				if (!kernelcovmat_updating.kernel && changed.kernel) {
					kernelcovmat_changes.kernel = ctx.kernel;
					kernelcovmat_updating.kernel = ctx.kernel !== void 0;
				}
				if (!kernelcovmat_updating.params && changed.params) {
					kernelcovmat_changes.params = ctx.params;
					kernelcovmat_updating.params = ctx.params !== void 0;
				}
				kernelcovmat._set(kernelcovmat_changes);
				kernelcovmat_updating = {};
			},
			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(input, "change", change_handler);
				removeListener(input_1, "change", change_handler_1);
				removeListener(input_2, "change", change_handler_2);
				if (detach) {
					detachNode(text_9);
					detachNode(div_1);
				}

				destroyEach(each_blocks, detach);

				if_block.d();
				if (component.refs.svgArea === svg$$1) component.refs.svgArea = null;
				removeListener(div_2, "click", click_handler);
				kernelcovmat.destroy();
				if (component.refs.covMat === kernelcovmat) component.refs.covMat = null;
				if (component.refs.gridMultipleKernel === div_1) component.refs.gridMultipleKernel = null;
			}
		};
	}

	// (13:4) {#each shadowPaths as sp}
	function create_each_block$7(component, ctx) {
		var path$$1, path_d_value;

		return {
			c: function c() {
				path$$1 = createSvgElement("path");
				setAttribute(path$$1, "d", path_d_value = ctx.sp);
				setAttribute(path$$1, "class", "shadowLine svelte-1w2ldvj");
			},
			m: function m(target, anchor) {
				insertNode(path$$1, target, anchor);
			},
			p: function p(changed, ctx) {
				if (changed.shadowPaths && path_d_value !== (path_d_value = ctx.sp)) {
					setAttribute(path$$1, "d", path_d_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(path$$1);
				}
			}
		};
	}

	// (21:4) {#if active}
	function create_if_block$4(component, ctx) {
		var text$$1, tspan, text_1;

		return {
			c: function c() {
				text$$1 = createSvgElement("text");
				tspan = createSvgElement("tspan");
				text_1 = createText("(click to pause)");
				setAttribute(tspan, "fill", "rgb(245, 181, 62)");
				setAttribute(tspan, "font-style", "italic");
				setAttribute(text$$1, "x", "5");
				setAttribute(text$$1, "y", "15");
				setAttribute(text$$1, "class", "annotation");
			},
			m: function m(target, anchor) {
				insertNode(text$$1, target, anchor);
				appendNode(tspan, text$$1);
				appendNode(text_1, tspan);
			},
			d: function d(detach) {
				if (detach) {
					detachNode(text$$1);
				}
			}
		};
	}

	// (23:4) {:else}
	function create_if_block_1$2(component, ctx) {
		var text$$1, tspan, text_1;

		return {
			c: function c() {
				text$$1 = createSvgElement("text");
				tspan = createSvgElement("tspan");
				text_1 = createText("(click to start)");
				setAttribute(tspan, "fill", "rgb(245, 181, 62)");
				setAttribute(tspan, "font-style", "italic");
				setAttribute(text$$1, "x", "5");
				setAttribute(text$$1, "y", "15");
				setAttribute(text$$1, "class", "annotation");
			},
			m: function m(target, anchor) {
				insertNode(text$$1, target, anchor);
				appendNode(tspan, text$$1);
				appendNode(text_1, tspan);
			},
			d: function d(detach) {
				if (detach) {
					detachNode(text$$1);
				}
			}
		};
	}

	function get_each_context$7(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.sp = list[i];
		child_ctx.each_value = list;
		child_ctx.sp_index = i;
		return child_ctx;
	}

	function PriorSampling(options) {
		var _this2 = this;

		init(this, options);
		this.refs = {};
		this._state = assign(data$b(), options.data);
		this._recompute({ context: 1, shadows: 1, line: 1 }, this._state);
		this._intro = true;
		this._handlers.update = [onupdate$2];

		this._handlers.destroy = [ondestroy];

		if (!document.getElementById("svelte-1w2ldvj-style")) add_css$9();

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$b(this, this._state);

		this.root._oncreate.push(function () {
			oncreate$6.call(_this2);
			_this2.fire("update", { changed: assignTrue({}, _this2._state), current: _this2._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(PriorSampling.prototype, proto);
	assign(PriorSampling.prototype, methods$3);

	PriorSampling.prototype._recompute = function _recompute(changed, state) {
		if (changed.context) {
			if (this._differs(state.line, state.line = line$1(state))) changed.line = true;
			if (this._differs(state.zero, state.zero = zero$1(state))) changed.zero = true;
			if (this._differs(state.sdPlus, state.sdPlus = sdPlus$1(state))) changed.sdPlus = true;
			if (this._differs(state.sdMinus, state.sdMinus = sdMinus$1(state))) changed.sdMinus = true;
			if (this._differs(state.sdArea, state.sdArea = sdArea$1(state))) changed.sdArea = true;
		}

		if (changed.shadows || changed.line) {
			if (this._differs(state.shadowPaths, state.shadowPaths = shadowPaths(state))) changed.shadowPaths = true;
		}
	};

	/* src/scripts/components/Posterior.html generated by Svelte v2.9.1 */

	function connectedline$1(_ref) {
	  var context = _ref.context;

	  return line().curve(stepBefore).x(function (d) {
	    return d[0];
	  }).y(function (d) {
	    return d[1];
	  });
	}

	function line$2(_ref2) {
	  var context = _ref2.context;

	  return line().x(function (d) {
	    return context.u(d[0]);
	  }).y(function (d) {
	    return context.v(d[1]);
	  });
	}

	function zero$2(_ref3) {
	  var context = _ref3.context;

	  return line().x(function (d) {
	    return context.u(d[0]);
	  }).y(function (d) {
	    return context.v(d[1]);
	  });
	}

	function sdPlus$2(_ref4) {
	  var context = _ref4.context;

	  return line().x(function (d) {
	    return context.u(d[0]);
	  }).y(function (d) {
	    return context.v(d[1] + 2 * d[2]);
	  });
	}

	function sdMinus$2(_ref5) {
	  var context = _ref5.context;

	  return line().x(function (d) {
	    return context.u(d[0]);
	  }).y(function (d) {
	    return context.v(d[1] - 2 * d[2]);
	  });
	}

	function sdArea$2(_ref6) {
	  var context = _ref6.context;

	  return area$3().x(function (d) {
	    return context.u(d[0]);
	  }).y0(function (d) {
	    return context.v(d[1] - 2 * d[2]);
	  }).y1(function (d) {
	    return context.v(d[1] + 2 * d[2]);
	  });
	}

	function data$c() {
	  return {
	    trainingPoints: [{ x: -1.122, y: -1, active: false }, { x: 1.122, y: 1, active: false }],
	    context: new Context(500, 300, [-5, 5], [-10, 10]),
	    curves: [],
	    meanCurve: [],
	    circleSize: 0,
	    countDimensions: 50,
	    countSamples: 1

	  };
	}
	function toV$3(context, y) {
	  return context.v(y);
	}
	function toU$2(context, x) {
	  return context.u(x);
	}
	var methods$4 = {
	  colorBar: function colorBar() {
	    var svg$$1 = select(this.refs.covScale);
	    var currentComponent = this.refs.covMat;

	    var _currentComponent$get = currentComponent.get(),
	        colorsRow = _currentComponent$get.colorsRow;

	    var _get = this.get(),
	        countDimensions = _get.countDimensions;

	    var rects = svg$$1.selectAll('.rects');
	    var colorArray = [];
	    if (colorsRow.length > 1) {
	      rects.style('stroke-width', '1px').style('stroke', 'black').each(function (d, i) {
	        var cov = colorsRow[i];
	        var newColor = currentComponent.returnColor(cov.cov);
	        colorArray.push(newColor);
	      });
	    } else {
	      rects.style('stroke-width', '0px').style('stroke', '#9A8B7A');
	      colorArray = Array(countDimensions).fill('rgba(0,0,0,0.2)');
	    }
	    return colorArray;
	  },
	  colorGradient: function colorGradient(colorArray, colorsRow) {
	    var _get2 = this.get(),
	        countDimensions = _get2.countDimensions;

	    var svg$$1 = select(this.refs.covScale);
	    var gradient = svg$$1.selectAll('.gradient > stop');
	    var gradient2 = svg$$1.selectAll('.gradientBackground > stop');

	    if (colorsRow.length > 0) {
	      gradient.attr('offset', function (d, i) {
	        return 100 / countDimensions * i + '%';
	      }).attr('stop-color', function (d, i) {
	        return colorArray[i];
	      }).attr('stop-opacity', 1);

	      gradient2.attr('offset', function (d, i) {
	        return 100 / countDimensions * i + '%';
	      }).attr('stop-opacity', function (d, i) {
	        return colorsRow[i].cov * 2;
	      });
	    } else {
	      gradient.attr('stop-opacity', 0);
	      gradient2.attr('stop-opacity', 1);
	    }
	  },
	  resampleFake: function resampleFake() {
	    var _get3 = this.get(),
	        curves = _get3.curves;

	    this.set({ curves: curves });
	  },
	  resample: function resample(idx) {
	    var _get4 = this.get(),
	        context = _get4.context,
	        trainingPoints = _get4.trainingPoints,
	        countDimensions = _get4.countDimensions;

	    var _get5 = this.get(),
	        curves = _get5.curves;

	    // creates linear spaced values


	    var N = countDimensions;

	    var _context$xDomain = context.xDomain(),
	        _context$xDomain2 = slicedToArray(_context$xDomain, 2),
	        xmin = _context$xDomain2[0],
	        xmax = _context$xDomain2[1];

	    var step$$1 = (xmax - xmin) / (N - 1);
	    var xs = sequence(xmin, xmax + step$$1, step$$1);

	    // prepare training data
	    var activePoints = trainingPoints.filter(function (p) {
	      return p.active;
	    });
	    var xsTrain = activePoints.map(function (p) {
	      return p.x;
	    });
	    var ysTrain = activePoints.map(function (p) {
	      return p.y;
	    });

	    var _refs$covMat$get = this.refs.covMat.get(),
	        params = _refs$covMat$get.params,
	        kernel = _refs$covMat$get.kernel,
	        covMatrix$$1 = _refs$covMat$get.covMatrix;

	    var paramValues = params.map(function (p) {
	      return p.value;
	    });
	    var fn = kernel.apply(null, paramValues);

	    var process = gaussianProcess(fn, xs, xsTrain, ysTrain);
	    var ys = process.sample();
	    var sd = process.getSd();
	    var ysMean = process.getMean();

	    this.refs.covMat.externalCov(process.cov);
	    this.refs.covMat.set({ covMatrix: covMatrix$$1 });

	    var pts = zip(xs, ys, sd);
	    var ptsMean = zip(xs, ysMean, sd);

	    curves[idx] = pts;
	    this.set({ curves: curves, meanCurve: ptsMean });
	  },
	  toggle: function toggle(idx) {
	    var _get6 = this.get(),
	        trainingPoints = _get6.trainingPoints;

	    trainingPoints[idx].active = !trainingPoints[idx].active;
	    this.set({ trainingPoints: trainingPoints });
	    this.refs.covMat.set({ shouldResample: true });
	  },
	  createVis: function createVis() {
	    var _get7 = this.get(),
	        meanCurve = _get7.meanCurve,
	        sdPlus = _get7.sdPlus,
	        sdMinus = _get7.sdMinus,
	        sdArea = _get7.sdArea,
	        zero = _get7.zero,
	        curves = _get7.curves,
	        line$$1 = _get7.line,
	        context = _get7.context,
	        connectedline = _get7.connectedline,
	        countDimensions = _get7.countDimensions,
	        circleSize = _get7.circleSize;

	    var svg$$1 = select(this.refs.graph);
	    var matScale = select(this.refs.covScale);

	    svg$$1.append('path').data([meanCurve]).attr('class', 'sdArea').attr('stroke', 'none').attr('fill', 'rgba(255,224,255,0.6)').style('fill', 'url(#masterBackground)').style('opacity', 0.5).attr('d', sdArea);

	    svg$$1.append('path').data([meanCurve]).attr('class', 'zero').attr('fill', 'none').attr('stroke', '#c51b8a').attr('stroke-width', '2px').attr('d', zero);

	    svg$$1.append('path').data([meanCurve]).attr('class', 'sdPlus').attr('fill', 'none').attr('stroke', '#fa9fb5').attr('stroke-width', '1px').attr('d', sdPlus);

	    svg$$1.append('path').data([meanCurve]).attr('class', 'sdMinus').attr('fill', 'none').attr('stroke', '#fa9fb5').attr('stroke-width', '1px').attr('d', sdMinus);

	    ////Circles
	    // Data Join
	    var circles = svg$$1.selectAll('g.circles').data(curves);
	    //Exit
	    circles.exit().remove();
	    //Enter
	    circles.enter().append('g').classed('circles', true).selectAll('.samples').data(function (d) {
	      return d;
	    }).enter() // d is matrix[i]
	    .append('circle').classed('samples', true).attr('cx', function (d) {
	      return context.u(d[0]);
	    }).attr('cy', function (d) {
	      return context.v(d[1]);
	    }).attr('r', circleSize).style('fill', 'none').style('stroke', 'black').style('stroke-with', 1);

	    ////Lines
	    // Data Join

	    var lineConnectors = matScale.selectAll('g.lineConnectors').data([meanCurve]);

	    //Exit
	    lineConnectors.exit().remove();

	    //Enter
	    matScale.selectAll('.lineConnector').data(meanCurve).enter() // d is matrix[i]
	    .append('path').classed('lineConnector', true).attr('stroke', 'black').attr('fill', 'transparent').style('stroke-width', '1px').style('stroke-dasharray', 4).attr('d', function (d) {
	      var xConv = context.u(d[0]);
	      var yConv = context.v(d[1] + 2 * d[2]);
	      return connectedline([[xConv + 1, yConv], [xConv + 1, 12], [xConv + context.width, 12], [xConv + context.width, 10]]);
	    });

	    ////Gradient
	    var gradient = matScale.append('linearGradient').classed('gradient', true).attr('x1', '0%').attr('y1', '0%').attr('x2', '100%').attr('y2', '0%').attr('id', 'master');

	    ////Gradient
	    var gradient2 = matScale.append('linearGradient').classed('gradientBackground', true).attr('x1', '0%').attr('y1', '0%').attr('x2', '100%').attr('y2', '0%').attr('id', 'masterBackground');

	    var stopId = 0;
	    for (var i = 0; i < countDimensions; i++) {
	      gradient.append('stop').attr('offset', stopId + '%').attr('stop-color', 'rgba(0,0,0,0.2)').attr('stop-opacity', 1);
	      gradient2.append('stop').attr('offset', stopId + '%').attr('stop-color', 'rgb(255,224,255)').attr('stop-opacity', 1);
	      stopId = stopId + 100 / countDimensions * i;
	    }

	    matScale.append('rect').attr('width', context.width).attr('height', context.width / countDimensions).attr('x', 1).attr('y', context.y(0) - 9).style('fill', 'url(#master)');

	    ////Rects
	    // Data Join

	    var rects = matScale.selectAll('g.colorRect').data([curves[0]]);

	    //Exit
	    rects.exit().remove();

	    //Enter
	    rects.enter().append('g').classed('colorRect', true).selectAll('.rects').data(function (d) {
	      return d;
	    }).enter() // d is matrix[i]
	    .append('rect').classed('rects', true).attr('x', function (d) {
	      return context.u(d[0]);
	    }).attr('y', context.y(0)).attr('width', context.width / countDimensions).attr('height', context.width / countDimensions).style('fill', 'transparent').style('stroke', 'black').style('stroke-width', '1px').style('stroke-opacity', 0);

	    svg$$1.selectAll('.curve').data(curves).enter().append('path').attr('class', 'curve').attr('fill', 'none')
	    //          .attr('stroke', 'url(#master)')
	    .attr('stroke', 'rgba(0,0,0,0.2)').attr('stroke-width', '2px').attr('d', line$$1);
	  },
	  updateLines: function updateLines() {
	    var _get8 = this.get(),
	        meanCurve = _get8.meanCurve,
	        curves = _get8.curves,
	        zero = _get8.zero,
	        sdArea = _get8.sdArea,
	        sdPlus = _get8.sdPlus,
	        sdMinus = _get8.sdMinus,
	        line$$1 = _get8.line;

	    var svg$$1 = select(this.refs.graph);

	    svg$$1.select('.zero').transition().duration(750).attr('d', zero(meanCurve));
	    svg$$1.select('.sdArea').transition().duration(750).attr('d', sdArea(meanCurve));
	    svg$$1.select('.sdPlus').transition().duration(750).attr('d', sdPlus(meanCurve));
	    svg$$1.select('.sdMinus').transition().duration(750).attr('d', sdMinus(meanCurve));

	    svg$$1.selectAll('.curve').data(curves).transition().transition().duration(750).attr('d', line$$1);
	  },
	  updateCircles: function updateCircles() {
	    var _get9 = this.get(),
	        curves = _get9.curves,
	        context = _get9.context;

	    var _refs$covMat$get2 = this.refs.covMat.get(),
	        hoveredRowIdx = _refs$covMat$get2.hoveredRowIdx,
	        colorsRow = _refs$covMat$get2.colorsRow;

	    var svg$$1 = select(this.refs.graph);
	    var circles = svg$$1.selectAll('g.circles').data(curves);
	    //Update
	    circles.selectAll('.samples').data(function (d) {
	      return d;
	    }).transition().duration(750).attr('cx', function (d) {
	      return context.u(d[0]);
	    }).attr('cy', function (d) {
	      return context.v(d[1]);
	    }).attr('stroke-opacity', function (d, i) {
	      if (colorsRow.length > 1) {
	        return colorsRow[i].cov;
	      } else {
	        return 0;
	      }
	    }).attr('stroke-with', function (d, i) {
	      if (hoveredRowIdx === i) {
	        return '4px';
	      } else {
	        return '1px';
	      }
	    });
	  },
	  updateGradient: function updateGradient() {
	    var matScale = select(this.refs.covScale);

	    var _refs$covMat$get3 = this.refs.covMat.get(),
	        hoveredRowIdx = _refs$covMat$get3.hoveredRowIdx,
	        colorsRow = _refs$covMat$get3.colorsRow,
	        offset = _refs$covMat$get3.offset,
	        gridSize = _refs$covMat$get3.gridSize;

	    var _get10 = this.get(),
	        meanCurve = _get10.meanCurve,
	        context = _get10.context,
	        countDimensions = _get10.countDimensions,
	        connectedline = _get10.connectedline;

	    var colorArray = this.colorBar();

	    matScale.selectAll('.lineConnector').data(meanCurve).attr('d', function (d, i) {
	      var xConv = context.u(d[0]);
	      var yConv = context.v(d[1] + 2 * d[2]);
	      var offsetRight = 37 + gridSize / 2 + (gridSize + offset) * i;
	      var offsetLeft = xConv + context.width - context.width / (countDimensions - 1) * i;
	      return connectedline([[xConv + 1, yConv], [xConv + 1, -16], [offsetLeft + offsetRight, -16], [offsetLeft + offsetRight, hoveredRowIdx * gridSize]]);
	    }).style('stroke-dasharray', function (d, i) {
	      if (hoveredRowIdx === i) {
	        return 'none';
	      } else {
	        return '4';
	      }
	    }).style('stroke-opacity', function (d, i) {
	      if (colorsRow.length > 1) {
	        if (hoveredRowIdx === i) {
	          return 1;
	        } else {
	          return colorsRow[i].cov;
	        }
	      } else {
	        return 0;
	      }
	    }).style('stroke-width', function (d, i) {
	      if (hoveredRowIdx === i) {
	        return '2px';
	      } else {
	        return '1px';
	      }
	    });
	    this.colorGradient(colorArray, colorsRow);
	  }
	};

	function oncreate$7() {
	  var _this = this;

	  this.resample(0);

	  this.createVis();
	  this.refs.covMat.on('update', function () {
	    _this.resampleFake();
	  });
	}
	function onupdate$3(_ref7) {
	  var _changed = _ref7._changed,
	      current = _ref7.current,
	      _previous = _ref7._previous;

	  var _refs$covMat$get4 = this.refs.covMat.get(),
	      shouldResample = _refs$covMat$get4.shouldResample;

	  var _get11 = this.get(),
	      countSamples = _get11.countSamples;

	  var xPosOuter = document.getElementById('Posterior').getBoundingClientRect().x;
	  var xPos = this.refs.grid.getBoundingClientRect().left;
	  this.refs.annotations.style.left = xPos - xPosOuter + 'px';

	  if (shouldResample) {
	    for (var i = 0; i < countSamples; i++) {
	      this.resample(i);
	    }
	  }

	  this.updateLines();
	  this.updateCircles();
	  this.updateGradient();
	}
	function add_css$a() {
	  var style = createElement("style");
	  style.id = 'svelte-qwaljy-style';
	  style.textContent = ".svelte-ref-annotations.svelte-qwaljy{position:absolute;pointer-events:none;margin:1em;top:0px;left:0px}.kernel-grid.svelte-qwaljy{display:inline-grid;grid-template-columns:auto auto auto}.kernel-grid.svelte-qwaljy{display:inline-grid;grid-template-columns:auto auto auto}.grid-item.svelte-qwaljy{margin:1em}.svelte-ref-zero.svelte-qwaljy{stroke:rgba(0, 0, 0, 0.2);stroke-width:1px}.sdLine.svelte-qwaljy{fill:none;stroke:rgba(0, 0, 0, 0.2);stroke-width:2px;stroke-dasharray:4}.line.svelte-qwaljy{fill:none;stroke:#c51b8a;stroke-width:2px}.samples.svelte-qwaljy{stroke:black;stroke-width:1px;stroke-opacity:0}.inactive.svelte-qwaljy{fill:transparent;stroke:rgba(0, 0, 0, 0.4);stroke-dasharray:2;stroke-width:2px}.active.svelte-qwaljy{fill:transparent;stroke:rgba(0, 0, 0, 0.4);stroke-width:2px}";
	  appendNode(style, document.head);
	}

	function create_main_fragment$c(component, ctx) {
	  var div, div_1, div_2, svg$$1, g, text$$1, text_1, text_y_value, line_1, line_1_y__value, line_1_x__value, line_1_y__value_1, g_1, text_2, tspan, text_3, text_2_y_value, svg_width_value, svg_height_value, text_5, div_3, text_8, div_4, svg_1, svg_1_width_value;

	  var each_value = ctx.trainingPoints;

	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$8(component, get_each_context$8(ctx, each_value, i));
	  }

	  function click_handler_1(event$$1) {
	    component.resample(0);
	  }

	  var kernelcovmat_initial_data = {
	    external: true,
	    interaction: true,
	    gridSize: 6,
	    offset: 0,
	    slider: false,
	    n: ctx.countDimensions,
	    width: 300,
	    height: 300
	  };
	  var kernelcovmat = new KernelCovMat({
	    root: component.root,
	    store: component.store,
	    data: kernelcovmat_initial_data
	  });

	  component.refs.covMat = kernelcovmat;

	  return {
	    c: function c() {
	      div = createElement("div");
	      div_1 = createElement("div");
	      div_2 = createElement("div");
	      svg$$1 = createSvgElement("svg");
	      g = createSvgElement("g");
	      text$$1 = createSvgElement("text");
	      text_1 = createText("y = 0");
	      line_1 = createSvgElement("line");
	      g_1 = createSvgElement("g");

	      for (var i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }

	      text_2 = createSvgElement("text");
	      tspan = createSvgElement("tspan");
	      text_3 = createText("(click to resample)");
	      text_5 = createText("\n    ");
	      div_3 = createElement("div");
	      kernelcovmat._fragment.c();
	      text_8 = createText("\n  ");
	      div_4 = createElement("div");
	      svg_1 = createSvgElement("svg");
	      setAttribute(text$$1, "x", "5");
	      setAttribute(text$$1, "y", text_y_value = toV$3(ctx.context, 0) - 5);
	      setAttribute(text$$1, "class", "annotation");
	      setAttribute(line_1, "x1", "0");
	      setAttribute(line_1, "y1", line_1_y__value = toV$3(ctx.context, 0));
	      setAttribute(line_1, "x2", line_1_x__value = ctx.context.width);
	      setAttribute(line_1, "y2", line_1_y__value_1 = toV$3(ctx.context, 0));
	      setAttribute(line_1, "class", "svelte-qwaljy svelte-ref-zero");
	      setAttribute(tspan, "fill", "rgb(245, 181, 62)");
	      setAttribute(tspan, "font-style", "italic");
	      setAttribute(text_2, "x", 5);
	      setAttribute(text_2, "y", text_2_y_value = ctx.context.height - 5);
	      setAttribute(text_2, "class", "annotation");
	      addListener(svg$$1, "click", click_handler_1);
	      setAttribute(svg$$1, "class", "plot");
	      setAttribute(svg$$1, "width", svg_width_value = ctx.context.width);
	      setAttribute(svg$$1, "height", svg_height_value = ctx.context.height);
	      div_2.className = "grid-item svelte-qwaljy";
	      div_3.className = "grid-item svelte-qwaljy";
	      div_1.className = "kernel-grid svelte-qwaljy";
	      setAttribute(svg_1, "width", svg_1_width_value = ctx.context.width);
	      setAttribute(svg_1, "height", "50");
	      setStyle(svg_1, "overflow", "visible");
	      div_4.className = "svelte-qwaljy svelte-ref-annotations";
	      div.className = "figure";
	      setAttribute(div, "xmlns:ref", "http://www.w3.org/1999/xhtml");
	    },
	    m: function m(target, anchor) {
	      insertNode(div, target, anchor);
	      appendNode(div_1, div);
	      appendNode(div_2, div_1);
	      appendNode(svg$$1, div_2);
	      appendNode(g, svg$$1);
	      appendNode(text$$1, g);
	      appendNode(text_1, text$$1);
	      appendNode(line_1, g);
	      component.refs.zero = line_1;
	      component.refs.graph = g;
	      appendNode(g_1, svg$$1);

	      for (var i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].m(g_1, null);
	      }

	      appendNode(text_2, svg$$1);
	      appendNode(tspan, text_2);
	      appendNode(text_3, tspan);
	      component.refs.svgArea = svg$$1;
	      appendNode(text_5, div_1);
	      appendNode(div_3, div_1);
	      kernelcovmat._mount(div_3, null);
	      component.refs.grid = div_1;
	      appendNode(text_8, div);
	      appendNode(div_4, div);
	      appendNode(svg_1, div_4);
	      component.refs.covScale = svg_1;
	      component.refs.annotations = div_4;
	    },
	    p: function p(changed, ctx) {
	      if (changed.context && text_y_value !== (text_y_value = toV$3(ctx.context, 0) - 5)) {
	        setAttribute(text$$1, "y", text_y_value);
	      }

	      if (changed.context && line_1_y__value !== (line_1_y__value = toV$3(ctx.context, 0))) {
	        setAttribute(line_1, "y1", line_1_y__value);
	      }

	      if (changed.context && line_1_x__value !== (line_1_x__value = ctx.context.width)) {
	        setAttribute(line_1, "x2", line_1_x__value);
	      }

	      if (changed.context && line_1_y__value_1 !== (line_1_y__value_1 = toV$3(ctx.context, 0))) {
	        setAttribute(line_1, "y2", line_1_y__value_1);
	      }

	      if (changed.trainingPoints || changed.context) {
	        each_value = ctx.trainingPoints;

	        for (var i = 0; i < each_value.length; i += 1) {
	          var child_ctx = get_each_context$8(ctx, each_value, i);

	          if (each_blocks[i]) {
	            each_blocks[i].p(changed, child_ctx);
	          } else {
	            each_blocks[i] = create_each_block$8(component, child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(g_1, null);
	          }
	        }

	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }

	      if (changed.context && text_2_y_value !== (text_2_y_value = ctx.context.height - 5)) {
	        setAttribute(text_2, "y", text_2_y_value);
	      }

	      if (changed.context && svg_width_value !== (svg_width_value = ctx.context.width)) {
	        setAttribute(svg$$1, "width", svg_width_value);
	      }

	      if (changed.context && svg_height_value !== (svg_height_value = ctx.context.height)) {
	        setAttribute(svg$$1, "height", svg_height_value);
	      }

	      var kernelcovmat_changes = {};
	      if (changed.countDimensions) kernelcovmat_changes.n = ctx.countDimensions;
	      kernelcovmat._set(kernelcovmat_changes);

	      if (changed.context && svg_1_width_value !== (svg_1_width_value = ctx.context.width)) {
	        setAttribute(svg_1, "width", svg_1_width_value);
	      }
	    },
	    d: function d(detach) {
	      if (detach) {
	        detachNode(div);
	      }

	      if (component.refs.zero === line_1) component.refs.zero = null;
	      if (component.refs.graph === g) component.refs.graph = null;

	      destroyEach(each_blocks, detach);

	      removeListener(svg$$1, "click", click_handler_1);
	      if (component.refs.svgArea === svg$$1) component.refs.svgArea = null;
	      kernelcovmat.destroy();
	      if (component.refs.covMat === kernelcovmat) component.refs.covMat = null;
	      if (component.refs.grid === div_1) component.refs.grid = null;
	      if (component.refs.covScale === svg_1) component.refs.covScale = null;
	      if (component.refs.annotations === div_4) component.refs.annotations = null;
	    }
	  };
	}

	// (17:10) {#each trainingPoints as pt, idx}
	function create_each_block$8(component, ctx) {
	  var circle$$1, circle_class_value, circle_cx_value, circle_cy_value;

	  var if_block = ctx.pt.active && create_if_block$5(component, ctx);

	  return {
	    c: function c() {
	      if (if_block) if_block.c();
	      circle$$1 = createSvgElement("circle");
	      circle$$1._svelte = { component: component, ctx: ctx };

	      addListener(circle$$1, "click", click_handler$1);
	      setAttribute(circle$$1, "class", circle_class_value = "trainingPoint " + (ctx.pt.active ? 'active' : 'inactive') + " svelte-qwaljy");
	      setAttribute(circle$$1, "cx", circle_cx_value = toU$2(ctx.context, ctx.pt.x));
	      setAttribute(circle$$1, "cy", circle_cy_value = toV$3(ctx.context, ctx.pt.y));
	      setAttribute(circle$$1, "r", "6");
	    },
	    m: function m(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insertNode(circle$$1, target, anchor);
	    },
	    p: function p(changed, ctx) {
	      if (ctx.pt.active) {
	        if (if_block) {
	          if_block.p(changed, ctx);
	        } else {
	          if_block = create_if_block$5(component, ctx);
	          if_block.c();
	          if_block.m(circle$$1.parentNode, circle$$1);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }

	      circle$$1._svelte.ctx = ctx;
	      if (changed.trainingPoints && circle_class_value !== (circle_class_value = "trainingPoint " + (ctx.pt.active ? 'active' : 'inactive') + " svelte-qwaljy")) {
	        setAttribute(circle$$1, "class", circle_class_value);
	      }

	      if ((changed.context || changed.trainingPoints) && circle_cx_value !== (circle_cx_value = toU$2(ctx.context, ctx.pt.x))) {
	        setAttribute(circle$$1, "cx", circle_cx_value);
	      }

	      if ((changed.context || changed.trainingPoints) && circle_cy_value !== (circle_cy_value = toV$3(ctx.context, ctx.pt.y))) {
	        setAttribute(circle$$1, "cy", circle_cy_value);
	      }
	    },
	    d: function d(detach) {
	      if (if_block) if_block.d(detach);
	      if (detach) {
	        detachNode(circle$$1);
	      }

	      removeListener(circle$$1, "click", click_handler$1);
	    }
	  };
	}

	// (18:10) {#if pt.active}
	function create_if_block$5(component, ctx) {
	  var circle$$1, circle_cx_value, circle_cy_value;

	  return {
	    c: function c() {
	      circle$$1 = createSvgElement("circle");
	      setAttribute(circle$$1, "cx", circle_cx_value = toU$2(ctx.context, ctx.pt.x));
	      setAttribute(circle$$1, "cy", circle_cy_value = toV$3(ctx.context, ctx.pt.y));
	      setAttribute(circle$$1, "r", "3");
	      setAttribute(circle$$1, "fill", "rgba(0,0,0,0.6)");
	    },
	    m: function m(target, anchor) {
	      insertNode(circle$$1, target, anchor);
	    },
	    p: function p(changed, ctx) {
	      if ((changed.context || changed.trainingPoints) && circle_cx_value !== (circle_cx_value = toU$2(ctx.context, ctx.pt.x))) {
	        setAttribute(circle$$1, "cx", circle_cx_value);
	      }

	      if ((changed.context || changed.trainingPoints) && circle_cy_value !== (circle_cy_value = toV$3(ctx.context, ctx.pt.y))) {
	        setAttribute(circle$$1, "cy", circle_cy_value);
	      }
	    },
	    d: function d(detach) {
	      if (detach) {
	        detachNode(circle$$1);
	      }
	    }
	  };
	}

	function get_each_context$8(ctx, list, i) {
	  var child_ctx = Object.create(ctx);
	  child_ctx.pt = list[i];
	  child_ctx.each_value = list;
	  child_ctx.idx = i;
	  return child_ctx;
	}

	function click_handler$1(event$$1) {
	  var _svelte = this._svelte,
	      component = _svelte.component,
	      ctx = _svelte.ctx;


	  component.toggle(ctx.idx);
	}

	function Posterior(options) {
	  var _this2 = this;

	  init(this, options);
	  this.refs = {};
	  this._state = assign(data$c(), options.data);
	  this._recompute({ context: 1 }, this._state);
	  this._intro = true;
	  this._handlers.update = [onupdate$3];

	  if (!document.getElementById("svelte-qwaljy-style")) add_css$a();

	  if (!options.root) {
	    this._oncreate = [];
	    this._beforecreate = [];
	    this._aftercreate = [];
	  }

	  this._fragment = create_main_fragment$c(this, this._state);

	  this.root._oncreate.push(function () {
	    oncreate$7.call(_this2);
	    _this2.fire("update", { changed: assignTrue({}, _this2._state), current: _this2._state });
	  });

	  if (options.target) {
	    this._fragment.c();
	    this._mount(options.target, options.anchor);

	    this._lock = true;
	    callAll(this._beforecreate);
	    callAll(this._oncreate);
	    callAll(this._aftercreate);
	    this._lock = false;
	  }
	}

	assign(Posterior.prototype, proto);
	assign(Posterior.prototype, methods$4);

	Posterior.prototype._recompute = function _recompute(changed, state) {
	  if (changed.context) {
	    if (this._differs(state.connectedline, state.connectedline = connectedline$1(state))) changed.connectedline = true;
	    if (this._differs(state.line, state.line = line$2(state))) changed.line = true;
	    if (this._differs(state.zero, state.zero = zero$2(state))) changed.zero = true;
	    if (this._differs(state.sdPlus, state.sdPlus = sdPlus$2(state))) changed.sdPlus = true;
	    if (this._differs(state.sdMinus, state.sdMinus = sdMinus$2(state))) changed.sdMinus = true;
	    if (this._differs(state.sdArea, state.sdArea = sdArea$2(state))) changed.sdArea = true;
	  }
	};

	/* src/scripts/components/KernelCombinations.html generated by Svelte v2.9.1 */

	function line$3(_ref) {
		var context = _ref.context;

		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1]);
		});
	}

	function zero$3(_ref2) {
		var context = _ref2.context;
		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1]);
		});
	}

	function sdPlus$3(_ref3) {
		var context = _ref3.context;
		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1] + 2 * d[2]);
		});
	}

	function sdMinus$3(_ref4) {
		var context = _ref4.context;
		return line().x(function (d) {
			return context.u(d[0]);
		}).y(function (d) {
			return context.v(d[1] - 2 * d[2]);
		});
	}

	function sdArea$3(_ref5) {
		var context = _ref5.context;
		return area$3().x(function (d) {
			return context.u(d[0]);
		}).y0(function (d) {
			return context.v(d[1] - 2 * d[2]);
		}).y1(function (d) {
			return context.v(d[1] + 2 * d[2]);
		});
	}

	function data$d() {
		return {
			trainingPoints: [],
			countDimensions: 75,
			context: new Context(500, 300, [-5, 5], [-10, 10]),
			curves: [],
			circleSize: 3,
			kernels: [{
				kernel: rbf,
				name: 'RBF',
				active: true,
				params: [{
					name: 'Variance σ',
					value: 1,
					min: 0,
					max: 1
				}, {
					name: 'Length l',
					value: 1,
					min: 0,
					max: 1
				}]
			}, {
				name: 'Periodic',
				kernel: periodic,
				active: false,
				params: [{
					name: 'Variance σ',
					value: 1,
					min: 0,
					max: 1
				}, {
					name: 'Length l',
					value: 3,
					min: 0,
					max: 1
				}, {
					name: 'P',
					value: 0.8,
					min: 0,
					max: 1
				}]
			}, {
				name: 'Linear',
				kernel: linear$4,
				active: false,
				params: [{
					name: 'Variance σ',
					value: 0.3,
					min: 0,
					max: 1
				}, {
					name: 'Sigma_b',
					value: 0.5,
					min: 0,
					max: 1
				}, {
					name: 'Offset c',
					value: 0,
					min: -1,
					max: 1
				}]
			}],
			useTrainingData: false,
			currentKernel: rbf,
			currentParams: [],
			countSamples: 3,
			meanCurve: [],
			firstClick: true

		};
	}
	function toV$4(context, y) {
		return context.v(y);
	}
	function toU$3(context, x) {
		return context.u(x);
	}
	var methods$5 = {
		createTrainingSet: function createTrainingSet() {
			// Create test values
			var xTrain = [0.7238, -0.3105, 0.3172, -3.0417, 2];
			var isActive = [true, true, true, true, true];
			var yTrain = xTrain.map(function (x) {
				return Math.sin(6 * x) + 2 * x;
			});
			var result = xTrain.map(function (d, i) {
				return {
					x: xTrain[i],
					y: yTrain[i],
					active: isActive[i]
				};
			});
			this.set({ trainingPoints: result });
		},
		fkt: function fkt() {
			var solution = 1;
			var rbf$$1 = rbf();
			var periodic$$1 = periodic(1, 3, 0.8);
			var linear$$1 = linear$4(0.3, 0.5, 0);
			var paramsList = [];

			var _get = this.get(),
			    kernels = _get.kernels;

			if (kernels[0].active) {
				solution = rbf$$1;
				paramsList[0] = kernels[0];
			}
			if (kernels[1].active) {
				solution = periodic$$1;
				paramsList[0] = kernels[1];
			}
			if (kernels[2].active) {
				solution = linear$$1;
				paramsList[0] = kernels[2];
			}
			if (kernels[0].active && kernels[1].active) {
				solution = combineKernels([rbf$$1, periodic$$1]);
				paramsList[0] = kernels[0];
				paramsList[1] = kernels[1];
			}
			if (kernels[1].active && kernels[2].active) {
				solution = combineKernels([linear$$1, periodic$$1]);
				paramsList[0] = kernels[1];
				paramsList[1] = kernels[2];
			}
			if (kernels[0].active && kernels[2].active) {
				solution = combineKernels([linear$$1, rbf$$1]);
				paramsList[0] = kernels[0];
				paramsList[1] = kernels[2];
			}
			if (kernels[0].active && kernels[1].active && kernels[2].active) {
				solution = combineKernels([linear$$1, periodic$$1, rbf$$1]);
				paramsList[0] = kernels[0];
				paramsList[1] = kernels[1];
				paramsList[2] = kernels[2];
			}
			this.set({ currentParams: paramsList });
			return solution;
		},
		resample: function resample(idx) {
			var _get2 = this.get(),
			    context = _get2.context,
			    trainingPoints = _get2.trainingPoints;

			var _get3 = this.get(),
			    countDimensions = _get3.countDimensions,
			    currentKernel = _get3.currentKernel,
			    curves = _get3.curves;

			// creates linear spaced values


			var N = countDimensions;

			var _context$xDomain = context.xDomain(),
			    _context$xDomain2 = slicedToArray(_context$xDomain, 2),
			    xmin = _context$xDomain2[0],
			    xmax = _context$xDomain2[1];

			var step$$1 = (xmax - xmin) / (N - 1);
			var xs = sequence(xmin, xmax + step$$1, step$$1);

			// prepare training data
			var activePoints = trainingPoints.filter(function (p) {
				return p.active;
			});
			var xsTrain = activePoints.map(function (p) {
				return p.x;
			});
			var ysTrain = activePoints.map(function (p) {
				return p.y;
			});

			var process = gaussianProcess(currentKernel, xs, xsTrain, ysTrain);
			var ys = process.sample();
			var ysMean = process.getMean();
			var sd = process.getSd();

			this.refs.covMat.externalCov(process.cov);
			this.refs.covMat.set({ covMatrix: process.cov, kernel: currentKernel });

			var pts = zip(xs, ys, sd);
			var ptsMean = zip(xs, ysMean, sd);

			curves[idx] = pts;
			this.set({ curves: curves, meanCurve: ptsMean });
		},
		toggle: function toggle(idx) {
			var _get4 = this.get(),
			    trainingPoints = _get4.trainingPoints;

			trainingPoints[idx].active = !trainingPoints[idx].active;
			this.set({ trainingPoints: trainingPoints });
		},
		setFirstClick: function setFirstClick(set$$1) {
			this.set({ firstClick: set$$1 });
		}
	};

	function oncreate$8() {
		var result = this.fkt();
		this.set({ currentKernel: result });
		this.createTrainingSet();

		var _get5 = this.get(),
		    meanCurve = _get5.meanCurve,
		    sdPlus = _get5.sdPlus,
		    sdMinus = _get5.sdMinus,
		    sdArea = _get5.sdArea,
		    zero = _get5.zero,
		    curves = _get5.curves,
		    line$$1 = _get5.line;

		var svg$$1 = select(this.refs.graph);

		svg$$1.append('path').data([meanCurve]).attr('class', 'sdArea').attr('stroke', 'none').attr('fill', 'rgba(255,224,255,0.6)').attr('d', sdArea);

		svg$$1.append('path').data([meanCurve]).attr('class', 'zero').attr('fill', 'none').attr('stroke', '#c51b8a').attr('stroke-width', '2px').attr('d', zero);

		svg$$1.append('path').data([meanCurve]).attr('class', 'sdPlus').attr('fill', 'none').attr('stroke', '#fa9fb5').attr('stroke-width', '1px').attr('d', sdPlus);

		svg$$1.append('path').data([meanCurve]).attr('class', 'sdMinus').attr('fill', 'none').attr('stroke', '#fa9fb5').attr('stroke-width', '1px').attr('d', sdMinus);

		svg$$1.selectAll('.curve').data(curves).enter().append('path').attr('class', 'curve').attr('fill', 'none').attr('stroke', 'rgba(0,0,0,0.2)').attr('stroke-width', '2px').attr('d', line$$1);
	}
	function onupdate$4(_ref6) {
		var _changed = _ref6._changed,
		    current = _ref6.current,
		    _previous = _ref6._previous;

		var result = this.fkt();
		current.currentKernel = result;
		var svg$$1 = select(this.refs.graph);
		if (result != 1) {
			this.set({ currentKernel: result });

			var _refs$covMat$get = this.refs.covMat.get(),
			    shouldResample = _refs$covMat$get.shouldResample;

			var _get6 = this.get(),
			    countSamples = _get6.countSamples;

			if (shouldResample) {
				for (var i = 0; i < countSamples; i++) {
					this.resample(i);
				}
			}

			var _get7 = this.get(),
			    meanCurve = _get7.meanCurve;

			svg$$1.select('.zero').transition().duration(750).attr('d', current.zero(meanCurve)).style('opacity', 1);
			svg$$1.select('.sdArea').transition().duration(750).attr('d', current.sdArea(meanCurve)).style('opacity', 1);
			svg$$1.select('.sdPlus').transition().duration(750).attr('d', current.sdPlus(meanCurve)).style('opacity', 1);
			svg$$1.select('.sdMinus').transition().duration(750).attr('d', current.sdMinus(meanCurve)).style('opacity', 1);

			svg$$1.selectAll('.curve').data(current.curves).transition().duration(750).attr('d', current.line).style('opacity', 1);
		} else {
			svg$$1.select('.zero').transition().duration(750).style('opacity', 0);
			svg$$1.select('.sdArea').transition().duration(750).style('opacity', 0);
			svg$$1.select('.sdPlus').transition().duration(750).style('opacity', 0);
			svg$$1.select('.sdMinus').transition().duration(750).style('opacity', 0);

			svg$$1.selectAll('.curve').transition().duration(750).style('opacity', 0);
		}
	}
	function add_css$b() {
		var style = createElement("style");
		style.id = 'svelte-t9dbix-style';
		style.textContent = "#info.svelte-t9dbix g:hover .annotation.svelte-t9dbix{display:block}#info.svelte-t9dbix g:hover .icon.svelte-t9dbix{display:none}#info.svelte-t9dbix .annotation.svelte-t9dbix{display:none}#info.svelte-t9dbix .icon.svelte-t9dbix{display:block}.hoverText.svelte-t9dbix{fill:rgb(245, 181, 62);font-size:13px;font-style:italic}.kernel-grid.svelte-t9dbix{display:inline-grid;grid-template-columns:auto auto auto}.grid-item.svelte-t9dbix{margin:1em}.svelte-ref-zero.svelte-t9dbix{stroke:rgba(0,0,0,0.2);stroke-width:1px}.sdLine.svelte-t9dbix{fill:none;stroke:rgba(0,0,0,0.2);stroke-width:2px;stroke-dasharray:4}.line.svelte-t9dbix{fill:none;stroke:#c51b8a;stroke-width:2px}.inactive.svelte-t9dbix{fill:transparent;stroke:rgba(0, 0, 0, 0.4);stroke-dasharray:2;stroke-width:2px}.active.svelte-t9dbix{fill:transparent;stroke:rgba(0, 0, 0, 0.4);stroke-width:2px}";
		appendNode(style, document.head);
	}

	function create_main_fragment$d(component, ctx) {
		var div, text_1, div_1, div_2, svg$$1, g, text_2, text_3, text_2_y_value, line_1, text_4, text_5, text_4_x_value, text_4_y_value, line_2, line_2_y__value, line_2_x__value, line_2_y__value_1, text_6, text_7, text_6_x_value, text_6_y_value, line_3, line_3_y__value, line_3_x__value, line_3_y__value_1, text_8, text_9, text_8_x_value, text_8_y_value, line_1_y__value, line_1_x__value, line_1_y__value_1, g_1, svg_1, g_2, g_3, path$$1, path_1, g_4, text_10, svg_1_visibility_value, svg_width_value, svg_height_value, text_12, div_3;

		var each_value = ctx.kernels;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$9(component, get_each_context$9(ctx, each_value, i));
		}

		var each_value_1 = ctx.trainingPoints;

		var each_1_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_1_blocks[i] = create_each_block_1$2(component, get_each_1_context$2(ctx, each_value_1, i));
		}

		var if_block = ctx.firstClick && create_if_block_1$3(component, ctx);

		var each_value_2 = ctx.currentParams;

		var each_2_blocks = [];

		for (var i = 0; i < each_value_2.length; i += 1) {
			each_2_blocks[i] = create_each_block_2$2(component, get_each_2_context$2(ctx, each_value_2, i));
		}

		function mouseover_handler(event$$1) {
			component.setFirstClick(false);
		}

		var kernelcovmat_initial_data = {
			external: true,
			interaction: false,
			n: ctx.countDimensions,
			width: 300,
			height: 300,
			offset: 0,
			gridSize: 4,
			slider: false
		};
		var kernelcovmat = new KernelCovMat({
			root: component.root,
			store: component.store,
			data: kernelcovmat_initial_data
		});

		component.refs.covMat = kernelcovmat;

		return {
			c: function c() {
				div = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text_1 = createText("\n");
				div_1 = createElement("div");
				div_2 = createElement("div");
				svg$$1 = createSvgElement("svg");
				g = createSvgElement("g");
				text_2 = createSvgElement("text");
				text_3 = createText("y = 0");
				line_1 = createSvgElement("line");
				text_4 = createSvgElement("text");
				text_5 = createText("μ");
				line_2 = createSvgElement("line");
				text_6 = createSvgElement("text");
				text_7 = createText("μ + 2σ");
				line_3 = createSvgElement("line");
				text_8 = createSvgElement("text");
				text_9 = createText("μ - 2σ");
				g_1 = createSvgElement("g");

				for (var i = 0; i < each_1_blocks.length; i += 1) {
					each_1_blocks[i].c();
				}

				svg_1 = createSvgElement("svg");
				g_2 = createSvgElement("g");
				g_3 = createSvgElement("g");
				path$$1 = createSvgElement("path");
				path_1 = createSvgElement("path");
				if (if_block) if_block.c();
				g_4 = createSvgElement("g");
				text_10 = createSvgElement("text");

				for (var i = 0; i < each_2_blocks.length; i += 1) {
					each_2_blocks[i].c();
				}

				text_12 = createText("\n  ");
				div_3 = createElement("div");
				kernelcovmat._fragment.c();
				setAttribute(div, "xmlns:bind", "http://www.w3.org/1999/xhtml");
				setAttribute(text_2, "x", "5");
				setAttribute(text_2, "y", text_2_y_value = toV$4(ctx.context, 0) - 5);
				setAttribute(text_2, "class", "annotation");
				setAttribute(text_4, "x", text_4_x_value = ctx.context.width - 14);
				setAttribute(text_4, "y", text_4_y_value = toV$4(ctx.context, 0) - 5);
				setAttribute(text_4, "class", "annotation");
				setAttribute(line_2, "class", "sdLine svelte-t9dbix");
				setAttribute(line_2, "x1", "0");
				setAttribute(line_2, "y1", line_2_y__value = toV$4(ctx.context, 2));
				setAttribute(line_2, "x2", line_2_x__value = ctx.context.width);
				setAttribute(line_2, "y2", line_2_y__value_1 = toV$4(ctx.context, 2));
				setAttribute(text_6, "x", text_6_x_value = ctx.context.width - 42);
				setAttribute(text_6, "y", text_6_y_value = toV$4(ctx.context, 2) - 5);
				setAttribute(text_6, "class", "annotation");
				setAttribute(line_3, "class", "sdLine svelte-t9dbix");
				setAttribute(line_3, "x1", "0");
				setAttribute(line_3, "y1", line_3_y__value = toV$4(ctx.context, -2));
				setAttribute(line_3, "x2", line_3_x__value = ctx.context.width);
				setAttribute(line_3, "y2", line_3_y__value_1 = toV$4(ctx.context, -2));
				setAttribute(text_8, "x", text_8_x_value = ctx.context.width - 42);
				setAttribute(text_8, "y", text_8_y_value = toV$4(ctx.context, -2) - 5);
				setAttribute(text_8, "class", "annotation");
				setAttribute(line_1, "x1", "0");
				setAttribute(line_1, "y1", line_1_y__value = toV$4(ctx.context, 0));
				setAttribute(line_1, "x2", line_1_x__value = ctx.context.width);
				setAttribute(line_1, "y2", line_1_y__value_1 = toV$4(ctx.context, 0));
				setAttribute(line_1, "class", "svelte-t9dbix svelte-ref-zero");
				setAttribute(path$$1, "d", "M0 0h24v24H0z");
				setAttribute(path$$1, "fill", "none");
				setAttribute(path_1, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z");
				setAttribute(path_1, "fill", "rgb(245, 181, 62)");
				setAttribute(g_3, "class", "icon svelte-t9dbix");
				setAttribute(text_10, "x", 5);
				setAttribute(text_10, "y", 0);
				setAttribute(text_10, "class", "annotation svelte-t9dbix");
				addListener(svg_1, "mouseover", mouseover_handler);
				setAttribute(svg_1, "id", "info");
				setAttribute(svg_1, "x", "5");
				setAttribute(svg_1, "y", 5);
				setAttribute(svg_1, "visibility", svg_1_visibility_value = ctx.kernels.filter(function (p) {
					return p.active;
				}).length > 0 ? 'visible' : 'hidden');
				setAttribute(svg_1, "class", "svelte-t9dbix");
				setAttribute(svg$$1, "class", "plot");
				setAttribute(svg$$1, "width", svg_width_value = ctx.context.width);
				setAttribute(svg$$1, "height", svg_height_value = ctx.context.height);
				div_2.className = "grid-item svelte-t9dbix";
				div_3.className = "grid-item svelte-t9dbix";
				div_1.className = "kernel-grid svelte-t9dbix";
			},
			m: function m(target, anchor) {
				insertNode(div, target, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div, null);
				}

				insertNode(text_1, target, anchor);
				insertNode(div_1, target, anchor);
				appendNode(div_2, div_1);
				appendNode(svg$$1, div_2);
				appendNode(g, svg$$1);
				appendNode(text_2, g);
				appendNode(text_3, text_2);
				appendNode(line_1, g);
				appendNode(text_4, line_1);
				appendNode(text_5, text_4);
				appendNode(line_2, line_1);
				appendNode(text_6, line_1);
				appendNode(text_7, text_6);
				appendNode(line_3, line_1);
				appendNode(text_8, line_1);
				appendNode(text_9, text_8);
				component.refs.zero = line_1;
				component.refs.graph = g;
				appendNode(g_1, svg$$1);

				for (var i = 0; i < each_1_blocks.length; i += 1) {
					each_1_blocks[i].m(g_1, null);
				}

				appendNode(svg_1, svg$$1);
				appendNode(g_2, svg_1);
				appendNode(g_3, g_2);
				appendNode(path$$1, g_3);
				appendNode(path_1, g_3);
				if (if_block) if_block.m(g_3, null);
				appendNode(g_4, g_2);
				appendNode(text_10, g_4);

				for (var i = 0; i < each_2_blocks.length; i += 1) {
					each_2_blocks[i].m(text_10, null);
				}

				component.refs.svgArea = svg$$1;
				appendNode(text_12, div_1);
				appendNode(div_3, div_1);
				kernelcovmat._mount(div_3, null);
			},
			p: function p(changed, ctx) {
				if (changed.kernels) {
					each_value = ctx.kernels;

					for (var i = 0; i < each_value.length; i += 1) {
						var child_ctx = get_each_context$9(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$9(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (changed.context && text_2_y_value !== (text_2_y_value = toV$4(ctx.context, 0) - 5)) {
					setAttribute(text_2, "y", text_2_y_value);
				}

				if (changed.context && text_4_x_value !== (text_4_x_value = ctx.context.width - 14)) {
					setAttribute(text_4, "x", text_4_x_value);
				}

				if (changed.context && text_4_y_value !== (text_4_y_value = toV$4(ctx.context, 0) - 5)) {
					setAttribute(text_4, "y", text_4_y_value);
				}

				if (changed.context && line_2_y__value !== (line_2_y__value = toV$4(ctx.context, 2))) {
					setAttribute(line_2, "y1", line_2_y__value);
				}

				if (changed.context && line_2_x__value !== (line_2_x__value = ctx.context.width)) {
					setAttribute(line_2, "x2", line_2_x__value);
				}

				if (changed.context && line_2_y__value_1 !== (line_2_y__value_1 = toV$4(ctx.context, 2))) {
					setAttribute(line_2, "y2", line_2_y__value_1);
				}

				if (changed.context && text_6_x_value !== (text_6_x_value = ctx.context.width - 42)) {
					setAttribute(text_6, "x", text_6_x_value);
				}

				if (changed.context && text_6_y_value !== (text_6_y_value = toV$4(ctx.context, 2) - 5)) {
					setAttribute(text_6, "y", text_6_y_value);
				}

				if (changed.context && line_3_y__value !== (line_3_y__value = toV$4(ctx.context, -2))) {
					setAttribute(line_3, "y1", line_3_y__value);
				}

				if (changed.context && line_3_x__value !== (line_3_x__value = ctx.context.width)) {
					setAttribute(line_3, "x2", line_3_x__value);
				}

				if (changed.context && line_3_y__value_1 !== (line_3_y__value_1 = toV$4(ctx.context, -2))) {
					setAttribute(line_3, "y2", line_3_y__value_1);
				}

				if (changed.context && text_8_x_value !== (text_8_x_value = ctx.context.width - 42)) {
					setAttribute(text_8, "x", text_8_x_value);
				}

				if (changed.context && text_8_y_value !== (text_8_y_value = toV$4(ctx.context, -2) - 5)) {
					setAttribute(text_8, "y", text_8_y_value);
				}

				if (changed.context && line_1_y__value !== (line_1_y__value = toV$4(ctx.context, 0))) {
					setAttribute(line_1, "y1", line_1_y__value);
				}

				if (changed.context && line_1_x__value !== (line_1_x__value = ctx.context.width)) {
					setAttribute(line_1, "x2", line_1_x__value);
				}

				if (changed.context && line_1_y__value_1 !== (line_1_y__value_1 = toV$4(ctx.context, 0))) {
					setAttribute(line_1, "y2", line_1_y__value_1);
				}

				if (changed.trainingPoints || changed.context || changed.countDimensions) {
					each_value_1 = ctx.trainingPoints;

					for (var i = 0; i < each_value_1.length; i += 1) {
						var _child_ctx = get_each_1_context$2(ctx, each_value_1, i);

						if (each_1_blocks[i]) {
							each_1_blocks[i].p(changed, _child_ctx);
						} else {
							each_1_blocks[i] = create_each_block_1$2(component, _child_ctx);
							each_1_blocks[i].c();
							each_1_blocks[i].m(g_1, null);
						}
					}

					for (; i < each_1_blocks.length; i += 1) {
						each_1_blocks[i].d(1);
					}
					each_1_blocks.length = each_value_1.length;
				}

				if (ctx.firstClick) {
					if (!if_block) {
						if_block = create_if_block_1$3(component, ctx);
						if_block.c();
						if_block.m(g_3, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.currentParams) {
					each_value_2 = ctx.currentParams;

					for (var i = 0; i < each_value_2.length; i += 1) {
						var _child_ctx2 = get_each_2_context$2(ctx, each_value_2, i);

						if (each_2_blocks[i]) {
							each_2_blocks[i].p(changed, _child_ctx2);
						} else {
							each_2_blocks[i] = create_each_block_2$2(component, _child_ctx2);
							each_2_blocks[i].c();
							each_2_blocks[i].m(text_10, null);
						}
					}

					for (; i < each_2_blocks.length; i += 1) {
						each_2_blocks[i].d(1);
					}
					each_2_blocks.length = each_value_2.length;
				}

				if (changed.kernels && svg_1_visibility_value !== (svg_1_visibility_value = ctx.kernels.filter(function (p) {
					return p.active;
				}).length > 0 ? 'visible' : 'hidden')) {
					setAttribute(svg_1, "visibility", svg_1_visibility_value);
				}

				if (changed.context && svg_width_value !== (svg_width_value = ctx.context.width)) {
					setAttribute(svg$$1, "width", svg_width_value);
				}

				if (changed.context && svg_height_value !== (svg_height_value = ctx.context.height)) {
					setAttribute(svg$$1, "height", svg_height_value);
				}

				var kernelcovmat_changes = {};
				if (changed.countDimensions) kernelcovmat_changes.n = ctx.countDimensions;
				kernelcovmat._set(kernelcovmat_changes);
			},
			d: function d(detach) {
				if (detach) {
					detachNode(div);
				}

				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(text_1);
					detachNode(div_1);
				}

				if (component.refs.zero === line_1) component.refs.zero = null;
				if (component.refs.graph === g) component.refs.graph = null;

				destroyEach(each_1_blocks, detach);

				if (if_block) if_block.d();

				destroyEach(each_2_blocks, detach);

				removeListener(svg_1, "mouseover", mouseover_handler);
				if (component.refs.svgArea === svg$$1) component.refs.svgArea = null;
				kernelcovmat.destroy();
				if (component.refs.covMat === kernelcovmat) component.refs.covMat = null;
			}
		};
	}

	// (1:47) {#each kernels as k}
	function create_each_block$9(component, ctx) {
		var label,
		    input,
		    input_id_value,
		    text$$1,
		    text_1_value = ctx.k.name,
		    text_1;

		function input_change_handler() {
			ctx.each_value[ctx.k_index].active = input.checked;
			component.set({ kernels: ctx.kernels });
		}

		return {
			c: function c() {
				label = createElement("label");
				input = createElement("input");
				text$$1 = createText(" ");
				text_1 = createText(text_1_value);
				addListener(input, "change", input_change_handler);
				setAttribute(input, "type", "checkbox");
				input.id = input_id_value = "checkbox" + ctx.k.name;
			},
			m: function m(target, anchor) {
				insertNode(label, target, anchor);
				appendNode(input, label);

				input.checked = ctx.k.active;

				appendNode(text$$1, label);
				appendNode(text_1, label);
			},
			p: function p(changed, _ctx) {
				ctx = _ctx;
				input.checked = ctx.k.active;
				if (changed.kernels && input_id_value !== (input_id_value = "checkbox" + ctx.k.name)) {
					input.id = input_id_value;
				}

				if (changed.kernels && text_1_value !== (text_1_value = ctx.k.name)) {
					text_1.data = text_1_value;
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(label);
				}

				removeListener(input, "change", input_change_handler);
			}
		};
	}

	// (19:8) {#each trainingPoints as pt, idx}
	function create_each_block_1$2(component, ctx) {
		var circle$$1, circle_class_value, circle_cx_value, circle_cy_value;

		var if_block = ctx.pt.active && create_if_block$6(component, ctx);

		return {
			c: function c() {
				if (if_block) if_block.c();
				circle$$1 = createSvgElement("circle");
				circle$$1._svelte = { component: component, ctx: ctx };

				addListener(circle$$1, "click", click_handler$2);
				setAttribute(circle$$1, "class", circle_class_value = "trainingPoint " + (ctx.pt.active ? 'active' : 'inactive') + " svelte-t9dbix");
				setAttribute(circle$$1, "cx", circle_cx_value = toU$3(ctx.context, ctx.pt.x) + ctx.context.width / ctx.countDimensions / 2);
				setAttribute(circle$$1, "cy", circle_cy_value = toV$4(ctx.context, ctx.pt.y));
				setAttribute(circle$$1, "r", "6");
			},
			m: function m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insertNode(circle$$1, target, anchor);
			},
			p: function p(changed, ctx) {
				if (ctx.pt.active) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$6(component, ctx);
						if_block.c();
						if_block.m(circle$$1.parentNode, circle$$1);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				circle$$1._svelte.ctx = ctx;
				if (changed.trainingPoints && circle_class_value !== (circle_class_value = "trainingPoint " + (ctx.pt.active ? 'active' : 'inactive') + " svelte-t9dbix")) {
					setAttribute(circle$$1, "class", circle_class_value);
				}

				if ((changed.context || changed.trainingPoints || changed.countDimensions) && circle_cx_value !== (circle_cx_value = toU$3(ctx.context, ctx.pt.x) + ctx.context.width / ctx.countDimensions / 2)) {
					setAttribute(circle$$1, "cx", circle_cx_value);
				}

				if ((changed.context || changed.trainingPoints) && circle_cy_value !== (circle_cy_value = toV$4(ctx.context, ctx.pt.y))) {
					setAttribute(circle$$1, "cy", circle_cy_value);
				}
			},
			d: function d(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(circle$$1);
				}

				removeListener(circle$$1, "click", click_handler$2);
			}
		};
	}

	// (20:8) {#if pt.active}
	function create_if_block$6(component, ctx) {
		var circle$$1, circle_cx_value, circle_cy_value;

		return {
			c: function c() {
				circle$$1 = createSvgElement("circle");
				setAttribute(circle$$1, "cx", circle_cx_value = toU$3(ctx.context, ctx.pt.x) + ctx.context.width / ctx.countDimensions / 2);
				setAttribute(circle$$1, "cy", circle_cy_value = toV$4(ctx.context, ctx.pt.y));
				setAttribute(circle$$1, "r", "3");
				setAttribute(circle$$1, "fill", "rgba(0,0,0,0.6)");
			},
			m: function m(target, anchor) {
				insertNode(circle$$1, target, anchor);
			},
			p: function p(changed, ctx) {
				if ((changed.context || changed.trainingPoints || changed.countDimensions) && circle_cx_value !== (circle_cx_value = toU$3(ctx.context, ctx.pt.x) + ctx.context.width / ctx.countDimensions / 2)) {
					setAttribute(circle$$1, "cx", circle_cx_value);
				}

				if ((changed.context || changed.trainingPoints) && circle_cy_value !== (circle_cy_value = toV$4(ctx.context, ctx.pt.y))) {
					setAttribute(circle$$1, "cy", circle_cy_value);
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(circle$$1);
				}
			}
		};
	}

	// (35:12) {#if firstClick}
	function create_if_block_1$3(component, ctx) {
		var text$$1, text_1;

		return {
			c: function c() {
				text$$1 = createSvgElement("text");
				text_1 = createText("(hover for information)");
				setAttribute(text$$1, "class", "hoverText svelte-t9dbix");
				setAttribute(text$$1, "x", 30);
				setAttribute(text$$1, "y", "1.2em");
			},
			m: function m(target, anchor) {
				insertNode(text$$1, target, anchor);
				appendNode(text_1, text$$1);
			},
			d: function d(detach) {
				if (detach) {
					detachNode(text$$1);
				}
			}
		};
	}

	// (41:14) {#each currentParams as pList}
	function create_each_block_2$2(component, ctx) {
		var tspan,
		    text_value = ctx.pList.name,
		    text$$1,
		    text_1;

		var each_value_3 = ctx.pList.params;

		var each_blocks = [];

		for (var i = 0; i < each_value_3.length; i += 1) {
			each_blocks[i] = create_each_block_3(component, get_each_context_1(ctx, each_value_3, i));
		}

		return {
			c: function c() {
				tspan = createSvgElement("tspan");
				text$$1 = createText(text_value);
				text_1 = createText(":\n                ");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				setAttribute(tspan, "x", "5");
				setAttribute(tspan, "dy", "1.5em");
			},
			m: function m(target, anchor) {
				insertNode(tspan, target, anchor);
				appendNode(text$$1, tspan);
				appendNode(text_1, tspan);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(tspan, null);
				}
			},
			p: function p(changed, ctx) {
				if (changed.currentParams && text_value !== (text_value = ctx.pList.name)) {
					text$$1.data = text_value;
				}

				if (changed.currentParams) {
					each_value_3 = ctx.pList.params;

					for (var i = 0; i < each_value_3.length; i += 1) {
						var child_ctx = get_each_context_1(ctx, each_value_3, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_3(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(tspan, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_3.length;
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(tspan);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (44:16) {#each pList.params as p,i}
	function create_each_block_3(component, ctx) {
		var tspan,
		    text_value = ctx.p.name,
		    text$$1,
		    text_1,
		    text_2_value = ctx.p.value + ', ',
		    text_2;

		return {
			c: function c() {
				tspan = createSvgElement("tspan");
				text$$1 = createText(text_value);
				text_1 = createText(" = ");
				text_2 = createText(text_2_value);
				setAttribute(tspan, "fill", "rgb(245, 181, 62)");
				setAttribute(tspan, "font-style", "italic");
			},
			m: function m(target, anchor) {
				insertNode(tspan, target, anchor);
				appendNode(text$$1, tspan);
				appendNode(text_1, tspan);
				appendNode(text_2, tspan);
			},
			p: function p(changed, ctx) {
				if (changed.currentParams && text_value !== (text_value = ctx.p.name)) {
					text$$1.data = text_value;
				}

				if (changed.currentParams && text_2_value !== (text_2_value = ctx.p.value + ', ')) {
					text_2.data = text_2_value;
				}
			},
			d: function d(detach) {
				if (detach) {
					detachNode(tspan);
				}
			}
		};
	}

	function get_each_context$9(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.k = list[i];
		child_ctx.each_value = list;
		child_ctx.k_index = i;
		return child_ctx;
	}

	function get_each_1_context$2(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.pt = list[i];
		child_ctx.each_value_1 = list;
		child_ctx.idx = i;
		return child_ctx;
	}

	function click_handler$2(event$$1) {
		var _svelte = this._svelte,
		    component = _svelte.component,
		    ctx = _svelte.ctx;


		component.toggle(ctx.idx);
	}

	function get_each_2_context$2(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.pList = list[i];
		child_ctx.each_value_2 = list;
		child_ctx.pList_index = i;
		return child_ctx;
	}

	function get_each_context_1(ctx, list, i) {
		var child_ctx = Object.create(ctx);
		child_ctx.p = list[i];
		child_ctx.each_value_3 = list;
		child_ctx.i = i;
		return child_ctx;
	}

	function KernelCombinations(options) {
		var _this = this;

		init(this, options);
		this.refs = {};
		this._state = assign(data$d(), options.data);
		this._recompute({ context: 1 }, this._state);
		this._intro = true;
		this._handlers.update = [onupdate$4];

		if (!document.getElementById("svelte-t9dbix-style")) add_css$b();

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$d(this, this._state);

		this.root._oncreate.push(function () {
			oncreate$8.call(_this);
			_this.fire("update", { changed: assignTrue({}, _this._state), current: _this._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(KernelCombinations.prototype, proto);
	assign(KernelCombinations.prototype, methods$5);

	KernelCombinations.prototype._recompute = function _recompute(changed, state) {
		if (changed.context) {
			if (this._differs(state.line, state.line = line$3(state))) changed.line = true;
			if (this._differs(state.zero, state.zero = zero$3(state))) changed.zero = true;
			if (this._differs(state.sdPlus, state.sdPlus = sdPlus$3(state))) changed.sdPlus = true;
			if (this._differs(state.sdMinus, state.sdMinus = sdMinus$3(state))) changed.sdMinus = true;
			if (this._differs(state.sdArea, state.sdArea = sdArea$3(state))) changed.sdArea = true;
		}
	};

	var TeaserComponent = new Teaser({ // eslint-disable-line no-unused-vars
	  target: document.querySelector('#Teaser')
	});
	var MultivariateComponent = new Multivariate({ // eslint-disable-line no-unused-vars
	  target: document.querySelector('#Multivariate')
	});
	var MarginalizationConditioningComponent = new MarginalizationConditioning({ // eslint-disable-line no-unused-vars
	  target: document.querySelector('#MarginalizationConditioning')
	});
	var MultipleKernelsComponent = new MultipleKernels({ // eslint-disable-line no-unused-vars
	  target: document.querySelector('#MultipleKernels')
	});
	var PriorFigureComponent = new PriorFigure({ // eslint-disable-line no-unused-vars
	  target: document.querySelector('#PriorFigure')
	});
	var PosteriorFigureComponent = new PosteriorFigure({ // eslint-disable-line no-unused-vars
	  target: document.querySelector('#PosteriorFigure')
	});
	var PriorSamplingComponent = new PriorSampling({ // eslint-disable-line no-unused-vars
	  target: document.querySelector('#Prior')
	});
	var PosteriorComponent = new Posterior({ // eslint-disable-line no-unused-vars
	  target: document.querySelector('#Posterior')
	});
	var KernelCombinationsComponent = new KernelCombinations({ // eslint-disable-line no-unused-vars
	  target: document.querySelector('#KernelCombinations')
	});

}());
